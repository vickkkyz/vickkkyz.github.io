<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>读《告白》有感</title>
    <link href="/2024/02/06/%E8%AF%BB%E5%90%8E%E6%84%9F/%E5%91%8A%E7%99%BD/"/>
    <url>/2024/02/06/%E8%AF%BB%E5%90%8E%E6%84%9F/%E5%91%8A%E7%99%BD/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>剧透警告</p>          </div><p>告白？看到这个词，我以为是传统意义上的告白（即男生向女生表白的意思），但是看小说简介明明是一个悬疑片，于是我带着好奇的心理读了下去…</p><p>看完之后非常感慨，真的不愧是日本悬疑小说，描写人物心理的细腻，词语的暗示，以及细节的处理都非常好，环环相扣，看完第一章就想立马看下一章。另外，这个视角我认为也很新奇，第一次见。刚开始看第一章的时候以为全文是以森口老师的视角来展开的，后来看到第二章发现换了一个视角，啊，我恍然大悟，「告白」原来是这个意思，是每个人的陈述，白，即表达想法。这种写法很吸引我，几天就看完了。</p><p>文章一共分为六章，分别通过六个不同的视角来表达他们的经历、心理活动、立场。这场悲剧到底谁是罪魁祸首？如果要说，每个人都有过错，每个人都是扭曲变态的….</p><p>全文围绕着班主任森口悠子的女儿爱美遇害展开，通过不同人不同的立场阐述，直接导致死亡的是班里的下村直树，间接的是渡边修哉，可是为什么未成年人会想要杀人呢，离不开家长们潜移默化的言语和行为，逐渐造成了孩子扭曲变态的心灵。本文也反映了影响青少年犯罪的重要因素–家庭环境，以及青少年犯罪相关的法律的不完善。</p><div class="note note-primary no-icon">            <p>第一章：森口悠子</p>          </div><p>开篇的场景就是森口老师最后一次在班上讲述她的经历，通过此延展到女儿遇害，直接指出凶手的行为，引发大家的猜想，为什么她不选择报警呢，因为根据日本未成年人犯罪法，就算是杀人，也不过是去少管所呆一阵子，最后轻飘飘的放出来。</p><p>难道森口悠子就是完全的受害者吗？她知道报警制裁不了这两个人，于是暗中开始了自己的报复….最初她想要将HIV患者(森口的老公)的血加到这两个加害者的牛奶中，企图让他们患病，失败后，她又通过新班主任寺田良辉间接使下村直树精神失常，甚至导致直树下手杀了自己的母亲，最后将修哉制作的炸药放到了修哉君母亲的实验室，导致她遇害。</p><div class="note note-primary no-icon">            <p>第二章：班长北原美月</p>          </div><p>“愚蠢的庸人忘记了一件最重要的事情，那就是，自己并没有制裁他人的权利…”</p><p>班里开始有霸凌修哉的苗头，并且越来越恶劣，所有人被发送邮件，如果不参与制裁修哉的行动，TA就将被视为修哉君的同党。作为班长，美月和老师接触的最多，有人向老师打小报告（这里其实是森口暗示维特-新老师故意在班里说的），他们认为是美月干的，于是开始制裁美月。美月和修哉像是同一条绳子上的蚂蚱抱团取暖，可是修哉是否将她视作朋友呢？并没有，只是要制作炸弹的利用工具。最后他们在吵架的时候，修哉把美月杀了，放到了”实验室“的冰箱里….</p><div class="note note-primary no-icon">            <p>第三章：下村直树的二姐</p>          </div><p>“扭曲的爱，扭曲的家教，扭曲的教育，以及扭曲的妻子关系…一旦揭开盖子，必然会找到扭曲之处，于是得出了该案理所当然会发生的结论。”</p><p>表面上是二姐，实际上是通过二姐读母亲日记的视角，来描述下村直树在家时母亲的告白，自从发生了那件事，直树就一直将自己封闭在屋里，脾气也变得喜怒无常，一度以为自己得了HIV，可能不久就将与人世，每次吃饭都要和家人的分开，上完厕所会一直刷马桶，衣服也要自己洗，母亲尝试给他做好吃的，吃到好吃的，他会泪流满面，母亲劝他去上学，他又暴躁得像换了一个人…最后母亲得知了下村就是杀害爱美的直接凶手，母亲心灰意冷，她一直以来引以为傲的教育，竟然教出了这么一个恐怖的人。最终母亲决定和她最爱的儿子一起同归于尽，最后直树把母亲杀了。</p><div class="note note-primary no-icon">            <p>第四章：下村直树</p>          </div><p>下村直树是一个老实、胆小、缺乏自信的人，被渡边修哉搭讪，他以为交到了好朋友，于是一起谋划着修哉的计划，实施杀害爱美的计划，可实际上，修哉一直都看不起他，认为他是个笨蛋。在计划实施的最后，爱美被电倒，自大的修哉以为计划完美完成，就直接走了，被拉下的直树本要将女孩扔到水池中，却发现女孩并没有死，欣喜若狂，渡边的计划失败了，把女孩扔到水池溺死了，他做成了渡边没有完成的计划，此时非常得意。</p><p>在班会上得知那天喝的牛奶被放了HIV病人的血，以及森口老师当着全班同学的面暗示他是凶手，直树瞬间感到非常害怕，害怕自己会因为感染HIV而死，害怕被警察抓走…</p><div class="note note-primary no-icon">            <p>第五章：渡边修哉</p>          </div><p>“我唯一爱的人因为我的存在而痛苦，让我非常难过”</p><p>渡边最爱的是他的母亲，母亲非常聪明，有着丰富的理工学科的知识，一直以来都是渡边最崇拜的对象。从小母亲就开始教他理工方面的知识，化学、物理、电路。可是突然有一天，原来的教授来劝母亲回大学继续学习，母亲因为渡边而拒绝了这个请求，后来母亲就变了，将压抑的憋屈全部发泄到渡边身上，然后父母离婚了，母亲离开了。除了母亲，没有人会赞赏渡边以及他的发明，因此渡边一直渴望再见母亲一面。后来父亲再婚，新继母怀孕了，把渡边赶到河边的杂物间，也就是他的”实验室”。因为不知道母亲的联系方式，渡边就想制造一件全民关注的事件来引起母亲的注意，参加比赛获奖的影响力远远小于刑事案件，于是想到制作电人钱包来杀人，并将苗头指向爱美。后来计划失败，他又谋划着更大的事情—制造炸弹，安置在学校，将学校炸了。</p><div class="note note-primary no-icon">            <p>第六章：渡边修哉和森口老师最后的通话</p>          </div><p>“我明白了，能够让一切仇恨都烟消云散的复仇是不存在的”</p><p>森口悠子说出了自己做的全部事情，包括往牛奶里注射丈夫樱宫的血液，故意在班会上说出凶手但又不直接指明，间接误导寺田良辉每周家访给下村直树施加压力，将炸弹移到渡边母亲的实验室…</p><p><img src="/../../image/novel/gaobai.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
      <category>小说</category>
      
      <category>悬疑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客大事件</title>
    <link href="/2024/01/06/%E5%8D%9A%E5%AE%A2%E5%A4%A7%E4%BA%8B%E4%BB%B6/"/>
    <url>/2024/01/06/%E5%8D%9A%E5%AE%A2%E5%A4%A7%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文按照时间顺序，记录博客的装修进程，着重记录踩坑和经验，希望能给和我遇到一样问题的小伙伴一些参考。</p>          </div><h1 id="2024-3-12-给文章设置密码"><a href="#2024-3-12-给文章设置密码" class="headerlink" title="2024.3.12 给文章设置密码"></a>2024.3.12 给文章设置密码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save hexo-blog-encrypt<br></code></pre></td></tr></table></figure><p>然后用<code>password</code>字段设置文章密码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">---<br><span class="hljs-attr">title</span>: <span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span><br><span class="hljs-attr">date</span>: <span class="hljs-number">2016</span>-<span class="hljs-number">03</span>-<span class="hljs-number">30</span> <span class="hljs-number">21</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02</span><br><span class="hljs-attr">password</span>: <span class="hljs-number">12345</span><br>---<br></code></pre></td></tr></table></figure><p>也可以自定义文章的提示信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">---<br><span class="hljs-attr">title</span>: <span class="hljs-title class_">Hexo</span>-<span class="hljs-title class_">Fluid</span>主题-给文章设置密码<br><span class="hljs-attr">categories</span>: 学习教程<br><span class="hljs-attr">password</span>: <span class="hljs-number">12345</span><br><span class="hljs-attr">abstract</span>: 有东西被加密了, 请输入密码查看.<br><span class="hljs-attr">message</span>: 您好, 这里需要密码.<br><span class="hljs-attr">wrong_pass_message</span>: 抱歉, 这个密码看着不太对, 请再试试.<br><span class="hljs-attr">wrong_hash_message</span>: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.<br><span class="hljs-attr">date</span>: <span class="hljs-number">2021</span>/<span class="hljs-number">12</span>/<span class="hljs-number">3</span> <span class="hljs-number">21</span>:<span class="hljs-number">19</span>:<span class="hljs-number">20</span><br><span class="hljs-attr">tags</span>:<br>  - <span class="hljs-title class_">Hexo</span><br>---<br></code></pre></td></tr></table></figure><ul><li><code>abstract</code> ：等同于信息头中的<code>excerpt</code>效果。</li><li><code>message</code> ：是在输入密码处显示的内容。</li><li><code>wrong_pass_message</code> ：是在输入错误密码时弹窗的信息内容。</li></ul><p>参考：<a href="https://tothefor.com/DragonOne/61a962e8.html">Hexo-Fluid主题-给文章设置密码</a></p><h1 id="2024-1-7-1-恶搞浏览器网页标题"><a href="#2024-1-7-1-恶搞浏览器网页标题" class="headerlink" title="2024.1.7(1) 恶搞浏览器网页标题"></a>2024.1.7(1) 恶搞浏览器网页标题</h1><p>在<code>根目录/node_modules/hexo-theme-fluid/source/js</code>这里！创建一个名为FunnyTitle.js的文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">OriginTitle</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>;<br><span class="hljs-keyword">var</span> titleTime;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">hidden</span>) &#123;<br>        $(<span class="hljs-string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&quot;/image/beautify/xinsuixuanzhong.png&quot;</span>);<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;_(:з」∠)_不要走！&#x27;</span>;<br>        <span class="hljs-built_in">clearTimeout</span>(titleTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        $(<span class="hljs-string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&quot;/image/beautify/favicon.ico&quot;</span>);<br>        <span class="hljs-comment">//document.title = &#x27;(*/ω＼*)你来啦&#x27; + OriginTitle;</span><br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;(*/ω＼*)你来啦~~&#x27;</span>;<br>        titleTime = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-title class_">OriginTitle</span>;<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后在<code>根目录/node_modules/hexo-theme-fluid/layout/layout.ejs</code>中引用上面的文件，具体写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;!--写在body标签内--&gt;<br>&lt;!--浏览器搞笑标题--&gt;<br>&lt;script type=&quot;text/javascript&quot; src=&quot;\js\FunnyTitle.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/69211731">知乎</a></p><h1 id="2024-1-7-2-给网站添加「霞鹜文楷」字体"><a href="#2024-1-7-2-给网站添加「霞鹜文楷」字体" class="headerlink" title="2024.1.7(2) 给网站添加「霞鹜文楷」字体"></a>2024.1.7(2) 给网站添加「霞鹜文楷」字体</h1><ol><li><p>修改这个文件<code>根目录/node_modules/hexo-theme-fluid/layout/_partials/head.ejs</code></p><p>在<code>&lt; head &gt;</code>标签内添加这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;!-- 通过cdn引入霞鹭文楷字体 --&gt;<br>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;<br></code></pre></td></tr></table></figure></li><li><p>在<code>根目录/node_modules/hexo-theme-fluid/source/css</code>下面添加文件<code>custom.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-class">.markdown-body</span>,<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;LXGW WenKai Screen&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>_config.fluid.html</code>的<code>font</code>标签的<code>font_family</code>字段添加<code>&quot;LXGW Wenkai Screen&quot;</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">&quot;LXGW Wenkai Screen&quot;</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://penghh.fun/2023/05/07/2023-5-7-hexo_blog_font/">彭宏豪</a></p><h1 id="2024-1-7-3-背景固定-毛玻璃效果"><a href="#2024-1-7-3-背景固定-毛玻璃效果" class="headerlink" title="2024.1.7(3) 背景固定+毛玻璃效果"></a>2024.1.7(3) 背景固定+毛玻璃效果</h1><div class="note note-success">            <p>背景固定</p>          </div><p>博客根目录新建一个文件夹<code>scripts</code>，在里面新建一个文件<code>injector.js</code>，内容为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">root</span>: siteRoot = <span class="hljs-string">&quot;/&quot;</span> &#125; = hexo.<span class="hljs-property">config</span>;<br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&quot;body_begin&quot;</span>, <span class="hljs-string">`&lt;div id=&quot;web_bg&quot;&gt;&lt;/div&gt;`</span>);<br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&quot;body_end&quot;</span>, <span class="hljs-string">`&lt;script src=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>js/backgroundize.js&quot;&gt;&lt;/script&gt;`</span>);<br></code></pre></td></tr></table></figure><p>在<code>node_modules/hexo-theme-fluid/source/js</code>下新建文件<code>backgroundize.js</code>，内容为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span><br>    .<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#web_bg&#x27;</span>)<br>    .<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">`background-image: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">document</span>.querySelector(<span class="hljs-string">&#x27;.banner&#x27;</span>).style.background.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>]&#125;</span>;position: fixed;width: 100%;height: 100%;z-index: -1;background-size: cover;`</span>);<br><br><span class="hljs-variable language_">document</span><br>    .<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#banner&quot;</span>)<br>    .<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">&#x27;background-image: url()&#x27;</span>)<br><br><span class="hljs-variable language_">document</span><br>    .<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#banner .mask&quot;</span>)<br>    .<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">&#x27;background-color:rgba(0,0,0,0)&#x27;</span>)<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>毛玻璃</p>          </div><p><code>_config.fluid.yml</code>中修改文章背景色为透明：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 主面板背景色</span><br><span class="hljs-comment"># Color of main board</span><br><span class="hljs-attr">board_color:</span> <span class="hljs-string">&quot;#ffffff80&quot;</span><br><span class="hljs-attr">board_color_dark:</span> <span class="hljs-string">&quot;#00000080&quot;</span><br></code></pre></td></tr></table></figure><p>在<code>node_modules/hexo-theme-fluid/source/css</code>中新建文件<code>cloudedGlass.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#board</span> &#123;<br>  -webkit-backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>);<br>  backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>_config.fluid.yml</code>引入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">custom_css:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/css/cloudedGlass.css</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://qingshaner.com/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF%E5%9B%BA%E5%AE%9A(ES6%E6%94%B9%E5%86%99%E7%89%88)%E4%B8%8E%E6%AF%9B%E7%8E%BB%E7%92%83%E5%BA%95%E9%A1%B5/">清山的博客</a></p><h1 id="2024-1-7-4-修改行内代码颜色"><a href="#2024-1-7-4-修改行内代码颜色" class="headerlink" title="2024.1.7(4) 修改行内代码颜色"></a>2024.1.7(4) 修改行内代码颜色</h1><p>修改这个文件：<code>博客根目录/node_modules/hexo-theme-fluid/source/css/_ pages/_base/base.styl</code>，找到code这一行，修改color的值。</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs styl"><span class="hljs-selector-tag">code</span><br>  <span class="hljs-comment">//color inherit</span><br>  <span class="hljs-attribute">color</span> <span class="hljs-number">#E05B35</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/ba692a97a602">简书</a></p><h1 id="2024-1-6-1-页脚添加网站运行时间"><a href="#2024-1-6-1-页脚添加网站运行时间" class="headerlink" title="2024.1.6(1) 页脚添加网站运行时间"></a>2024.1.6(1) 页脚添加网站运行时间</h1><p>需要修改主题的源代码，在网上搜索了很多类似的，都要改<code>themes/source</code>下面的文件，但是我的themes文件夹下面是空的！搜索了几篇文章，发现其实有两种方式可以加载fluid主题。</p><p><strong>方式一：</strong>（我采用的是这种方式）</p><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/config.yml">config.yml</a> 内容复制进去。</p><p><strong>方式二</strong>：（网上大部分采用的这个方法，所以themes下面有内容）</p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 Hexo 博客目录中的 <code>themes</code> 目录，并将解压出的文件夹重命名为 fluid。</p><p>参考：<a href="https://emoryhuang.cn/blog/1729600336.html">https://emoryhuang.cn/blog/1729600336.html</a></p><hr><p><strong>所以方式一该怎么修改源代码呢？</strong></p><p>我们并不是在<code>themes</code>文件，而是npm帮我们管理的，位置在<code>博客根目录/node_modules/hexo-theme-fluid/source</code></p><p>所以！就直接在这里改。</p><p>在<code>node_modules/hexo-theme-fluid/source/js</code>下新增文件<code>duration.js</code>，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createtime</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> grt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;12/24/2023 22:51:00&quot;</span>);<span class="hljs-comment">//在此处修改你的建站时间，格式：月/日/年 时:分:秒</span><br>    now.<span class="hljs-title function_">setTime</span>(now.<span class="hljs-title function_">getTime</span>() + <span class="hljs-number">250</span>);<br>    days = (now - grt) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>; dnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(days);<br>    hours = (now - grt) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum); hnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(hours);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">String</span>(hnum).<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123; hnum = <span class="hljs-string">&quot;0&quot;</span> + hnum; &#125; minutes = (now - grt) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum);<br>    mnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(minutes); <span class="hljs-keyword">if</span> (<span class="hljs-title class_">String</span>(mnum).<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123; mnum = <span class="hljs-string">&quot;0&quot;</span> + mnum; &#125;<br>    seconds = (now - grt) / <span class="hljs-number">1000</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * hnum) - (<span class="hljs-number">60</span> * mnum);<br>    snum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(seconds); <span class="hljs-keyword">if</span> (<span class="hljs-title class_">String</span>(snum).<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123; snum = <span class="hljs-string">&quot;0&quot;</span> + snum; &#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;timeDate&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;本站已安全运行 &quot;</span> + dnum + <span class="hljs-string">&quot; 天 &quot;</span>;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;times&quot;</span>).<span class="hljs-property">innerHTML</span> = hnum + <span class="hljs-string">&quot; 小时 &quot;</span> + mnum + <span class="hljs-string">&quot; 分 &quot;</span> + snum + <span class="hljs-string">&quot; 秒&quot;</span>;<br>&#125;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-string">&quot;createtime()&quot;</span>, <span class="hljs-number">250</span>);<br></code></pre></td></tr></table></figure><p>然后在<code>_config.fluid.yml</code>的<code>footer</code>标签中添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">&lt;!--</span> <span class="hljs-string">页脚添加网站运行时间</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">&lt;div&gt;</span><br>    <span class="hljs-string">&lt;span</span> <span class="hljs-string">id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br>    <span class="hljs-string">&lt;span</span> <span class="hljs-string">id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br>    <span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;/js/duration.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://www.liujunxiang0076.asia/2023/08/03/hexo%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/">https://www.liujunxiang0076.asia/2023/08/03/hexo%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/</a></p><h1 id="2024-1-6-2-美化的标签语法"><a href="#2024-1-6-2-美化的标签语法" class="headerlink" title="2024.1.6(2) 美化的标签语法"></a>2024.1.6(2) 美化的标签语法</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note default %&#125;<br>default 提示块标签<br>&#123;% endnote %&#125;<br><br>&#123;% note primary no-icon %&#125;  //可使用语法 no-icon去掉小图标<br>primary 提示块标签<br>&#123;% endnote %&#125;<br><br>&#123;% note success %&#125;<br>success 提示块标签<br>&#123;% endnote %&#125;<br><br>&#123;% note info %&#125;<br>info 提示块标签<br>&#123;% endnote %&#125;<br><br>&#123;% note warning %&#125;<br>warning 提示块标签<br>&#123;% endnote %&#125;<br><br>&#123;% note danger %&#125;<br>danger 提示块标签<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>default 提示块标签</p>          </div><div class="note note-primary no-icon">            <p>  &#x2F;&#x2F;可使用语法 no-icon去掉小图标<br>primary 提示块标签</p>          </div><div class="note note-success">            <p>success 提示块标签</p>          </div><div class="note note-info">            <p>info 提示块标签</p>          </div><div class="note note-warning">            <p>warning 提示块标签</p>          </div><div class="note note-danger">            <p>danger 提示块标签</p>          </div><p>参考：<a href="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-note/fluid-note/">CangLan</a></p><h1 id="2023-12-26-添加嘉然看板娘"><a href="#2023-12-26-添加嘉然看板娘" class="headerlink" title="2023.12.26 添加嘉然看板娘"></a>2023.12.26 添加嘉然看板娘</h1><p>把如下代码复制到_config.fluid.yml的footer标签内：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">&lt;!--</span> <span class="hljs-string">Load</span> <span class="hljs-string">TweenLite</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;https://cdn.jsdelivr.net/npm/greensock@1.20.2/dist/TweenLite.js&quot;&gt;&lt;/script&gt;</span><br><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">Copyrighted</span> <span class="hljs-string">cubism</span> <span class="hljs-string">SDK</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">Load</span> <span class="hljs-string">Pixi</span> <span class="hljs-string">(dependency</span> <span class="hljs-string">for</span> <span class="hljs-string">cubism</span> <span class="hljs-number">2</span><span class="hljs-string">/4</span> <span class="hljs-string">integrated</span> <span class="hljs-string">loader)</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;https://cdn.jsdelivr.net/npm/pixi.js@5.3.6/dist/pixi.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">Load</span> <span class="hljs-string">cubism</span> <span class="hljs-number">4</span> <span class="hljs-string">integrated</span> <span class="hljs-string">loader</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.3.1/dist/cubism4.min.js&quot;&gt;&lt;/script&gt;</span><br><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">Load</span> <span class="hljs-string">pio</span> <span class="hljs-string">and</span> <span class="hljs-string">alternative</span> <span class="hljs-string">loader</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">&lt;link</span> <span class="hljs-string">href=&quot;https://cdn.jsdelivr.net/gh/vickkkyz/vickkkyz.github.io@2.0/css/pio.css&quot;</span> <span class="hljs-string">rel=&quot;stylesheet&quot;</span> <span class="hljs-string">type=&quot;text/css&quot;/&gt;</span><br><span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;https://cdn.jsdelivr.net/gh/journey-ad/blog-img@76ba2b3/live2d/lib/pio.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;https://cdn.jsdelivr.net/gh/journey-ad/blog-img@76ba2b3/live2d/lib/pio_sdk4.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;script</span> <span class="hljs-string">src=&quot;https://cdn.jsdelivr.net/gh/journey-ad/blog-img@76ba2b3/live2d/lib/load.js&quot;&gt;&lt;/script&gt;</span><br></code></pre></td></tr></table></figure><p>但是由于直接使用，嘉然不适应本主题(fluid)，需要把pio.css文件下载下来放入本地进行自己修改给她定义一下尺寸，在#pio下面添加一个height: 240px 限制一下大小。因为博客要可以线上访问到这个url才行，所以我把它放到github上了。然后上面的那个url换成自己的地址。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#pio</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">240px</span>;<br>    <span class="hljs-attribute">vertical-align</span>: middle<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法来源：<a href="https://www.moeshou.com/310/">叶小兽</a></p><hr><p>但是！！好像就是因为github的原因，我的博客在加载嘉然的时候并没有加载pio.css这个文件，设置的大小不生效。</p><div class="note note-success">            <p>通过大佬<a href="https://seailor.com/">Seailor</a>的帮助，我将github的链接转换成了jsdelivr的CDN来加速访问，这样就生效了</p>          </div><p><img src="/../image/beautify/jsdelivr.png"></p><p>如果没设置过，这边应该是显示：<code>Create a new release</code>，进入下图，自己定义版本的名称，选择要发布的分支，发布之后，就可以使用， 使用方法：<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code>，文件路径是以选择的分支为根目录的相对路径。</p><p>比如：<code>https://cdn.jsdelivr.net/gh/vickkkyz/vickkkyz.github.io@v1.0/css/pio.css</code></p><p><img src="/../image/beautify/release.png"></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/336641644">随风</a></p><p>感谢：<a href="https://seailor.com/">Seailor</a></p>]]></content>
    
    
    <categories>
      
      <category>博客美化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从头开始</title>
    <link href="/2023/12/24/start/"/>
    <url>/2023/12/24/start/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6edacbf8daab1f81c1033bc185c35992fd834accd201b5bbc034ca0f8235e695">2e77dea67943b4f27ecfe13b0003f82deb4a4af49e0457310f99fc9de3b6817ac5f9b11879a35bbbed82129e9b809c05fcca375f88ed05d49ec4ff3a41f9af7eeed8b16e97bde0cd9185b400da6b6ebded0e62403b27eee90437d57de982094e9df3edaa312bff8914b9f261c6eab76805a0d497d1474c441599e8bab9929e1e82ed0ebb51ff7e3026b46509d7ce04c21a1a1705bfc3359884574eaf472b5a09dc8f602db9ee2f07d0d6b2f64b62064a039c1491e30795f47b9761cee6885da04c8ff53ae47e2aad4039221b6b960df46a9fb7169b75214b2ec0cde49b45db66c75d241f5dfd07d843e601edcd8fafc0cedae5ce2be081a0b4402a49467453b303185a01425694df302b197b2bb52e593880d6a7bec19b242ed2ee9d8b4ca147a023c315c9558fef9735f4ca9f2f8ff08252e6250a4f37a503b85909397bfced4bc4a3dee4c5aea63768962f931b8f0df96abc61942fdeaf9f58ef6a322df9a12a60b2de0d8856e4c41f95eaebf11b47c669e4fb54ddffe78b67996b3603bced4c90771eb558a6ad6ed6152f1a5cd9ee1277d947f002a4d2b668044dc67a1a02ece9a2d315437aee13842546f85ec2aa860b6fbc215f21f606bd1f9cb5e3eda4933619d2f185a6d30af3cc8a2daa140caf0bbf3dea2c7f8742b66d35754215a74d4cae7a983b219a8935ed668b6101f9a5233a06f619e67642b3e9b1fa328be63b7e5e44b070433200d3a7ccc9f8f747773f5f5bf8947a79f1101d4ae39997a84db8c6fac0a1f40ac4ac11e4cac0358510ff43d9c8b3aed9cdb5241657e6110afb3476f65cc1694052c18ab083c07d1567eaae578acb88d13415b851df759f2e846387062a9f7e669f4be9d442ec4794cd28b20796142bc736921e37c7e631b54f7ff4877afc2ba5807e3ae921e72709bf59926b3f88b551912d8737b18d036e45f7c8601844acfa5d3e0593844a8118a3a10dd88c3a4b03492c114e30503246c560b5c178bd8ebc902592d57de2af2267a99e8dbd94619cf001b417b0ca34e2bdc8afb934fdbf1f565fdd5ca52f5b45a05356977213481ae30836173bfac60bda168b2da1fd527ad96fdbfde8f2621647ca16ef1838501b6cf4f91a42d434b70818378abfdbd6070cff67953c646a50708dc5790d17fe297c053d968830e2b458a072add8f1e4e796b262a9256fcfefc59e4303bdb1b4c5967d14db15b5176d238f47f3a072add739285f1f7129824c5e189ef4c286b7a30f3ab9f1d3272565d2b412f5476b64a1f09f864d6320ef40828b9d5ed9c2bc6fe53b861b9ccfc762aeec54e436a0781f30f51c530325ce648b17bf3eca5e158eb9aaf19368944f7130ce3adbb90360b00fe8cf19158489cfbba7a1b04dfbca7fc6c3732a5bd0f2d59e555d5febbac2c2b3872fbd8727b204448ef1ce8ce679743f89bf8630cde3206971654a9424f4f8d5f1f788885effce756b29ca45b8ab66c2a34ee31bfa71cb0837f718324bc64a0049b9df92acb9f58b31d1555e4a957d85248e1b8d3770276ed61c8be56c7ce86b586ea8d7b8c3cd906e03767051ed3d7982304889129d6f57a582fc7049b082c12bf4701fe5d2164d2bb4f7f7a20b6dea15b92c87a7a149227cb6e848dd80ca25cef8ce467c5b5756ce0e3cdbcc71381d6c629c0d6d37584d33898644995bf3987d246642863b01738f1e845035be24d0317e10364dc4e8ac13ea610a768c87ec72e11f199497a91b9757878135aa090ad09d8c95cf39083aaa06bc3b47cca232ebae1f7de70635c17a0195c4e831d391471c703c6210a61e5c5e5eea7616896e80e03f5528be0f05e7cbfd734ba78c6d6a288a8b9f6b831697c0eb1a7d11110e8a96daf65bbb06a3fe50da66ae1ed7b6cbb2915e85cf67008ac812c5506c99fcb1c35de22603ba363d953cad95789a227b72645c7b692512e9d52237ee41cf12656c2c0195bb10f54aa05d4bab70a76dfdbb4bc0e2d9e57e1857cd4b702fb073ed9bd74c03a3e29e905664b5ab372a2b962941289a7c5d52ad07185d98b64a2d440dd13ea7c0291d74006dc4a6871a40a64c7fe175e545592d577df33d905a1b9c731acb4f9d16ca45c14708bb0f5797cf693256e0587f2657ca67189dc61d53b6d9b59a89e6630f3c457f9fcd1d6b073f1d0b115289afad20bbdf232b175c0c6eb573475d97c41c38ca2940297a8aae0f783c40b3cf10a1c1112d48ea9483a8f8f81b67edfe66b4ea44e6cf7bd3fe1487deab99d06e6a7141a80f6b7179ae64e53eb2a9af406dc4f754506754edf6c7ab74254ea067fca751b5f373728d259400540a8dcc8f4f36498b774fa39a0bfd832d586c363ab38c129c68f39d99dd924f05e834b670777ab2075952f54f4a64c4375125648e15e19307479877efc0d1da3547b41ae5d96e768a1620be7d0d796d48a6471ab871ea006bba762104cb7a1e11309d50a351e1e3faead7689eb9bca4b5e1ef8d58cfa286908913b41b3ff95d2e2ed3875e1d68f20147af1e92e5be8766a48c8436a064b4ef6165485e900a01acd90facf7cb23b52cc02ad028103860f44d6be3038ae517433f4a176ef30bf9d01a6a241c974620f0d6a9f7035896b17b8b78115667647f0fe24550cbff1de7f363ec65d7bc3cf09dace88e47389eba6796589b1113db657567ff8bf3d25cc2e0e2ed126762e270ee605c58e7b321f62bd2a16e2cf8a825db810af779ec7cf377180190348cbf91e0598e888c3087dc09c249a9b51a290d492d99519cf3482e80e45a876d0f24d3b2852ab44643e85442dd5d179492683ecbac4acd0c06002d1b84089a9ab7d0880871cddeea830967f87215a1ae4ce50b5cbb988d9a1f8b7c23bada9f99f56c9b2efda949427ceb2e86f67feae5ebf801fd184d3f17107f1d9e40c8919155c4543d8af711fee3763116ecf4401c5c92973fe1042bdc2265b9f688bc132a87c5c8955893f7d8032a3589cac5b12feeee03b7d591b4f3b0f9c47005996c3c670e466f0655ba878296aba21e968e293be7d9f29ab00cef8949bd90a00d36fed6255bd0aaeaeb88383f0e848bd708b44be3168022cb9ac434a56ed8d1d702dab41173d897f279abb3fa30f2d0e33c5995ed621503bf89268cc976efb41bafa2489ffd72fdf3e3241a045d87534b0a28e045bab0c5d3b7087fa55f2c0ebb46ccb7b5a2d8ec97b0288c73006f7f25fdb74cb5ac8c449a2543a23250352a4216b9e7886591dbda5cd6ea3112a2cfbdbd1286b6c7b72e73421feab5a93abbf2cae1e9169856ff2068f7aa570cf3be81e7653ea1423c4c0c8da619e827be906dc9d19825ee1e878b6492ea17e8cfbe2c59a93eaea40d41d38f6bcf9a25a00a27a5ff8be59107380521a6486b190797bdcc4d03fb86d991bf12f4dd5e3ab512c10dc9e2a0c4bfe6fe983cc2ff8b8316e8efa8dbc48696be7bf8ef0ba5d61c4cdf3e47d72976e1a68d408de0a07bbc19409d491c7763b2232f106c84993b4e4c9439498098955fb7619aa029e4ee2f7c413d3b7703f9c2a39049d2a6182d0dc2287e71c2fa1ad3ad1ca68ec73026c6618dcbc85a765dedbae8735a3e483bd56859781a315649cf0477e71cd62e86a758313c700b741a865c531e2d0c699bd436a21781ae309ea9ad5def989ac6ce23cae284c379a48efca7b054928c042f11784c60ebcff1a738983e76b7be816e5ad1575ac0b9f3dce575fb2b4d713384afcbcf563ea9ea9bababc86cd4eb67f57683ea190de2f3a80907a034c85fc799af45076fb172347a0a67600f12ad1c6ce54a8c8759046fc810b5a94ab5ba214dc4fef109c0b3e1621fc49672c790e01091a83f6efd3fc956e4fa50145e4a1b5ad1c0b9a274f87db4cb777c15554ab1132607cf75abde2fab0449be91dc7ee69e28192da868f271f0c314083bbf91b7b7f5ed032b1686f1bc0edb4c00bcf84dee479907e012ce422a32e76d69ee2396c88104aeff5513c6a6a2b0e1c356bcb3a6ff1ec4f2afa993918bc5b9970ae300c8a768f14bf856fc63c2fecc1b0e51981a50e654af3ca665a0ed2508dde3ad84ec5bd3b761e1bc80c23f15d013e290d79fcd46fafea199e132076c258c07d842dfc284cd2d864cd9066fcfdc334c14d47ea87f0a9165bebb73dfa1807701fdfd3424847797b415efc3d96e1eacc008959ef467fbc55c578f456e764c20fc7f8b251dfa07c715a3e2518eb32a67be0dc5ed3e34043c6f4d2fd7453ad28703c6dcd8fe35272994d5da1bb506554d5487e7972d10efa870627019cb91836d529839e3336c3a277fcf30109d25f3aa9fee3d75c8f8abfeea6a369ddc473ba6ae4c2d2fbcb6cbba4d7aa14fb4508121fe9998cc879a6bc5e6eb941de2a43bed57dda0790d8c01538430852abcf10ed376de5837321822054f3e584ac221216bc95f6638a9a523ec328a12d56e7d388cb4e187044353c24dc5f3d9f74af049a26f9817869e66a26cc74e7ca9653a4e4aec13728a12425b8616bc2b9060fab59ece3146ecf98f4ef54852fb3c76e56ac401dd141c371351cb70d68d8519e42f9912562ed2a07f81aa4eb879784afb24a47761b56a9761611be2cf11ef75c6b430a7aae846517fa83bf0b53c4e78d45bc508a85e5549bf4487ebe23a65e15b150513f221fdb063fbb0c12fb2c0738f2882ea31f548d8085d27809de9283ef13317ef0659d7acd7bd0f7ed4630cdbc421740120cce523ba72d60da0f7b93d7eb532860a7503effe60ed5ae085ab2e2a6d0538fd9712367948c614eedd2496c716a66294105796ca1c64905c8d55fdaaa8b9f91a79025998169e90c2ce98d5e324e9d35cfe4037111580709a4481a632d23f83669d8f04b3c8373ab424a5b7aa833b98c83f493a41025f29ece69ab5ac8e2637b329f1a573a63725b3da02acbaedcf24340b816b0608544ab9d9fb3d7965c998c44013cee0a6cb6243eb4bfeb2758360344eaab2f1180e9a8f27f625acd39743dfb4d8ae8007c2709a34523e61e0f4ac63f53fd202562ff9480dd98f6c7df37c0a48e4d37d582d4e3377a1c180b1f600648af7165b5b2360001328d3b5eb3a39516f63bbf7682f051ed9fb612b537e2291dac5452c9032d598ad1d8fb38f71c2dc674f1c187e0276c1a94d0bdd162f0a018c6076e7529ac073c45824a0ef76dd3a085b5eaae9f2daef1fc5bf96f6dd0c33a31f4351603429e3dd5f0a8ef47c156a0588e9c2e53b57c181afb5f619ea22af64be6ad85b566da0125b6f5b021ba2d0dfa73053f623ac3a576b29c15e6f226495bda95ac2789fdadcf2e817972c1a1871477933a489514419abbd5574a4f79153c0e7033da9ec82ec83bf6a992daaec730d364046b4a2f87f90b4a38eb50a059acf487d98443348761b7c397a0a4068a8d555e9c312bad3ee0776fd2d354d2a39c042d3b2278fc6d58f3ad1b65adc99a6c32c720f8d675c7412fcb49b742f97b439690a5245dacf61001f8b77d5a799c9d371014418b079c3d9047bf2af61a802b61673b7bb4b7497b8c7aff42cfa7b79aae9475b711670aeb2939d5aeb2411588e64b86680cc78566bb1857cf10ebec8b49860e24a40adf3c01d1b5638c59f2248eaecf03cd7bf9ecad36f507944552e0c040475dfb79987692c16110a7d771fdea7e51d56e85ae1b3e291883d74fe14a54ca1bf4623754dcd280984137927ffd14f04755a6bd370e166c96201336145cb25cd4f96ff1c692fe0f087e44dfda17e8241c9dfb6050f010b6432deaeb8f0d4e34632620ee054f597e0855f386f60c77f65cc661d476f430188b8b1e6d5867edb7ebc30ba67ba65f0da5ded9fd9c31e701ea0af1b0716aeaac839ed7df01c8f08e9beaeadd905eb15df9d5f7d3e14a192b85210798a45b260969bb9c5cdc83937684f86f708c2398bc00f297fdc1464495413c00a9c2275094c78c250ac71657816e34c6a090bf1d7d90759408711d8103be29073c0a7bd7e67b00c10ad30afc06805d5306c4bafc8db9dc500f34ccc7632d6118befc1fa63ebed10c15df544bc5222ca147a93c5ed3f0fa3c705eed15c4e8ec81dcef2c35a3162a1a5c31ad9b111e7a3912f97b1573e57bf72b7dcb5312c5643bb96ad14d523f3710c57b7c1006e3baa40de34e20d9390fe8b70c7391719e5831d8746142c252f59f44029e641d7930168d55d2af71fb407a65bff73f4524d3418c2c7e74cf0c793c160d86c1bbe50a5cc313a2915d2243252172a23f1eb0e1c7277d74fb34ca48b42da688d070af6cdc8ecec398365df891d332ddecc9dcd1fd1ede516e24931a8f15af3de2ee2779ba215d63591d3d6104c465efeb80643c9c0362bf6faa753359af16d3d31aeb98d06dcb982aa4edf6224b0d403ac3755f2fed767d52ff2d6e65a1dc15ee767d4b49a0fb88c9373037f4eea9209bdf3bf18300fb5a350dace4a14cb4e577ff7b1fb8c6964459739af36f060690091621b343ad8eceda8365ef40f76ca01774be79f07102b3bbb21e30dc2cc2a7f5b5b17da4519842c55b66380e075e895f1a1cdaa4624b8af9ec566ab514dc5aac6ae70d055294060bb697922f71136d307972c612c3e2265561512f1e112bdd89965798b5e093bcbe454320e274ff95a2f3dedc92c4884c052ff8104927a9ad762dc047546ace63d67f51fa61a8830843aef5e68f8f682c666ee7d9abcdd66e4ae18bc9c0ad56d2185d93eb258c6ec025ebd681157b228cb9e7afebcdde82c7045f5490c1f78f003becf2beb920696c8758042d0535b24929a6a4695f4af12a8b8dbe1447f8519e0aecf12ebf0ea083dff4a393e0e980ee0481049a73fef694c8a8392af86756bfb529f666d9ba3ddc931607a9d98b85372c686708c148cb308ca1fd0bf7d4aa130ca72401d81ba0bd495fc72c2f55825c96a81a9a56ac28f1f5174144f785456098107716e62990985a0c125d9c925f1396f9705578eec85af157afae3aaafd263e43c4febca9d54ef38f613f9536f39d01e67812db90af62fe2d038c53afc412ff8a8847f498ca1ed55ae6aa0c51187e41ac40d78a6c387a0746beca7c8322492890cc9b5b733dce7ea377993c47d548c2ced4aee6b143e38e576ef26588623cea78f84f71680a9585a9c72a2be29458e05a15890713cecb668c5f7834d5619ad7e34cee85473edfe5061f732f7d655925efa163cc8e8e215cdeddebf63a717f46c0f2725ccc5b2822209a867fbe83938a53606a7acb4deaa4aff592290c7ba1cf0846065cae9f75376f14ed71426fb0dd36dbec6cbbb75091f1f3101c92f57903b4075ea79a24ab97f7a53fd54ca05780273b4dc65326b2086964ddb3b1a757f44a059bc10d56b1acbea6f9a63f4c1cff551fb768b7532f76e934e4f1dddc5b04dc13d0e64a34fb4252b2ae953e8de08ffe0c3036ba5e525dae2da8ce2069cd7a4e6b35e6e5923079c369f4a7e1f5b6bef3e5b1422ff1bf11466a972390783bab490bf51ebac5cd09c7d314db3e60f051824ff8c25d6b33d23bb0591875c4b4a90c958a889a04b6884c53592ddef44af65c995360bd00ba6e06205f7bcb529a4550675b57f209c1a88d9a2014bb5719950841d93353e6a083a0b67118b6acf61d5d628bdeb5d69992c4590a8623a77c09618ac5d501050f51315aa36a2975911c45320d2af54ad1dfb9fc7d216d8a93eff91a6ac8e16b7eac3616c6e2c08dcf61a3e28748971d418593e96866f0cab441517d294d8137d866d5356f25bdfc4705f0c76a91995f246000a650035f202c3f71eb5c233dff0d805581dffe5ae52bf41add67c0044e282d94e9178559fc80fda335d1c8acf63bfb1768336963ad6272b9b84b4a567232b94264c6f89003f54065dc7166c209144ef3685d1f5d67f312cc9a882894f7cf972b1f52839f434c08626509bdfef3c40e3696bf214bddb7d18a3ee088f67cec6022f1d117d87092c1b1d75fddd24c801459b0393d08f2ea71e2b921315104fd7162093ff2f03b6bbc977088191b7c98cbeb8c35c2744ea2a6630245155fd71ef8cb032734547a3a12cb492fb9d78f1f89d261cb658ffa0ac54653f19c10fa08be14ec547fbfe8acc04ddd406cad371bcd9e8c13d9c11b1b3e1db9c5847827840e86da95211955705b270c36e7f77f9eebcd700a3e21ed2861aa0466e32d4c6b8a0e399f48a1816a88035237f25ecb2e5a69b920a308eec1a595a58a4638a70358305bc769c864551a082d8da7974b695a79fe9b079fdc927571c0fa22dac5d1675be42993df8a38417a87949dc6a7e08693c8dd271de80f9cb9e528f3a4714adeb1add094814d462df7856f6dd25c8c2d034ab02592ee93816af83402e692c8cc675378fb60989e204819d21380347cef5d1b589a9486830694b656a233bff51904c23bade9bd1ad53dfd208b53bb4875ccd6a09fc80bf8f017f300c362672291922e0e12459ea059a27a780cfada01b2c87bfd8544641674c88693fc7d146af55c511d5539bd87e677849ba0138183e29488130a7eccdb9e46ada71ad026be4a8ba5cb1861fd770f9e88181856887c3411f61fe8033c0c702fb613cd6326d4f61f92d751c7738eb2ef5bb5f9cc087162cc9133a09c8817de5180ede85e2bf20fa1d496b7f9be6f9eb9fb911834e31da409304fa25445ba7e61348f38a712345c9847bb8f13ecfeac83396dbc6e3d7226bd66158d62734d67acbaabd3d7019aff82dc3ebbe92</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP</title>
    <link href="/2022/10/30/Java/framework/AOP/"/>
    <url>/2022/10/30/Java/framework/AOP/</url>
    
    <content type="html"><![CDATA[<p>AOP：Aspect Oriented Programming，面向切面编程。</p><p>OOP：Object Oriented Programming，面向对象编程。</p><p>面向切面编程：基于OOP基础之上的新的编程思想，指在程序运行期间，将<strong>某段代码</strong>（日志）<strong>动态的切入</strong>（不把日志代码写死在业务逻辑方法中）到<strong>指定方法</strong>的<strong>指定位置</strong>（方法的开始、结束、异常位置）进行运行的这种编程方式。</p><hr><p>可以用动态代理来实现面向切面编程，但是有缺点：</p><p>写起来比较麻烦，每次都要通过反射来创建代理对象；jdk默认的动态代理如果目标对象没有实现任何接口，是无法为他创建代理对象的。因为代理对象和被代理对象的纽带就是接口类型。</p><hr><p><strong>AOP专业术语：</strong></p><p><img src="/../../../image/AOP/1.png"></p><hr><p><strong>抽取可重用的切入点表达式：</strong></p><ol><li><p>随便声明一个没有实现的返回<code>void</code>的空方法</p></li><li><p>给方法上标注<code>@Pointcut</code>注解</p></li><li><p>括号内写上切入点表达式</p><p><strong>切入点表达式结构</strong>：<code>execution(访问权限符 返回值类型 方法全类名(参数列表))</code></p></li></ol><p><code>*</code> ：只能匹配一层路径&#x2F;一个参数</p><p><code>execution(public int com.vickkkyz.aoppractice.math.MyMathCalculator.*(*,*))</code></p><p><code>..</code> ：用在参数表，表示匹配任意多个参数，任意参数类型</p><p>用在路径上，表示多层路径，下面的表示aoppractice包下的多层路径下名字叫MyMathCalculator的类</p><p><code>execution(public int com.vickkkyz.aoppractice..MyMathCalculator.*(*,*))</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 下列切入点表达式的意思是切 MyMathCalculator类下的任意名字的方法，两个任意类型的参数</span><br><span class="hljs-meta">@Pointcut(&quot;execution(public int com.vickkkyz.aoppractice.math.MyMathCalculator.*(*,*))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myPoint</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>写一次，之后全引用即可。</p><hr><p><strong>通知方法的执行顺序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-meta">@Before</span>  <span class="hljs-comment">// 前置通知</span><br>method.invoke(obj,args);<br><span class="hljs-meta">@AfterReturning</span>   <span class="hljs-comment">// 返回通知。正常返回</span><br>&#125;<span class="hljs-keyword">catch</span>()&#123;<br><span class="hljs-meta">@AfterThrowing</span>   <span class="hljs-comment">// 异常通知。方法异常</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-meta">@After</span>  <span class="hljs-comment">// 后置通知</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法正常执行：@Beofre -&gt; @After -&gt; @AfterReturning</p><p>方法异常执行：@Before -&gt; @After -&gt; @AfterThrowing</p><hr><p>使用参数<code>JoinPoint</code>可以拿到运行的方法的相信信息。需要在通知方法的参数列表上写上</p><p><code>JoinPoint joinPoint</code></p><p>在通知方法注解上写上<code>throwing = &quot;exception&quot;</code>，参数列表上加上这个参数<code>Exception exception</code>，通知方法就可以接收到方法出现的异常信息，注解上加上<code>returning = &quot;result&quot;</code> ，参数上写上<code>Object result</code>，就可以获得方法的返回值。</p><hr><p>Spring对增强方法要求不严格，因为通过注解标记了方法，只要能正常调用就完成了增强的目的；所以唯一要求严格的就是参数表，反射调用的时候得给参数赋值；JoinPoint是预定义的；如果有其他参数（接返回值的，接异常的），得声明出来哪个参数接什么；</p><hr><p><code>@Around</code></p><p>环绕通知，是Spring中最强大的通知，环绕通知是上面四个通知的整合，四合一。</p><p>有一个强大的回调参数，可以拿到底层动态代理的invoke权，</p><p>如果使用环绕通知注解，那么目标方法的调用就是在<code>@Around</code>注解修饰的方法中，需要我们显示去利用动态代理调用目标方法，其实就相当于之前的Spring帮我们调用的<code>method.invoke(obj,args)</code> ，变为我们自己调用<code>point.proceed(args);</code> 最后将方法的返回值，即proceed返回出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogUtils</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(public int com.vickkkyz.aoppractice.math.MyMathCalculator.*(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myPoint</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;myPoint()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        <span class="hljs-comment">// 获取到方法运行的参数列表</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-comment">// 方法签名</span><br>        <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> joinPoint.getSignature();<br>        <span class="hljs-comment">// 方法名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> signature.getName();<br>        System.out.println(<span class="hljs-string">&quot;[前置通知]方法执行前,参数为&quot;</span>+ Arrays.asList(args)+<span class="hljs-string">&quot;方法名为：&quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;myPoint()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfter</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[后置通知]finally&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(value = &quot;myPoint()&quot;,returning = &quot;result&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterReturning</span><span class="hljs-params">(Object result)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[正常返回]try语句块结束,结果为&quot;</span> + result);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterThrowing(value = &quot;myPoint()&quot;, throwing = &quot;exception&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterThrowing</span><span class="hljs-params">(Exception exception)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[方法异常]throwing,异常信息是&quot;</span>);<br>        exception.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;myPoint()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">logAround</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        Object[] args = point.getArgs();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;环绕前置&quot;</span>);<br>            <span class="hljs-comment">// 就是反射调用方法</span><br>            proceed = point.proceed(args);<br>            System.out.println(<span class="hljs-string">&quot;环绕正常返回&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;环绕异常&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;环绕后置&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将方法的结果返回，最终程序获取的该方法的结果就是这个</span><br>        <span class="hljs-comment">// 如果在这里篡改了结果，那么方法的返回结果就一直是这个</span><br>        <span class="hljs-keyword">return</span> proceed;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMathCalculator</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dev</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>AOP使用场景：</strong></p><p>1）、AOP加日志保存到数据库；</p><p>2）、AOP做权限验证； </p><p>3）、AOP做安全检查； </p><p>4）、AOP做事务控制；</p><p><a href="https://www.jianshu.com/p/9093e6ca3378">https://www.jianshu.com/p/9093e6ca3378</a></p><hr><p>对切入点表达式格式的说明：（即@Point注解内的表达式）</p><p><strong>within：匹配包&#x2F;类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配ProductService类种的所有方法</span><br><span class="hljs-meta">@Poincut(&quot;within(com.hhu.service.ProductService)&quot;)</span><br><br><span class="hljs-comment">//匹配com.hhu包及其子包下所有类的方法</span><br><span class="hljs-meta">@Pointcut(&quot;within(com.hhu..*)&quot;)</span><br></code></pre></td></tr></table></figure><p><strong>this、target、bean</strong>：<strong>匹配对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匹配AOP对象的目标对象为指定类型的方法，即DemoDao的aop的代理对象</span><br><span class="hljs-meta">@Pointcut(&quot;this(com.hhu.DemaoDao)&quot;)</span><br> <br><span class="hljs-comment">//匹配实现IDao接口的目标对象(而不是aop代理后的对象，这里即DemoDao的方法)</span><br><span class="hljs-meta">@Pointcut(&quot;target(com.hhu.Idao)&quot;)</span><br> <br><span class="hljs-comment">//匹配所有以Service结尾的bean中的方法</span><br><span class="hljs-meta">@Pointcut(&quot;bean(*Service)&quot;)</span><br></code></pre></td></tr></table></figure><p><strong>@annotation：匹配注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匹配方法标注有AdminOnly注解的方法</span><br><span class="hljs-meta">@Pointcut(&quot;annotation(com.hhu.demo.security.AdminOnly)&quot;)</span><br> <br><span class="hljs-comment">//匹配标注有Beta的类下的方法，要求annotation的RetentionPplicy级别为CLASS</span><br><span class="hljs-meta">@Pointcut(&quot;@within(com.google.common.annotations.Beta)&quot;)</span><br> <br><span class="hljs-comment">//匹配标注有Repository类下的方法，要求的annotation的RetentionPolicy级别为RUNTIME</span><br><span class="hljs-meta">@Pointcut(&quot;@target(org.springframework.stereotype.Repository)&quot;)</span><br> <br><span class="hljs-comment">//匹配传入的参数类型标注有Repository注解的方法</span><br><span class="hljs-meta">@Pointcut(&quot;@args(org.springframework.stereotype.Repository)&quot;)</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jaryle/article/details/88764751">https://blog.csdn.net/jaryle/article/details/88764751</a></p>]]></content>
    
    
    <categories>
      
      <category>FrameWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="/2022/10/22/Java/framework/MyBatis-Plus/"/>
    <url>/2022/10/22/Java/framework/MyBatis-Plus/</url>
    
    <content type="html"><![CDATA[<p><strong>本文是尚硅谷mybatis-plus教程，直接用了老师的文档。</strong></p><h1 id="一、MyBatis-Plus"><a href="#一、MyBatis-Plus" class="headerlink" title="一、MyBatis-Plus"></a>一、MyBatis-Plus</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><blockquote><p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/relationship-with-mybatis.png" alt="img"></p><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="3-支持数据库"><a href="#3-支持数据库" class="headerlink" title="3.支持数据库"></a>3.支持数据库</h2><blockquote><p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></blockquote><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li></ul><h2 id="4-框架结构"><a href="#4-框架结构" class="headerlink" title="4.框架结构"></a>4.框架结构</h2><img src="https://baomidou.com/img/mybatis-plus-framework.jpg" alt="framework" style="zoom:50%;" /><h2 id="5-官方地址"><a href="#5-官方地址" class="headerlink" title="5.官方地址"></a>5.官方地址</h2><blockquote><p><strong>官方网站：</strong><a href="https://baomidou.com/">https://baomidou.com/</a></p><p><strong>官方文档：</strong><a href="https://baomidou.com/pages/24112f/">https://baomidou.com/pages/24112f/</a></p></blockquote><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><ul><li><strong>IDE：IDEA 2019.3.5</strong></li><li><strong>JDK：JDK8+</strong></li><li><strong>构建工具：Maven 3.5.4</strong></li><li><strong>MySQL：MySQL 8.0.24</strong></li><li><strong>Navicat：Navicat Premium 15</strong></li><li><strong>Spring Boot：2.6.7</strong></li><li><strong>MyBatis-Plus：3.5.1</strong></li></ul><h2 id="2-建库建表"><a href="#2-建库建表" class="headerlink" title="2.建库建表"></a>2.建库建表</h2><ul><li><p><strong>打开Navicat运行以下SQL脚本进行建库建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE `mybatis_plus` <span class="hljs-comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>; <br>use `mybatis_plus`; <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>` ( <br>    `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>, <br>    `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>, <br>    `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>, <br>    `email` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span>, <br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure></li><li><p><strong>插入几条测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (id, name, age, email) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Jone&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;test1@baomidou.com&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;test2@baomidou.com&#x27;</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;test3@baomidou.com&#x27;</span>), <br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Sandy&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;test4@baomidou.com&#x27;</span>), <br>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Billie&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;test5@baomidou.com&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-创建工程"><a href="#3-创建工程" class="headerlink" title="3.创建工程"></a>3.创建工程</h2><ul><li><p><strong>使用<code>Spring Initializer</code>快速初始化一个 Spring Boot 工程</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519140839640.png" alt="image-20220519140839640" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141335981.png" alt="image-20220519141335981" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141737405.png" alt="image-20220519141737405" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141849937.png" alt="image-20220519141849937" style="zoom:80%;" /></li><li><p><strong>引入<code>MyBatis-Plus</code>的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>安装<code>Lombok</code>插件</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519143257305.png" alt="image-20220519143257305" style="zoom:80%;" /></li></ul><h2 id="4-配置编码"><a href="#4-配置编码" class="headerlink" title="4.配置编码"></a>4.配置编码</h2><ul><li><p><strong>配置<code>application.yml</code>文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#配置端口</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment">#配置数据源</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-comment">#配置数据源类型</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-comment">#配置连接数据库的信息</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span><br>    <span class="hljs-attr">username:</span> &#123;<span class="hljs-string">username</span>&#125;<br>    <span class="hljs-attr">password:</span> &#123;<span class="hljs-string">password</span>&#125;<br><br><span class="hljs-comment">#MyBatis-Plus相关配置</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment">#配置日志</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure></li><li><p><strong>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;指定Mapper接口所在的包&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusDemoApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MybatisPlusDemoApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编写实体类 <code>User.java</code>（此处使用了 Lombok 简化代码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编写 Mapper 包下的 <code>UserMapper</code>接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-测试查询"><a href="#5-测试查询" class="headerlink" title="5.测试查询"></a>5.测试查询</h2><ul><li><p><strong>编写一个测试类<code>MyBatisPlusTest.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisPlusTest</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试查询所有数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span><br>        List&lt;User&gt; users = userMapper.selectList(<span class="hljs-literal">null</span>);<br>        users.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>控制台打印查询结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519150454211.png" alt="image-20220519150454211"></p></li></ul><h1 id="三、增删改查"><a href="#三、增删改查" class="headerlink" title="三、增删改查"></a>三、增删改查</h1><h2 id="1-BaseMapper"><a href="#1-BaseMapper" class="headerlink" title="1.BaseMapper&lt;T&gt;"></a>1.BaseMapper&lt;T&gt;</h2><blockquote><p>说明:</p><ul><li>通用 CRUD 封装BaseMapper 接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li><li>泛型 <code>T</code> 为任意实体对象</li><li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li><li>对象 <code>Wrapper</code> 为条件构造器</li></ul></blockquote><p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，因此我们继承该接口以后可以直接使用。</p><p>本次演示的CRUD操作不包含参数带有条件构造器的方法，关于条件构造器将单独在一个章节进行演示。</p><hr><blockquote><p><strong>BaseMapper中提供的CRUD方法：</strong></p></blockquote><ul><li><p><strong>增加：Insert</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入一条记录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T entity)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>删除：Delete</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 entity 条件，删除记录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;<br><span class="hljs-comment">// 删除（根据ID 批量删除）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteBatchIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;<br><span class="hljs-comment">// 根据 ID 删除</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Serializable id)</span>;<br><span class="hljs-comment">// 根据 columnMap 条件，删除记录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteByMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>修改：Update</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 whereWrapper 条件，更新记录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;<br><span class="hljs-comment">// 根据 ID 修改</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updateById</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.ENTITY)</span> T entity)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>查询：Selete</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 ID 查询</span><br>T <span class="hljs-title function_">selectById</span><span class="hljs-params">(Serializable id)</span>;<br><span class="hljs-comment">// 根据 entity 条件，查询一条记录</span><br>T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br><br><span class="hljs-comment">// 查询（根据ID 批量查询）</span><br>List&lt;T&gt; <span class="hljs-title function_">selectBatchIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;<br><span class="hljs-comment">// 根据 entity 条件，查询全部记录</span><br>List&lt;T&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 查询（根据 columnMap 条件）</span><br>List&lt;T&gt; <span class="hljs-title function_">selectByMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录</span><br>List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">selectMaps</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span><br>List&lt;Object&gt; <span class="hljs-title function_">selectObjs</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br><br><span class="hljs-comment">// 根据 entity 条件，查询全部记录（并翻页）</span><br>IPage&lt;T&gt; <span class="hljs-title function_">selectPage</span><span class="hljs-params">(IPage&lt;T&gt; page, <span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span><br>IPage&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">selectMapsPage</span><span class="hljs-params">(IPage&lt;T&gt; page, <span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询总记录数</span><br>Integer <span class="hljs-title function_">selectCount</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-调用Mapper层实现CRUD"><a href="#2-调用Mapper层实现CRUD" class="headerlink" title="2.调用Mapper层实现CRUD"></a>2.调用Mapper层实现CRUD</h2><h3 id="2-1插入"><a href="#2-1插入" class="headerlink" title="2.1插入"></a>2.1插入</h3><hr><blockquote><p><strong>最终执行的结果，所获取的id为1527206783590903810</strong></p><p><strong>这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 测试插入一条数据</span><br><span class="hljs-comment">  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;Vz&quot;</span>);<br>    user.setAge(<span class="hljs-number">21</span>);<br>    user.setEmail(<span class="hljs-string">&quot;vz@oz6.cn&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insert(user);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;添加成功！&quot;</span> : <span class="hljs-string">&quot;添加失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>    <span class="hljs-comment">//1527206783590903810（当前 id 为雪花算法自动生成的id）</span><br>    System.out.println(<span class="hljs-string">&quot;id自动获取&quot;</span> + user.getId());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2删除"><a href="#2-2删除" class="headerlink" title="2.2删除"></a>2.2删除</h3><hr><h4 id="a、根据ID删除数据"><a href="#a、根据ID删除数据" class="headerlink" title="a、根据ID删除数据"></a>a、根据ID删除数据</h4><blockquote><p><strong>调用方法：int deleteById(Serializable id);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 测试根据id删除一条数据</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteById</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.deleteById(<span class="hljs-number">1527206783590903810L</span>);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;删除成功！&quot;</span> : <span class="hljs-string">&quot;删除失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b、根据ID批量删除数据"><a href="#b、根据ID批量删除数据" class="headerlink" title="b、根据ID批量删除数据"></a>b、根据ID批量删除数据</h4><blockquote><p><strong>调用方法：int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 测试通过id批量删除数据</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteBatchIds</span><span class="hljs-params">()</span>&#123;<br>    List&lt;Long&gt; ids = Arrays.asList(<span class="hljs-number">6L</span>,<span class="hljs-number">7L</span>,<span class="hljs-number">8L</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.deleteBatchIds(ids);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;删除成功！&quot;</span> : <span class="hljs-string">&quot;删除失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c、根据Map条件删除数据"><a href="#c、根据Map条件删除数据" class="headerlink" title="c、根据Map条件删除数据"></a>c、根据Map条件删除数据</h4><blockquote><p><strong>调用方法：int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 测试根据Map集合中所设置的条件删除数据</span><br><span class="hljs-comment">   */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteByMap</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//当前演示为根据name和age删除数据</span><br>    <span class="hljs-comment">//执行SQL为：DELETE FROM user WHERE name = ? AND age = ?</span><br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Vz&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">21</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.deleteByMap(map);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;删除成功！&quot;</span> : <span class="hljs-string">&quot;删除失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3修改"><a href="#2-3修改" class="headerlink" title="2.3修改"></a>2.3修改</h3><blockquote><p><strong>调用方法：int updateById(@Param(Constants.ENTITY) T entity);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 测试根据id修改用户信息</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateById</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setId(<span class="hljs-number">6L</span>);<br>    user.setName(<span class="hljs-string">&quot;VzUpdate&quot;</span>);<br>    user.setAge(<span class="hljs-number">18</span>);<br>    user.setEmail(<span class="hljs-string">&quot;Vz@sina.com&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.updateById(user);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;修改成功！&quot;</span> : <span class="hljs-string">&quot;修改失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4查询"><a href="#2-4查询" class="headerlink" title="2.4查询"></a>2.4查询</h3><hr><h4 id="a、根据ID查询用户信息"><a href="#a、根据ID查询用户信息" class="headerlink" title="a、根据ID查询用户信息"></a>a、根据ID查询用户信息</h4><blockquote><p><strong>调用方法：T selectById(Serializable id);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 测试根据id查询用户数据</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectById</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">1L</span>);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b、根据多个ID查询多个用户信息"><a href="#b、根据多个ID查询多个用户信息" class="headerlink" title="b、根据多个ID查询多个用户信息"></a>b、根据多个ID查询多个用户信息</h4><blockquote><p><strong>调用方法：List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 根据多个id查询用户数据</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectBatchIds</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span><br>    List&lt;Long&gt; ids = Arrays.asList(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">3L</span>);<br>    List&lt;User&gt; users = userMapper.selectBatchIds(ids);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c、根据Map条件查询用户信息"><a href="#c、根据Map条件查询用户信息" class="headerlink" title="c、根据Map条件查询用户信息"></a>c、根据Map条件查询用户信息</h4><blockquote><p><strong>调用方法：List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 根据Map所设置的条件查询用户</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectByMap</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?</span><br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>);<br>    List&lt;User&gt; users = userMapper.selectByMap(map);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d、查询所有用户信息"><a href="#d、查询所有用户信息" class="headerlink" title="d、查询所有用户信息"></a>d、查询所有用户信息</h4><blockquote><p><strong>调用方法：List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 测试查询所有数据</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectList</span><span class="hljs-params">()</span>&#123;<br>    List&lt;User&gt; users = userMapper.selectList(<span class="hljs-literal">null</span>);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-通用Service"><a href="#3-通用Service" class="headerlink" title="3.通用Service"></a>3.通用Service</h2><blockquote><p>说明:</p><ul><li>通用 Service CRUD 封装<code>IService</code>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</li><li>泛型 <code>T</code> 为任意实体对象</li><li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</li><li>对象 <code>Wrapper</code> 为 条件构造器</li></ul></blockquote><p>MyBatis-Plus中有一个接口 **<code>IService</code>**和其实现类 **<code>ServiceImpl</code>**，封装了常见的业务层逻辑，详情查看源码IService和ServiceImpl</p><p>因此我们在使用的时候仅需在自己定义的**<code>Service</code><strong>接口中继承</strong><code>IService</code><strong>接口，在自己的实现类中实现自己的Service并继承</strong><code>ServiceImpl</code>**即可</p><hr><blockquote><p><strong>IService中的CRUD方法</strong></p></blockquote><ul><li><p><strong>增加：Save、SaveOrUpdate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入一条记录（选择字段，策略插入）</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">save</span><span class="hljs-params">(T entity)</span>;<br><span class="hljs-comment">// 插入（批量）</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">saveBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList)</span>;<br><span class="hljs-comment">// 插入（批量）</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">saveBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList, <span class="hljs-type">int</span> batchSize)</span>;<br><br><span class="hljs-comment">// TableId 注解存在更新记录，否插入一条记录</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">saveOrUpdate</span><span class="hljs-params">(T entity)</span>;<br><span class="hljs-comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">saveOrUpdate</span><span class="hljs-params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;<br><span class="hljs-comment">// 批量修改插入</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">saveOrUpdateBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList)</span>;<br><span class="hljs-comment">// 批量修改插入</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">saveOrUpdateBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList, <span class="hljs-type">int</span> batchSize)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>删除：Remove</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 entity 条件，删除记录</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 ID 删除</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">removeById</span><span class="hljs-params">(Serializable id)</span>;<br><span class="hljs-comment">// 根据 columnMap 条件，删除记录</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">removeByMap</span><span class="hljs-params">(Map&lt;String, Object&gt; columnMap)</span>;<br><span class="hljs-comment">// 删除（根据ID 批量删除）</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">removeByIds</span><span class="hljs-params">(Collection&lt;? extends Serializable&gt; idList)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>修改：Update</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Wrapper&lt;T&gt; updateWrapper)</span>;<br><span class="hljs-comment">// 根据 whereWrapper 条件，更新记录</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;<br><span class="hljs-comment">// 根据 ID 选择修改</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">updateById</span><span class="hljs-params">(T entity)</span>;<br><span class="hljs-comment">// 根据ID 批量更新</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">updateBatchById</span><span class="hljs-params">(Collection&lt;T&gt; entityList)</span>;<br><span class="hljs-comment">// 根据ID 批量更新</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">updateBatchById</span><span class="hljs-params">(Collection&lt;T&gt; entityList, <span class="hljs-type">int</span> batchSize)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>查询：Get、List、Count</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 ID 查询</span><br>T <span class="hljs-title function_">getById</span><span class="hljs-params">(Serializable id)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span><br>T <span class="hljs-title function_">getOne</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录</span><br>T <span class="hljs-title function_">getOne</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper, <span class="hljs-type">boolean</span> throwEx)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录</span><br>Map&lt;String, Object&gt; <span class="hljs-title function_">getMap</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录</span><br>&lt;V&gt; V <span class="hljs-title function_">getObj</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="hljs-built_in">super</span> Object, V&gt; mapper)</span>;<br><br><br><span class="hljs-comment">// 查询所有</span><br>List&lt;T&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 查询列表</span><br>List&lt;T&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 查询（根据ID 批量查询）</span><br>Collection&lt;T&gt; <span class="hljs-title function_">listByIds</span><span class="hljs-params">(Collection&lt;? extends Serializable&gt; idList)</span>;<br><span class="hljs-comment">// 查询（根据 columnMap 条件）</span><br>Collection&lt;T&gt; <span class="hljs-title function_">listByMap</span><span class="hljs-params">(Map&lt;String, Object&gt; columnMap)</span>;<br><span class="hljs-comment">// 查询所有列表</span><br>List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">listMaps</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 查询列表</span><br>List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">listMaps</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 查询全部记录</span><br>List&lt;Object&gt; <span class="hljs-title function_">listObjs</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 查询全部记录</span><br>&lt;V&gt; List&lt;V&gt; <span class="hljs-title function_">listObjs</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> Object, V&gt; mapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录</span><br>List&lt;Object&gt; <span class="hljs-title function_">listObjs</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录</span><br>&lt;V&gt; List&lt;V&gt; <span class="hljs-title function_">listObjs</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="hljs-built_in">super</span> Object, V&gt; mapper)</span>;<br><br><span class="hljs-comment">// 查询总记录数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询总记录数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>分页：Page</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 ID 查询</span><br>T <span class="hljs-title function_">getById</span><span class="hljs-params">(Serializable id)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span><br>T <span class="hljs-title function_">getOne</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录</span><br>T <span class="hljs-title function_">getOne</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper, <span class="hljs-type">boolean</span> throwEx)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录</span><br>Map&lt;String, Object&gt; <span class="hljs-title function_">getMap</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper)</span>;<br><span class="hljs-comment">// 根据 Wrapper，查询一条记录</span><br>&lt;V&gt; V <span class="hljs-title function_">getObj</span><span class="hljs-params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="hljs-built_in">super</span> Object, V&gt; mapper)</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-调用Service层操作数据"><a href="#4-调用Service层操作数据" class="headerlink" title="4.调用Service层操作数据"></a>4.调用Service层操作数据</h2><blockquote><p>我们在自己的Service接口中通过继承MyBatis-Plus提供的IService接口，不仅可以获得其提供的CRUD方法，而且还可以使用自身定义的方法。</p></blockquote><ul><li><p><strong>创建<code>UserService</code>并继承<code>IService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * UserService继承IService模板提供的基础功能 </span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>创建<code>UserService</code>的实现类并继承<code>ServiceImpl</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * ServiceImpl实现了IService，提供了IService中基础功能的实现 </span><br><span class="hljs-comment">  * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>测试查询记录数</strong></p><blockquote><p><strong>调用方法：int count();</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetCount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//查询总记录数</span><br>    <span class="hljs-comment">//执行的SQL为：SELECT COUNT( * ) FROM user</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> userService.count();<br>    System.out.println(<span class="hljs-string">&quot;总记录数：&quot;</span> + count);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>测试批量插入数据</strong></p><blockquote><p><strong>调用方法：boolean saveBatch(Collection<T> entityList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    List&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;Vz&quot;</span>+i);<br>        user.setAge(<span class="hljs-number">20</span>+i);<br>        list.add(user);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> userService.saveBatch(list);<br>    System.out.println(b ? <span class="hljs-string">&quot;添加成功！&quot;</span> : <span class="hljs-string">&quot;添加失败！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="四、常用注解"><a href="#四、常用注解" class="headerlink" title="四、常用注解"></a>四、常用注解</h1><blockquote><p>MyBatis-Plus提供的注解可以帮我们解决一些数据库与实体之间相互映射的问题。</p></blockquote><h2 id="1-TableName"><a href="#1-TableName" class="headerlink" title="1.@TableName"></a>1.@TableName</h2><blockquote><p>经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表，由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致。</p></blockquote><h3 id="1-1引出问题"><a href="#1-1引出问题" class="headerlink" title="1.1引出问题"></a>1.1引出问题</h3><hr><blockquote><p><strong>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</strong></p></blockquote><ul><li><p>我们将表<code>user</code>更名为<code>t_user</code>，测试查询功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520093844842.png" alt="image-20220520093844842"></p></li><li><p>程序抛出异常，<strong>Table ‘mybatis_plus.user’ doesn’t exist</strong>，因为现在的表名为<code>t_user</code>，而默认操作的表名和实体类型的类名一致，即<code>user</code>表</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520094126411.png" alt="image-20220520094126411"></p></li></ul><h3 id="1-2解决问题"><a href="#1-2解决问题" class="headerlink" title="1.2解决问题"></a>1.2解决问题</h3><hr><h4 id="a、使用注解解决问题"><a href="#a、使用注解解决问题" class="headerlink" title="a、使用注解解决问题"></a>a、使用注解解决问题</h4><blockquote><p><strong>在实体类类型上添加<code>@TableName(&quot;t_user&quot;)</code>，标识实体类对应的表，即可成功执行SQL语句</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;t_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b、使用全局配置解决问题"><a href="#b、使用全局配置解决问题" class="headerlink" title="b、使用全局配置解决问题"></a>b、使用全局配置解决问题</h4><blockquote><p><strong>在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如 <code>t_</code> 或 <code>tbl_</code> 此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表</strong></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-comment"># 设置实体类所对应的表的统一前缀</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">t_</span><br></code></pre></td></tr></table></figure><h2 id="2-TableId"><a href="#2-TableId" class="headerlink" title="2.@TableId"></a>2.@TableId</h2><blockquote><p><strong>经过以上的测试，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id</strong></p></blockquote><h3 id="2-1引出问题"><a href="#2-1引出问题" class="headerlink" title="2.1引出问题"></a>2.1引出问题</h3><hr><blockquote><p><strong>若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？</strong></p></blockquote><ul><li><p>我们实体类中的属性<code>id</code>改为<code>uid</code>，将表中的字段<code>id</code>也改为<code>uid</code>，测试添加功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100939157.png" alt="image-20220520100939157"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100715109.png" alt="image-20220520100715109"></p></li><li><p>程序抛出异常，<strong>Field ‘uid’ doesn’t have a default value</strong>，说明MyBatis-Plus没有将<code>uid</code>作为主键赋值</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520101317761.png" alt="image-20220520101317761"></p></li></ul><h3 id="2-2解决问题"><a href="#2-2解决问题" class="headerlink" title="2.2解决问题"></a>2.2解决问题</h3><hr><blockquote><p><strong>在实体类中uid属性上通过<code>@TableId</code>将其标识为主键，即可成功执行SQL语句</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Date</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> Long uid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-TableId的value属性"><a href="#2-3-TableId的value属性" class="headerlink" title="2.3@TableId的value属性"></a>2.3@TableId的value属性</h3><hr><blockquote><p>若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常**Unknown column ‘id’ in ‘field list’**，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，<code>@TableId(&quot;uid&quot;)</code>或<code>@TableId(value=&quot;uid&quot;)</code></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520103030977.png" alt="image-20220520103030977"></p><h3 id="2-4-TableId的type属性"><a href="#2-4-TableId的type属性" class="headerlink" title="2.4@TableId的type属性"></a>2.4@TableId的type属性</h3><hr><blockquote><p><strong>type属性用来定义主键策略：默认雪花算法</strong></p></blockquote><p><strong>常用的主键策略：</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IdType.ASSIGN_ID（默认）</td><td align="center">基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td align="center">IdType.AUTO</td><td align="center">使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，</td></tr></tbody></table><p><strong>配置全局主键策略：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#MyBatis-Plus相关配置</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment">#配置日志</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-comment">#配置mp的主键策略为自增</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br>      <span class="hljs-comment"># 设置实体类所对应的表的统一前缀</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">t_</span><br></code></pre></td></tr></table></figure><h2 id="3-TbaleField"><a href="#3-TbaleField" class="headerlink" title="3.@TbaleField"></a>3.@TbaleField</h2><blockquote><p>经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致</p><p>如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？</p></blockquote><h3 id="3-1情况一"><a href="#3-1情况一" class="headerlink" title="3.1情况一"></a>3.1情况一</h3><hr><p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</p><p>例如实体类属性<code>userName</code>，表中字段<code>user_name</code></p><p>此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格</p><p>相当于在MyBatis中配置</p><h3 id="3-2情况二"><a href="#3-2情况二" class="headerlink" title="3.2情况二"></a>3.2情况二</h3><hr><blockquote><p>若实体类中的属性和表中的字段不满足情况1</p><p>例如实体类属性<code>name</code>，表中字段<code>username</code></p><p>此时需要在实体类属性上使用<code>@TableField(&quot;username&quot;)</code>设置属性所对应的字段名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(&quot;uid&quot;)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@TableField(&quot;username&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-TableLogic"><a href="#4-TableLogic" class="headerlink" title="4.@TableLogic"></a>4.@TableLogic</h2><h3 id="4-1逻辑删除"><a href="#4-1逻辑删除" class="headerlink" title="4.1逻辑删除"></a>4.1逻辑删除</h3><hr><blockquote><p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</p><p>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p><p>使用场景：可以进行数据恢复</p></blockquote><h3 id="4-2实现逻辑删除"><a href="#4-2实现逻辑删除" class="headerlink" title="4.2实现逻辑删除"></a>4.2实现逻辑删除</h3><hr><ul><li><p><strong>数据库中创建逻辑删除状态列，设置默认值为0</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134529809.png" alt="image-20220520134529809"></p></li><li><p><strong>实体类中添加逻辑删除属性</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134636112.png" alt="image-20220520134636112"></p></li><li><p><strong>测试删除功能，真正执行的是修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteById</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.deleteById(<span class="hljs-number">1527472864163348482L</span>);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;删除成功！&quot;</span> : <span class="hljs-string">&quot;删除失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520135637388.png" alt="image-20220520135637388"></p></li><li><p><strong>此时执行查询方法，查询的结果为自动添加条件<code>is_deleted=0</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520140036445.png" alt="image-20220520140036445"></p></li></ul><h1 id="五、条件构造器"><a href="#五、条件构造器" class="headerlink" title="五、条件构造器"></a>五、条件构造器</h1><h2 id="1-Wrapper介绍"><a href="#1-Wrapper介绍" class="headerlink" title="1.Wrapper介绍"></a>1.Wrapper介绍</h2><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521092812125.png" alt="image-20220521092812125"></p><ul><li><p><code>Wrapper</code> ： 条件构造抽象类，最顶端父类</p><ul><li><p><code>AbstractWrapper </code>： 用于查询条件封装，生成 sql 的 where 条件</p><ul><li><p><code>QueryWrapper </code>： 查询条件封装</p></li><li><p><code>UpdateWrapper </code>： Update 条件封装</p></li><li><p><code>AbstractLambdaWrapper </code>： 使用Lambda 语法</p><ul><li><p><code>LambdaQueryWrapper </code>：用于Lambda语法使用的查询Wrapper</p></li><li><p><code>LambdaUpdateWrapper </code>： Lambda 更新封装Wrapper</p></li></ul></li></ul></li></ul></li></ul><h2 id="2-QueryWrapper"><a href="#2-QueryWrapper" class="headerlink" title="2.QueryWrapper"></a>2.QueryWrapper</h2><ul><li><p><strong>组装查询条件</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息</span><br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>).between(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>).isNotNull(<span class="hljs-string">&quot;email&quot;</span>);<br>    List&lt;User&gt; users = userMapper.selectList(queryWrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>组装排序条件</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 ORDER BY age DESC,id ASC</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序</span><br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.orderByDesc(<span class="hljs-string">&quot;age&quot;</span>).orderByAsc(<span class="hljs-string">&quot;id&quot;</span>);<br>    List&lt;User&gt; users = userMapper.selectList(queryWrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>组装删除条件</strong></p><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET is_deleted&#x3D;1 WHERE is_deleted&#x3D;0 AND (email IS NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//删除邮箱地址为null的用户信息</span><br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.isNull(<span class="hljs-string">&quot;email&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.delete(queryWrapper);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;删除成功！&quot;</span> : <span class="hljs-string">&quot;删除失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>条件的优先级</strong></p><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET user_name&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (age &gt; ? AND user_name LIKE ? OR email IS NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改</span><br>    UpdateWrapper&lt;User&gt; updateWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;&gt;();<br>    updateWrapper.gt(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>).like(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>).or().isNull(<span class="hljs-string">&quot;email&quot;</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;Oz&quot;</span>);<br>    user.setEmail(<span class="hljs-string">&quot;test@oz6.com&quot;</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.update(user, updateWrapper);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;修改成功！&quot;</span> : <span class="hljs-string">&quot;修改失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET username&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (username LIKE ? AND (age &gt; ? OR email IS NULL))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test05</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span><br>    UpdateWrapper&lt;User&gt; updateWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;&gt;();<br>    updateWrapper.like(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>).and(i-&gt;i.gt(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>).or().isNull(<span class="hljs-string">&quot;email&quot;</span>));<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;Vz7797&quot;</span>);<br>    user.setEmail(<span class="hljs-string">&quot;test@ss8o.com&quot;</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.update(user, updateWrapper);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;修改成功！&quot;</span> : <span class="hljs-string">&quot;修改失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>组装select子句</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT username,age,email FROM t_user WHERE is_deleted&#x3D;0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test06</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//查询用户的用户名、年龄、邮箱信息</span><br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.select(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br>    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);<br>    maps.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实现子查询</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (uid IN (select uid from t_user where uid &lt;&#x3D; 100))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test07</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//查询id小于等于100的用户信息</span><br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.inSql(<span class="hljs-string">&quot;uid&quot;</span>, <span class="hljs-string">&quot;select uid from t_user where uid &lt;= 100&quot;</span>);<br>    List&lt;User&gt; list = userMapper.selectList(queryWrapper);<br>    list.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-UpdateWrapper"><a href="#3-UpdateWrapper" class="headerlink" title="3.UpdateWrapper"></a>3.UpdateWrapper</h2><blockquote><p>UpdateWrapper不仅拥有QueryWrapper的组装条件功能，还提供了set方法进行修改对应条件的数据库信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test08</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span><br>    UpdateWrapper&lt;User&gt; updateWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;&gt;();<br>    updateWrapper.like(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>).and( i -&gt; i.gt(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>).or().isNull(<span class="hljs-string">&quot;email&quot;</span>)).set(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;svip@qq.com&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.update(<span class="hljs-literal">null</span>, updateWrapper);<br>    System.out.println(result &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;修改成功！&quot;</span> : <span class="hljs-string">&quot;修改失败！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;受影响的行数为：&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-condition"><a href="#4-condition" class="headerlink" title="4.condition"></a>4.condition</h2><blockquote><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果</p></blockquote><ul><li><p><strong>思路一</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (user_name LIKE ? AND age &lt;&#x3D; ?)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test09</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageBegin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageEnd</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(StringUtils.isNotBlank(username))&#123;<br>        <span class="hljs-comment">//isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符</span><br>        queryWrapper.like(<span class="hljs-string">&quot;user_name&quot;</span>, username);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ageBegin != <span class="hljs-literal">null</span>)&#123;<br>        queryWrapper.ge(<span class="hljs-string">&quot;age&quot;</span>, ageBegin);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ageEnd != <span class="hljs-literal">null</span>)&#123;<br>        queryWrapper.le(<span class="hljs-string">&quot;age&quot;</span>, ageEnd);<br>    &#125;<br>    List&lt;User&gt; list = userMapper.selectList(queryWrapper);<br>    list.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>思路二</strong></p><blockquote><p>上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test10</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageBegin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageEnd</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(StringUtils.isNotBlank(username), <span class="hljs-string">&quot;user_name&quot;</span>, username)<br>        .ge(ageBegin != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;age&quot;</span>, ageBegin)<br>        .le(ageEnd != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;age&quot;</span>, ageEnd);<br>    List&lt;User&gt; list = userMapper.selectList(queryWrapper);<br>    list.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-LambdaQueryWrapper"><a href="#5-LambdaQueryWrapper" class="headerlink" title="5.LambdaQueryWrapper"></a>5.LambdaQueryWrapper</h2><blockquote><p>功能等同于QueryWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test11</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageBegin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageEnd</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username)<br>        .ge(ageBegin != <span class="hljs-literal">null</span>, User::getAge, ageBegin)<br>        .le(ageEnd != <span class="hljs-literal">null</span>, User::getAge, ageEnd);<br>    List&lt;User&gt; list = userMapper.selectList(queryWrapper);<br>    list.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-LambdaUpdateWrapper"><a href="#6-LambdaUpdateWrapper" class="headerlink" title="6.LambdaUpdateWrapper"></a>6.LambdaUpdateWrapper</h2><blockquote><p>功能等同于UpdateWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test12</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span><br>    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;&gt;();<br>    updateWrapper.like(User::getName, <span class="hljs-string">&quot;a&quot;</span>)<br>        .and(i -&gt; i.gt(User::getAge, <span class="hljs-number">20</span>).or().isNull(User::getEmail));<br>    updateWrapper.set(User::getName, <span class="hljs-string">&quot;小黑&quot;</span>).set(User::getEmail,<span class="hljs-string">&quot;abc@atguigu.com&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.update(<span class="hljs-literal">null</span>, updateWrapper);<br>    System.out.println(<span class="hljs-string">&quot;result：&quot;</span>+result);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、常用插件"><a href="#六、常用插件" class="headerlink" title="六、常用插件"></a>六、常用插件</h1><h2 id="1-分页插件"><a href="#1-分页插件" class="headerlink" title="1.分页插件"></a>1.分页插件</h2><blockquote><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p></blockquote><ul><li><p><strong>添加配置类<code>MyBatisPlusConfig</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisPlusConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">//添加分页插件</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPage</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//new Page()中的两个参数分别是当前页码，每页显示数量</span><br>    Page&lt;User&gt; page = userMapper.selectPage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-literal">null</span>);<br>    List&lt;User&gt; users = page.getRecords();<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>limit index pageSize</code>  index 即为当前页的第一个记录的条数，index &#x3D; (当前页的页码-1) * pageSize</p><p>new Page&lt;&gt;(1, 2)中1表示要访问第一页，pageSize是2</p></li></ul><h2 id="2-自定义分页"><a href="#2-自定义分页" class="headerlink" title="2.自定义分页"></a>2.自定义分页</h2><blockquote><p>上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？</p></blockquote><ul><li><p><strong>在<code>UserMapper</code>接口中定义一个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 根据年龄查询用户列表，分页显示 </span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 </span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> age 年龄 </span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> </span><br><span class="hljs-comment">  */</span><br>Page&lt;User&gt; <span class="hljs-title function_">selectPageVo</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page,<span class="hljs-meta">@Param(&quot;age&quot;)</span> Integer age)</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>在<code>UserMapper.xml</code>中编写SQL实现该方法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPageVo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    select id,username as name,age,email from t_user where age &gt; #&#123;age&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageVo</span><span class="hljs-params">()</span>&#123;<br>    Page&lt;User&gt; page = userMapper.selectPageVo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;User&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>), <span class="hljs-number">20</span>);<br>    List&lt;User&gt; users = page.getRecords();<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h2><blockquote><p><strong>作用：当要更新一条记录的时候，希望这条记录没有被别人更新</strong></p></blockquote><p>乐观锁的实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li><li>如果 version 不对，就更新失败</li></ul><h3 id="3-1场景"><a href="#3-1场景" class="headerlink" title="3.1场景"></a>3.1场景</h3><hr><ul><li>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。</li><li>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50&#x3D;150元存入了数据库；小王将商品减了30元，并将100-30&#x3D;70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。</li><li>现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。</li></ul><h3 id="3-2乐观锁与悲观锁"><a href="#3-2乐观锁与悲观锁" class="headerlink" title="3.2乐观锁与悲观锁"></a>3.2乐观锁与悲观锁</h3><hr><ul><li>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。</li><li>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。</li></ul><h3 id="3-3模拟修改冲突"><a href="#3-3模拟修改冲突" class="headerlink" title="3.3模拟修改冲突"></a>3.3模拟修改冲突</h3><hr><ul><li><p><strong>数据库中增加商品表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_product ( <br>    id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>, <br>    NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品名称&#x27;</span>, <br>    price <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;价格&#x27;</span>, <br>    VERSION <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;乐观锁版本号&#x27;</span>, <br>    <span class="hljs-keyword">PRIMARY</span> KEY (id) <br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>添加一条数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_product (id, NAME, price) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;外星人笔记本&#x27;</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>添加一个实体类<code>Product</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-keyword">private</span> Integer version;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>添加一个Mapper接口<code>ProductMapper</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testProduct01</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//1.小李获取商品价格</span><br>    <span class="hljs-type">Product</span> <span class="hljs-variable">productLi</span> <span class="hljs-operator">=</span> productMapper.selectById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());<br><br>    <span class="hljs-comment">//2.小王获取商品价格</span><br>    <span class="hljs-type">Product</span> <span class="hljs-variable">productWang</span> <span class="hljs-operator">=</span> productMapper.selectById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());<br><br>    <span class="hljs-comment">//3.小李修改商品价格+50</span><br>    productLi.setPrice(productLi.getPrice()+<span class="hljs-number">50</span>);<br>    productMapper.updateById(productLi);<br><br>    <span class="hljs-comment">//4.小王修改商品价格-30</span><br>    productWang.setPrice(productWang.getPrice()-<span class="hljs-number">30</span>);<br>    productMapper.updateById(productWang);<br><br>    <span class="hljs-comment">//5.老板查询商品价格</span><br>    <span class="hljs-type">Product</span> <span class="hljs-variable">productBoss</span> <span class="hljs-operator">=</span> productMapper.selectById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>执行结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521225803162.png" alt="image-20220521225803162"></p></li></ul><h3 id="3-4乐观锁解决问题"><a href="#3-4乐观锁解决问题" class="headerlink" title="3.4乐观锁解决问题"></a>3.4乐观锁解决问题</h3><hr><ul><li><p><strong>实体类<code>version</code>字段添加注解<code>@Version</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-meta">@Version</span><br>    <span class="hljs-keyword">private</span> Integer version;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>添加乐观锁插件配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>    <span class="hljs-comment">//添加分页插件</span><br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<br>    <span class="hljs-comment">//添加乐观锁插件</span><br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>());<br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>再次执行测试方法</strong></p><blockquote><p>小李查询商品信息：</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小王查询商品信息：</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小李修改商品价格，自动将version+1</p><p>​UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>小王修改商品价格，此时version已更新，条件不成立，修改失败</p><p>​UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>最终，小王修改失败，查询价格：150</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p></blockquote></li><li><p><strong>优化执行流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testProduct01</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//1.小李获取商品价格</span><br>    <span class="hljs-type">Product</span> <span class="hljs-variable">productLi</span> <span class="hljs-operator">=</span> productMapper.selectById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());<br><br>    <span class="hljs-comment">//2.小王获取商品价格</span><br>    <span class="hljs-type">Product</span> <span class="hljs-variable">productWang</span> <span class="hljs-operator">=</span> productMapper.selectById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());<br><br>    <span class="hljs-comment">//3.小李修改商品价格+50</span><br>    productLi.setPrice(productLi.getPrice()+<span class="hljs-number">50</span>);<br>    productMapper.updateById(productLi);<br><br>    <span class="hljs-comment">//4.小王修改商品价格-30</span><br>    productWang.setPrice(productWang.getPrice()-<span class="hljs-number">30</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> productMapper.updateById(productWang);<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//操作失败，重试</span><br>        <span class="hljs-type">Product</span> <span class="hljs-variable">productNew</span> <span class="hljs-operator">=</span> productMapper.selectById(<span class="hljs-number">1</span>);<br>        productNew.setPrice(productNew.getPrice()-<span class="hljs-number">30</span>);<br>        productMapper.updateById(productNew);<br>    &#125;<br><br>    <span class="hljs-comment">//5.老板查询商品价格</span><br>    <span class="hljs-type">Product</span> <span class="hljs-variable">productBoss</span> <span class="hljs-operator">=</span> productMapper.selectById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521230448577.png" alt="image-20220521230448577"></p></li></ul><h1 id="七、通用枚举"><a href="#七、通用枚举" class="headerlink" title="七、通用枚举"></a>七、通用枚举</h1><blockquote><p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p></blockquote><ul><li><p><strong>数据库表添加字段<code>sex</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521231317777.png" alt="image-20220521231317777"></p></li><li><p><strong>创建通用枚举类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SexEnum</span> &#123;<br>    MALE(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>),<br>    FEMALE(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;女&quot;</span>);<br><br>    <span class="hljs-meta">@EnumValue</span> <span class="hljs-comment">//将注解所标识的属性的值存储到数据库中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br>    <span class="hljs-keyword">private</span> String sexName;<br><br>    SexEnum(Integer sex, String sexName) &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.sexName = sexName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>User实体类中添加属性sex</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@TableField(&quot;username&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-meta">@TableLogic</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> isDeleted;  <span class="hljs-comment">//逻辑删除</span><br><br>    <span class="hljs-keyword">private</span> SexEnum sex;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>配置扫描通用枚举</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#MyBatis-Plus相关配置</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-comment">#指定mapper文件所在的地址</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment">#配置日志</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">banner:</span> <span class="hljs-string">off</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-comment">#配置mp的主键策略为自增</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br>      <span class="hljs-comment"># 设置实体类所对应的表的统一前缀</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">t_</span><br>  <span class="hljs-comment">#配置类型别名所对应的包</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.atguigu.mybatisplus.pojo</span><br>  <span class="hljs-comment"># 扫描通用枚举的包</span><br>  <span class="hljs-attr">type-enums-package:</span> <span class="hljs-string">com.atguigu.mybatisplus.enums</span><br></code></pre></td></tr></table></figure></li><li><p><strong>执行测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;admin&quot;</span>);<br>    user.setAge(<span class="hljs-number">33</span>);<br>    user.setSex(SexEnum.MALE);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insert(user);<br>    System.out.println(<span class="hljs-string">&quot;result:&quot;</span>+result);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="八、多数据源"><a href="#八、多数据源" class="headerlink" title="八、多数据源"></a>八、多数据源</h1><blockquote><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p></blockquote><p>场景说明：</p><p>我们创建两个库，分别为：<code>mybatis_plus</code>（以前的库不动）与<code>mybatis_plus_1</code>（新建），将mybatis_plus库的<code>product</code>表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p><h2 id="1-创建数据库及表"><a href="#1-创建数据库及表" class="headerlink" title="1.创建数据库及表"></a>1.创建数据库及表</h2><ul><li><p><strong>创建数据库<code>mybatis_plus_1</code>和表&#96;product</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE `mybatis_plus_1` <span class="hljs-comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;<br>use `mybatis_plus_1`; <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product ( <br>    id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>, <br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品名称&#x27;</span>, <br>    price <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;价格&#x27;</span>, <br>    version <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;乐观锁版本号&#x27;</span>, <br>    <span class="hljs-keyword">PRIMARY</span> KEY (id) <br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>添加测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> product (id, NAME, price) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;外星人笔记本&#x27;</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>删除<code>mybatis_plus</code>库中的<code>product</code>表</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">use mybatis_plus; <br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> product;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-新建工程引入依赖"><a href="#2-新建工程引入依赖" class="headerlink" title="2.新建工程引入依赖"></a>2.新建工程引入依赖</h2><blockquote><p><strong>自行新建一个Spring Boot工程并选择MySQL驱动及Lombok依赖</strong></p></blockquote><p><strong>引入MyBaits-Plus的依赖及多数据源的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-编写配置文件"><a href="#3-编写配置文件" class="headerlink" title="3.编写配置文件"></a>3.编写配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># 配置数据源信息</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">dynamic:</span><br>      <span class="hljs-comment"># 设置默认的数据源或者数据源组,默认值即为master</span><br>      <span class="hljs-attr">primary:</span> <span class="hljs-string">master</span><br>      <span class="hljs-comment"># 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源</span><br>      <span class="hljs-attr">strict:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">datasource:</span><br>        <span class="hljs-attr">master:</span><br>          <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span><br>          <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>          <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>          <span class="hljs-attr">password:</span> <span class="hljs-number">132537</span><br>        <span class="hljs-attr">slave_1:</span><br>          <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false</span><br>          <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>          <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>          <span class="hljs-attr">password:</span> <span class="hljs-number">132537</span><br></code></pre></td></tr></table></figure><h2 id="4-创建实体类"><a href="#4-创建实体类" class="headerlink" title="4.创建实体类"></a>4.创建实体类</h2><ul><li><p>新建一个<code>User</code>实体类（如果数据库表名有t_前缀记得配置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建一个实体类<code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-keyword">private</span> Integer version;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-创建Mapper及Service"><a href="#5-创建Mapper及Service" class="headerlink" title="5.创建Mapper及Service"></a>5.创建Mapper及Service</h2><ul><li><p>新建接口<code>UserMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建接口<code>ProductMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建Service接口<code>UserService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DS(&quot;master&quot;)</span> <span class="hljs-comment">//指定操作的数据源，master为user表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建Service接口<code>ProductService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DS(&quot;slave_1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;Product&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>自行建立Service的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-编写测试方法"><a href="#6-编写测试方法" class="headerlink" title="6.编写测试方法"></a>6.编写测试方法</h2><blockquote><p><strong>记得在启动类中添加注解<code>@MapperScan()</code></strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDatasourceApplicationTests</span> &#123;<br><span class="hljs-meta">@Resource</span><br>UserService userService;<br><br><span class="hljs-meta">@Resource</span><br>ProductService productService;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(<span class="hljs-number">1L</span>);<br><span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productService.getById(<span class="hljs-number">1L</span>);<br>System.out.println(<span class="hljs-string">&quot;User = &quot;</span> + user);<br>System.out.println(<span class="hljs-string">&quot;Product = &quot;</span> + product);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522113049945.png" alt="image-20220522113049945"></p><h1 id="九、MyBatisX插件"><a href="#九、MyBatisX插件" class="headerlink" title="九、MyBatisX插件"></a>九、MyBatisX插件</h1><blockquote><p>MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。</p><p>但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。</p><p>MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。</p></blockquote><h2 id="1-安装MyBatisX插件"><a href="#1-安装MyBatisX插件" class="headerlink" title="1.安装MyBatisX插件"></a>1.安装MyBatisX插件</h2><blockquote><p><strong>打开IDEA，File-&gt; Setteings-&gt;Plugins-&gt;MyBatisX，搜索栏搜索MyBatisX然后安装。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522115718361.png" alt="image-20220522115718361"></p><h2 id="2-快速生成代码"><a href="#2-快速生成代码" class="headerlink" title="2.快速生成代码"></a>2.快速生成代码</h2><ul><li><p>新建一个Spring Boot项目引入依赖（创建工程时记得勾选lombok及mysql驱动）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置数据源信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">132537</span><br></code></pre></td></tr></table></figure></li><li><p>在IDEA中与数据库建立链接</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522120758740.png" alt="image-20220522120758740"></p></li><li><p>填写数据库信息并保存</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121434468.png" alt="image-20220522121434468"></p></li><li><p>找到我们需要生成的表点击右键</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121613909.png" alt="image-20220522121613909"></p></li><li><p>填写完信息以后下一步</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122127649.png" alt="image-20220522122127649"></p></li><li><p>继续填写信息</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122525598.png" alt="image-20220522122525598"></p></li><li><p><strong>大功告成（真特么好用yyds）</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122612334.png" alt="image-20220522122612334"></p></li></ul><h2 id="3-快速生成CRUD"><a href="#3-快速生成CRUD" class="headerlink" title="3.快速生成CRUD"></a>3.快速生成CRUD</h2><blockquote><p>MyBaitsX可以根据我们在Mapper接口中输入的方法名快速帮我们生成对应的sql语句</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123143852.png" alt="image-20220522123143852"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123202310.png" alt="image-20220522123202310"></p><h1 id="十、致谢"><a href="#十、致谢" class="headerlink" title="十、致谢"></a>十、致谢</h1><p>感谢尚硅谷杨博超老师：<a href="https://www.bilibili.com/video/BV12R4y157Be?p=1">https://www.bilibili.com/video/BV12R4y157Be?p=1</a></p><p>感谢MyBatis-Plus作者苞米豆：<a href="https://baomidou.com/">https://baomidou.com/</a></p><p>感谢自己又坚持学习了一门课程：<a href="https://www.oz6.cn/">https://www.oz6.cn/</a></p>]]></content>
    
    
    <categories>
      
      <category>FrameWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>MyBatis-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础-java8新特性</title>
    <link href="/2022/10/18/Java/JavaSE/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/10/18/Java/JavaSE/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1、性能提升"><a href="#1、性能提升" class="headerlink" title="1、性能提升"></a>1、性能提升</h1><ol><li>jdk1.7以前，方法区通过永久代来实现。jdk1.8后，方法区通过元空间(MetaSpace)来实现，而元空间是本地内存。</li><li>哈希表中，当一个桶中的元素个数超过8(&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;)，会将链表转化为红黑树。</li></ol><h1 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h1><p> 学习lambda表达式之前，先了解一下匿名匿名内部类。</p><h2 id="2-1-匿名内部类"><a href="#2-1-匿名内部类" class="headerlink" title="2.1 匿名内部类"></a>2.1 匿名内部类</h2><p><a href="https://www.runoob.com/w3cnote/java-inner-class-intro.html#:~:text=%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%94%AF,%E5%AE%9E%E7%8E%B0%E6%88%96%E6%98%AF%E9%87%8D%E5%86%99%E3%80%82">这是有关内部类的讲解</a></p><p>对于<a href="https://www.cnblogs.com/wuhenzhidu/p/anonymous.html">匿名内部类</a>，它是一个表达式，最后用 ; 结尾，主体是一对大括号，里面编写代码逻辑。匿名内部类有父类，或者有接口。一般是用于 这个实例只使用一次，为了简洁，就不要为它再创建一个类，直接使用匿名内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <br>        <span class="hljs-comment">//匿名内部类写法</span><br>        <span class="hljs-comment">//Comparator是一个接口</span><br>        Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer t1, Integer t2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(t1,t2);<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-comment">//lambda表达式</span><br>        Comparator&lt;Integer&gt; comparator1 = ((t1,t2) -&gt; Integer.compare(t1,t2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-Lambda表达式"><a href="#2-2-Lambda表达式" class="headerlink" title="2.2 Lambda表达式"></a>2.2 Lambda表达式</h2><p><strong>基础语法：</strong>java8中引入了一个新的操作符<code>-&gt;</code>，该操作符称为箭头操作符或lambda操作符。</p><p>箭头操作符将lambda表达式拆分成两个部分，<strong>左侧</strong>是lambda表达式的参数列表，如果是接口，即是接口中抽象方法的参数列表，<strong>右侧</strong>是lambda表达式中所需执行的功能，lambda体，即对该抽象方法的具体实现。</p><hr><p><strong>语法格式一：抽象方法无参数，无返回值。</strong></p><p>​<code>() -&gt; System.out.println(&quot;hello!&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>        &#125;<br>    &#125;;<br>    runnable.run();<br>    <span class="hljs-comment">//=======================================</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable1</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    runnable1.run();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>语法格式二：有一个参数，无返回值</strong></p><p>​<code>(x) -&gt; System.out.println(x);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//实现accept这个抽象方法</span><br>    Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);<br>    con.accept(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T var1)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>语法格式三：如果只有一个参数，小括号可以不写</strong>(不过一般都写)</p><p><strong>语法格式四：有两个以上参数，有返回值，并且lambda体中有多条语句，则语句写在大括号中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; comparator1 = ((t1,t2) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;hahah&quot;</span>);<br>    <span class="hljs-keyword">return</span> Integer.compare(t1,t2);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>语法格式五：有两个以上参数，有返回值，如果只有一条语句，则大括号和return都可以省略不写</strong></p><p>​<code>Comparator&lt;Integer&gt; comparator1 = ((t1,t2) -&gt; Integer.compare(t1,t2));</code></p><p><strong>语法格式六：lambda表达式的参数列表的数据类型可以省略不写，因为jvm编译器通过上下文可以推断出超参数的数据类型</strong>(通过前面泛型推断)</p><p>​<code>Comparator&lt;Integer&gt; comparator1 = ((Integer t1,Integer t2) -&gt; Integer.compare(t1,t2));</code></p><hr><p>lambda表达式需要“函数式接口”的支持。<strong>函数式接口</strong>即接口中只能有一个抽象方法的接口。可以使用注解<code>@FunctionalInterface</code>修饰，表明这个接口必须是函数式接口</p><hr><p>使用lambda表达式的例子：(利用设计模式中的策略模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> get(<span class="hljs-number">2</span>,(x) -&gt; x * x);<br>    <span class="hljs-comment">//4</span><br>    System.out.println(res);<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">get</span><span class="hljs-params">(Integer num,Operation operation)</span>&#123;<br>    <span class="hljs-keyword">return</span> operation.getValue(num);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Operation</span>&#123;<br>    Integer <span class="hljs-title function_">getValue</span><span class="hljs-params">(Integer num)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-java8内置的四大核心函数式接口"><a href="#2-3-java8内置的四大核心函数式接口" class="headerlink" title="2.3 java8内置的四大核心函数式接口"></a>2.3 java8内置的四大核心函数式接口</h2><ol><li><p>Consumer<T>  消费型接口</p><p><code>void accpet(T t);</code></p></li><li><p>Supplier<T> 供给型接口</p><p><code>T get();</code></p></li><li><p>Function&lt;T,R&gt; 函数型接口</p><p><code>R apply(T t);</code></p></li><li><p>Predicate<T> 断言型接口</p><p><code>boolean test(T t);</code></p></li></ol><p>还有他们的子类接口也可以使用</p><h2 id="2-4-方法引用"><a href="#2-4-方法引用" class="headerlink" title="2.4 方法引用"></a>2.4 方法引用</h2><p>为了更加简化lambda表达式。</p><p>方法引用是什么？ 若lambda体中的内容有方法已经实现了，我们可以使用”方法引用”，可以理解为方法引用是lambda表达式的另外一种表现形式。</p><p>【注意事项】1、使用的前提是lambda体中方法的参数列表和返回值类型要与函数式接口中抽象方法的参数列表和返回值类型保持一致。  2、若lambda参数列表的第一参数是实例方法的调用者，而第二参数是实例方法的参数时，可以使用<strong>类::实例方法名</strong></p><p>分为：<strong>类::静态方法名</strong>    <strong>对象::实例方法名</strong>   <strong>类::实例方法名</strong></p><h2 id="2-5-构造器引用"><a href="#2-5-构造器引用" class="headerlink" title="2.5 构造器引用"></a>2.5 构造器引用</h2><p><strong>类名::new</strong></p><p>构造器的参数列表和函数式接口中抽象方法的列表中参数个数是一致的。比如抽象方法的参数个数是0个，那就默认匹配类的无参构造器。</p><h2 id="2-6-数组引用"><a href="#2-6-数组引用" class="headerlink" title="2.6 数组引用"></a>2.6 数组引用</h2><p><strong>Type::new</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//对象::实例方法</span><br>    Consumer&lt;Integer&gt; com = (x) -&gt; System.out.println(x);<br>    Consumer&lt;Integer&gt; com1 = System.out::println;<br><br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>    Supplier&lt;String&gt; sup = () -&gt; employee.getName();<br>    System.out.println(sup.get());<br><br>    Supplier&lt;String&gt; sup1 = employee::getName;<br>    System.out.println(sup.get());<br><br>    <span class="hljs-comment">//类::静态方法名</span><br>    Comparator&lt;Integer&gt; com3 = (x,y) -&gt; Integer.compare(x,y);<br>    Comparator&lt;Integer&gt; com4 = Integer::compareTo;<br><br>    <span class="hljs-comment">//类::实例方法名</span><br>    BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y);<br>    BiPredicate&lt;String,String&gt; bp1 = String::equals;<br><br>    <span class="hljs-comment">//构造器引用</span><br>    <span class="hljs-comment">//类::new</span><br>    Supplier&lt;Employee&gt; employeeSupplier = Employee::<span class="hljs-keyword">new</span>;<br><br>    <span class="hljs-comment">//数组引用</span><br>    Function&lt;Integer,String[]&gt; fun = (x) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[x];<br>    String[] strings = fun.apply(<span class="hljs-number">10</span>);<br>    System.out.println(strings.length);<br>    <br>    Function&lt;Integer,String[]&gt; function = String[]::<span class="hljs-keyword">new</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3、StreamAPI"><a href="#3、StreamAPI" class="headerlink" title="3、StreamAPI"></a>3、StreamAPI</h1><p>【流】是数据渠道，用于操作数据源（数组、集合等）所生成的元素序列。</p><ul><li>Stream自己不会存储元素</li><li>Stream不会改变源对象，而是返回一个全新的流</li><li>Stream操作时延迟执行的，它们会等到需要结果时才执行</li></ul><p><strong>流操作的三个步骤：</strong></p><p><img src="/../../../image/java/stream/stream1.png"></p><h2 id="3-1-创建Stream"><a href="#3-1-创建Stream" class="headerlink" title="3.1 创建Stream"></a>3.1 创建Stream</h2><ol><li>通过Collection系列集合提供的<code>stream()</code>或者<code>parallelStream()</code></li></ol><p><img src="/../../../image/java/stream/1.png"></p><h2 id="3-2-Stream的筛选与切片"><a href="#3-2-Stream的筛选与切片" class="headerlink" title="3.2 Stream的筛选与切片"></a>3.2 Stream的筛选与切片</h2><p><img src="/../../../image/java/stream/2.png"></p><h3 id="（1）filter"><a href="#（1）filter" class="headerlink" title="（1）filter"></a>（1）filter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; predicate)</span>;<br></code></pre></td></tr></table></figure><p>filter()参数内需要传一个断言型lambda表达式，即传一个参数，返回一个boolean类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.stream()<br>                .filter((x) -&gt; x.isBlank())<br>                .forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="（2）limit"><a href="#（2）limit" class="headerlink" title="（2）limit"></a>（2）limit</h3><p>一旦发现满足条件的两个数据，其他后序的迭代操作就不再继续进行了。</p><p><img src="/../../../image/java/stream/3.png"></p><h3 id="（3）skip、distinct"><a href="#（3）skip、distinct" class="headerlink" title="（3）skip、distinct()"></a>（3）skip、distinct()</h3><p><img src="/../../../image/java/stream/4.png"></p><h2 id="3-3-映射"><a href="#3-3-映射" class="headerlink" title="3.3 映射"></a>3.3 映射</h2><h3 id="（1）map"><a href="#（1）map" class="headerlink" title="（1）map"></a>（1）map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends R&gt; mapper)</span>;<br></code></pre></td></tr></table></figure><p>map接收一个函数型接口（即一个函数），即传进去一个参数，返回一个值，也可以直接传一个函数。即依次取出集合中的每个元素，然后对这个元素应用到函数上。</p><p><img src="/../../../image/java/stream/5.png"></p><p><img src="/../../../image/java/stream/6.png"></p><h3 id="（2）flatMap"><a href="#（2）flatMap" class="headerlink" title="（2）flatMap"></a>（2）flatMap</h3><p>如果接收的每个元素都是一个流的话，flatMap可以把流中的每个元素统一添加到一个流中。而map的话是把这个流直接加到一个统一的流中。</p><h2 id="4、排序"><a href="#4、排序" class="headerlink" title="4、排序"></a>4、排序</h2><p><img src="/../../../image/java/stream/7.png"></p><h2 id="5、查找与匹配"><a href="#5、查找与匹配" class="headerlink" title="5、查找与匹配"></a>5、查找与匹配</h2><p><img src="/../../../image/java/stream/8.png"></p><p><img src="/../../../image/java/stream/10.png"></p><p><img src="/../../../image/java/stream/9.png"></p><h2 id="6、归约与查找"><a href="#6、归约与查找" class="headerlink" title="6、归约与查找"></a>6、归约与查找</h2><h3 id="（1）归约"><a href="#（1）归约" class="headerlink" title="（1）归约"></a>（1）归约</h3><p><img src="/../../../image/java/stream/11.png"></p><p><img src="/../../../image/java/stream/12.png"></p><h3 id="（2）收集"><a href="#（2）收集" class="headerlink" title="（2）收集"></a>（2）收集</h3><p><img src="/../../../image/java/stream/13.png"></p><p><img src="/../../../image/java/stream/14.png"></p><p><strong>将结果收集到特定集合中</strong></p><p><img src="/../../../image/java/stream/15.png"></p><p><strong>对数据进行求和</strong></p><p><img src="/../../../image/java/stream/16.png"></p><p><img src="/../../../image/java/stream/17.png"></p><p><strong>分组</strong></p><p><img src="/../../../image/java/stream/18.png"></p><p><strong>多级分组</strong></p><p><img src="/../../../image/java/stream/19.png"></p><p><strong>分区</strong></p><p><img src="/../../../image/java/stream/20.png"></p><p>只有true和false区</p><h1 id="4、Optional类"><a href="#4、Optional类" class="headerlink" title="4、Optional类"></a>4、Optional类</h1><p>Optional&lt; T &gt;类是一个容器类，代表一个值存在或者不存在，原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</p><p><img src="/../../../image/java/stream/21.png"></p><h1 id="5、接口中的默认方法和静态方法"><a href="#5、接口中的默认方法和静态方法" class="headerlink" title="5、接口中的默认方法和静态方法"></a>5、接口中的默认方法和静态方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">practiceInterface</span> &#123;<br>    <br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;haha&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hehe&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架-SpringBoot</title>
    <link href="/2022/09/26/Java/framework/springboot/"/>
    <url>/2022/09/26/Java/framework/springboot/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础使用"><a href="#一、基础使用" class="headerlink" title="一、基础使用"></a>一、基础使用</h1><h2 id="1、创建SpringBoot项目"><a href="#1、创建SpringBoot项目" class="headerlink" title="1、创建SpringBoot项目"></a>1、创建SpringBoot项目</h2><p>创建一个空项目。</p><ol><li><p>首先修改maven版本</p><p><code>File -&gt; Settings -&gt; maven</code></p></li><li><p>创建一个springboot模块</p><p>这里也可以选择阿里云提供的 <code>https://start/aliyun.com</code></p><p><img src="/../../../image/springboot/1.png"></p><p><img src="/../../../image/springboot/2.png"></p><p><img src="/../../../image/springboot/3.png"></p><p><code>Settings -&gt; Editor -&gt; File Types</code></p><p><img src="/../../../image/springboot/4.png"></p></li></ol><h2 id="2、pom文件"><a href="#2、pom文件" class="headerlink" title="2、pom文件"></a>2、pom文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot项目都需要继承<code>spring-boot-starter-parent</code>，<code>spring-boot-starter-parent</code>中定义了若干个依赖管理，对有些依赖的版本管理，当在我们的这个项目中引入这个依赖，就不需要指定它的版本，这样可以避免多个依赖使用相同技术时出现的依赖版本冲突。</p><p>start包含了若干个依赖信息，我们只需要导入start就可以，来减少以来配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3、引导类"><a href="#3、引导类" class="headerlink" title="3、引导类"></a>3、引导类</h2><p>这是Spring的容器，是整个boot工程的执行入口。</p><p>springboot工程运行后初始化Spring容器，扫描引导类所在包加载bean</p><p>扫描引导类所在包及其子包的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot0101QuickstartApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这个的返回类型就是Applicationcontext</span><br>SpringApplication.run(Springboot0101QuickstartApplication.class, args);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、内嵌的tomcat服务器"><a href="#4、内嵌的tomcat服务器" class="headerlink" title="4、内嵌的tomcat服务器"></a>4、内嵌的tomcat服务器</h2><p>内嵌的Tomcat工作原理是将tomcat服务器作为对象运行，并将该对象交给Spring容器管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.65<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>tomcat-embed-co re是tomcat核心</p><h1 id="二、yml配置文件详解"><a href="#二、yml配置文件详解" class="headerlink" title="二、yml配置文件详解"></a>二、yml配置文件详解</h1><h2 id="1、不同后缀"><a href="#1、不同后缀" class="headerlink" title="1、不同后缀"></a>1、不同后缀</h2><h3 id="properties"><a href="#properties" class="headerlink" title=".properties"></a>.properties</h3><p> springboot中默认配置文件<code>application.properties</code>，通过键值对配置对应属性。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-comment">#显示日志的级别</span><br><span class="hljs-attr">logging.level.root</span>=<span class="hljs-string">info</span><br></code></pre></td></tr></table></figure><p>配置规则信息可以在<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties%E8%BF%99%E9%87%8C%E7%9C%8B">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties这里看</a></p><h3 id="yml"><a href="#yml" class="headerlink" title=".yml"></a>.yml</h3><p><strong>这是springboot使用的主流模式。</strong></p><p><code>application.yml</code></p><p><strong>冒号后面要有空格</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="yaml"><a href="#yaml" class="headerlink" title=".yaml"></a>.yaml</h3><p><code>application.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment">#对象数组</span><br><span class="hljs-attr">user:</span><br>  <span class="hljs-bullet">-</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">12</span><br>  <span class="hljs-bullet">-</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">lisi</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>如果这三个文件都存在的话，优先级：<code>.properties</code> &gt; <code>.yml</code> &gt; <code>.yaml</code></p><p>并且他们的不同属性共存叠加，相同的属性相互覆盖。</p><p><strong>常用的是yml</strong></p><hr><p>如果你创建的yml文件图标不是绿色的，写属性的时候没有提示，说明springboot不认为它是一个配置文件，需要我们手动设置。</p><p><img src="/../../../image/springboot/8.png"></p><p><img src="/../../../image/springboot/9.png"></p><h2 id="2、yaml读取配置文件中的数据"><a href="#2、yaml读取配置文件中的数据" class="headerlink" title="2、yaml读取配置文件中的数据"></a>2、yaml读取配置文件中的数据</h2><h3 id="1、读取单个属性值"><a href="#1、读取单个属性值" class="headerlink" title="1、读取单个属性值"></a>1、读取单个属性值</h3><p><strong>使用@Value读取单个数据</strong>，属性名引用方式：<code>$&#123;一级属性名.二级属性名&#125;</code></p><p><img src="/../../../image/springboot/10.png"></p><p>最后一个用String接收就可以，不用写成字符串数组String[]的形式。</p><p><strong>yaml文件中的变量引用</strong></p><p><img src="/../../../image/springboot/11.png"></p><hr><p>使用Environment对象封装全部配置信息，使用Autowired自动装配数据到Environment队长中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#yaml中</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>如何读取？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Controller层</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Environment environment;<br><br><span class="hljs-meta">@GetMapping(&quot;h&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hahh</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//括号里的内容和上面用$&#123;&#125;中的一样</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;server.port&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;haha&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2、方法一：-ConfigurationProperties-绑定一个bean"><a href="#2、方法一：-ConfigurationProperties-绑定一个bean" class="headerlink" title="2、方法一：@ConfigurationProperties 绑定一个bean"></a>2、方法一：@ConfigurationProperties 绑定一个bean</h3><p>将yaml指定属性封装为一个java对象，同时里面的值就是yaml的属性值。</p><p>对象属性名要与yaml中的属性名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-comment">// prefix的值是yaml的属性值名字</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;datasources&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataSources</span> &#123;<br>    <span class="hljs-comment">//类的属性名要与yaml中的一致</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">datasource:</span><br>  <span class="hljs-attr">driver:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost/springboot_db</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>使用的时候加上<code>@Autowired</code>即可</p><hr><h3 id="3、方法二：-EnableConfigurationProperties"><a href="#3、方法二：-EnableConfigurationProperties" class="headerlink" title="3、方法二：@EnableConfigurationProperties"></a>3、方法二：@EnableConfigurationProperties</h3><p>也可以使用这种方式将yml中的属性值注入到对象中。在用到的时候写Enable这个注解，实体类上不需要再写Component注解</p><p><img src="/../../../image/springboot/26.png"></p><hr><p><img src="/../../../image/springboot/27.png"></p><p>出现这个问题，引入这个依赖就可以了</p><p><img src="/../../../image/springboot/28.png"></p><h3 id="4、自定义配置文件名称"><a href="#4、自定义配置文件名称" class="headerlink" title="4、自定义配置文件名称"></a>4、自定义配置文件名称</h3><p>比如配置文件名为<code>server.yml</code></p><p>Edit Configurations -&gt;Program arguments</p><ul><li><p>通过启动参数加载配置文件</p><p><code>--spring.config.name=server</code></p></li><li><p>通过启动参数加载指定文件路径下的配置文件</p><p><code>--spring.config.location=classpath:/server.yml</code></p></li></ul><h3 id="5、多环境开发的yml文件配置"><a href="#5、多环境开发的yml文件配置" class="headerlink" title="5、多环境开发的yml文件配置"></a>5、多环境开发的yml文件配置</h3><p><img src="/../../../image/springboot/21.png"></p><p>最上面是当前选择启动环境</p><p>设置环境推荐这个4行的。</p><p>下面就是当前环境具体的参数设定。</p><hr><p>也可以创建多个yml文件，将这几个环境分开。</p><p><code>application-dev.yml</code>开发环境</p><p><code>application-pro.yml</code>生产环境</p><p><code>application-test.yml</code>测试环境</p><p><code>application.yml</code>是主配置文件，指定运行哪个配置文件。</p><p>主配置文件中设置公共配置（全局)<br>环境分类配置文件中常用于设置冲突属性（局部)</p><hr><p><img src="/../../../image/springboot/22.png"></p><p><strong>include中后面的配置文件会覆盖前面的相同的属性。</strong></p><p><img src="/../../../image/springboot/23.png"></p><h3 id="6、宽松绑定"><a href="#6、宽松绑定" class="headerlink" title="6、宽松绑定"></a>6、宽松绑定</h3><p><img src="/../../../image/springboot/29.png"></p><p>yml属性中的名无论大小写，加不加下划线，中划线，都会被匹配成功。类中也是这样</p><p><img src="/../../../image/springboot/30.png"></p><p>也就是注解@ConfigurationProperties(prefix &#x3D; “datasources”)里面的prefix中的值不能有大写</p><h1 id="三、SpringBoot整合第三方技术"><a href="#三、SpringBoot整合第三方技术" class="headerlink" title="三、SpringBoot整合第三方技术"></a>三、SpringBoot整合第三方技术</h1><h2 id="1、整合JUint"><a href="#1、整合JUint" class="headerlink" title="1、整合JUint"></a>1、整合JUint</h2><ol><li><p>导入测试对应的starter，一般在创建的SpringBoot项目中都自动有这个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试类使用@SpringBootTest修饰</p></li><li><p>使用自动装配的形式添加要测试的对象。</p></li></ol><p>如果对应的类不在引导类在的包及其子包下的话，这个测试类就不会被扫描到，需要在注解@SpringBootTest中指定引导类是谁</p><p><code>@SpringBootTest(classes = Springboot0101QuickstartApplication.class)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot0101QuickstartApplicationTests</span> &#123;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、整合MyBatis"><a href="#2、整合MyBatis" class="headerlink" title="2、整合MyBatis"></a>2、整合MyBatis</h2><p>创建一个全新的工程，记得在这一步选择MyBatis需要的模块，这样的话创建的工程会自动导入相关的依赖。</p><p><img src="/../../../image/springboot/12.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入对应的start --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步：设置数据源参数（在yml文件中配置）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">111111</span><br></code></pre></td></tr></table></figure><p>第三步：创建实体类对象。要与表结构对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String address;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步：数据库SQL映射需要添加@Mapper被容器识别到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from tb_student where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">getById</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、整合MyBatis-Plus"><a href="#3、整合MyBatis-Plus" class="headerlink" title="3、整合MyBatis-Plus"></a>3、整合MyBatis-Plus</h2><p>直接创建一个SpringBoot项目，创建时只添加MySQL Driver</p><p>第一步：引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将spring-boot-starter依赖删除</p><p>第二步：创建实体类对象</p><p>第三步：创建Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Student&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步：yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://xxznzhs.top:3306/test?serverTimezone=UTC</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">196131</span><br><br><span class="hljs-comment">#设置表前缀</span><br><span class="hljs-comment">#数据库中是tb_student，实体类名字为Student,mybatis-plus默认会去找student，所以要加上前缀</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">tb_</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><h2 id="4、整合Redis"><a href="#4、整合Redis" class="headerlink" title="4、整合Redis"></a>4、整合Redis</h2><p>1、导入对应的依赖</p><p><img src="/../../../image/springboot/33.png"></p><p><img src="/../../../image/springboot/34.png"></p><p>redis 是保存在缓存中的。</p><p>2、在yml中进行相关的配置。</p><p>配置redis所在服务器的IP地址，端口号</p><p>3、注入对象<code>RedisTemplate  redisTemplate</code></p><p><code>redisTemplate.opsForValue();</code>操作key value键值对</p><p>常用的是 </p><p>注入对象<code>StringRedisTemplate  stringRedisTemplate</code></p><p><code>stringRedisTemplate.opsForValue();</code></p><p>SpringBoot整合Redis客户端的选择：默认是lettuce</p><p><img src="/../../../image/springboot/35.png"></p><h1 id="四、日志"><a href="#四、日志" class="headerlink" title="四、日志"></a>四、日志</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span> <br><span class="hljs-attr">root:</span> <span class="hljs-string">info</span> <span class="hljs-comment">#输出info及以上的日志</span><br></code></pre></td></tr></table></figure><p>指定启动项目时输出的日志级别</p><p><strong>日志级别由低到高：debug -&gt; info -&gt; warn -&gt; error</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入<code>lombok</code>依赖，然后直接在项目中使用<code>@Slf4j</code>，使用的时候直接log.info(“…”)</p><p><img src="/../../../image/springboot/24.png"></p><p>自定义日志输出格式可以在yml文件中配置</p><p>日志也可以输出在指定文件中，在yml中配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">file:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">server.log</span><br>  <span class="hljs-attr">logback:</span><br>    <span class="hljs-attr">rollingpolicy:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">2KB</span> <span class="hljs-comment">#文件大小，超过后重新创建文件</span><br>      <span class="hljs-attr">file-name-pattern:</span> <span class="hljs-string">server.%d&#123;yyyy-MM-dd&#125;.%i.log</span> <span class="hljs-comment">#文件名,i是循环的数</span><br></code></pre></td></tr></table></figure><p><img src="/../../../image/springboot/25.png"></p><p>与模块是同级的。</p><h1 id="五、原理"><a href="#五、原理" class="headerlink" title="五、原理"></a>五、原理</h1><h2 id="1、bean的加载方式"><a href="#1、bean的加载方式" class="headerlink" title="1、bean的加载方式"></a>1、bean的加载方式</h2><h3 id="（1）xml方式"><a href="#（1）xml方式" class="headerlink" title="（1）xml方式"></a>（1）xml方式</h3><p>第一步：导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        spring的基础配置需要导入spring核心包，这里导入了一个大的--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步：创建实体类</p><p>第三步：创建spring配置文件</p><p><img src="/../../../image/springboot/36.png"></p><p>第四步：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.vickkkyz.Dog&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第五步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext1.xml&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;dog1&quot;</span>);<br>    System.out.println(dog1);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>也可以加载第三方bean</strong></p><h3 id="（2）注解方式"><a href="#（2）注解方式" class="headerlink" title="（2）注解方式"></a>（2）注解方式</h3><p>第一个方法是自定义bean</p><p>第一步：在实体类上加注解<code>@Component(&quot;dog1&quot;)</code></p><p>第二步：指定要加载的bean的位置 <code>&lt;context:component-scan base-package=&quot;com.vickkkyz&quot;/&gt;</code></p><p>组件扫描</p><p><img src="/../../../image/springboot/37.png"></p><p>基于注解的方式如何加载第三方bean？因为不能直接在第三方bean的源码上添加注解。</p><p>需要创建一个类，需要将这个类配置为Bean，里面的方法返回在方法体中创建的第三方bean，方法上加@Bean注解，这样第三方bean就可以被spring管理了。xml文件中需要加载这个类的路径，让它可以扫描到。</p><p><img src="/../../../image/springboot/38.png"></p><h3 id="（3）用注解方式声明配置类（配置类不再是xml）"><a href="#（3）用注解方式声明配置类（配置类不再是xml）" class="headerlink" title="（3）用注解方式声明配置类（配置类不再是xml）"></a>（3）用注解方式声明配置类（配置类不再是xml）</h3><p>这个类就相当于xml配置文件。</p><p><img src="/../../../image/springboot/39.png"></p><p><img src="/../../../image/springboot/40.png"></p><h3 id="（4）-Import注解"><a href="#（4）-Import注解" class="headerlink" title="（4）@Import注解"></a>（4）@Import注解</h3><p><img src="/../../../image/springboot/41.png"></p><p>这样被定义的<strong>bean的名称是类的全路径名称</strong></p><p>这个类定义的bean也会被加载到容器中</p><h3 id="（5）手工加载bean"><a href="#（5）手工加载bean" class="headerlink" title="（5）手工加载bean"></a>（5）手工加载bean</h3><p><img src="/../../../image/springboot/42.png"></p><p>注册bean的时候同名的被留下。最后的结果只有第三行那个tom  bean</p><hr><p><img src="/../../../image/springboot/43.png"></p><p><code>如何选择性加载bean</code></p><p><img src="/../../../image/springboot/44.png"></p><p>@ConditionalOnBean(name&#x3D;”jerry”)表示如果有这个bean加载，就加载cat类</p><p><img src="/../../../image/springboot/45.png"></p><h2 id="2、自动配置"><a href="#2、自动配置" class="headerlink" title="2、自动配置"></a>2、自动配置</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="3、SpringBoot启动核心原理"><a href="#3、SpringBoot启动核心原理" class="headerlink" title="3、SpringBoot启动核心原理"></a>3、SpringBoot启动核心原理</h2><p><a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=168&vd_source=c1b40fa5b4df055a1cae36a0ac4e1d21">https://www.bilibili.com/video/BV15b4y1a7yG?p=168&amp;vd_source=c1b40fa5b4df055a1cae36a0ac4e1d21</a></p><h1 id="六、补充"><a href="#六、补充" class="headerlink" title="六、补充"></a>六、补充</h1><h2 id="1、REST风格"><a href="#1、REST风格" class="headerlink" title="1、REST风格"></a>1、REST风格</h2><p>目的是隐藏资源的访问行为，无法通过地址得知对资源是何种操作。</p><p>用不同的请求方法来区分不同的controller</p><p><code>http://localhost:8080/users</code> POST请求</p><p><img src="/../../../image/springboot/5.png"></p><p><code>http://localhost:8080/users/1</code>  DELETE请求</p><p>使用@PathVariable注解可以获取路径中的内容，在<code>value=&quot;/users/&#123;id&#125;&quot;</code>来指定取出来的对应值给id</p><p><img src="/../../../image/springboot/6.png"></p><p><img src="/../../../image/springboot/7.png"></p><h2 id="2、-RestController"><a href="#2、-RestController" class="headerlink" title="2、@RestController"></a>2、@RestController</h2><p>类注解</p><p><code>@RestController = @Controller + @ResponseBody</code></p><p><code>@ResponseBody</code> <strong>表示该方法的返回结果直接写入HTTP response body 中</strong>，即将返回的java对象变成json。每个方法都要写，所以直接加载类上。</p><p><code>@Controller</code>表示<code>Controller</code>层类的bean配置，这样当容器启动时才可以将这个类放到容器中给spring管理。所以也是要写在类上。</p><p>因此就将二者合二为一了。</p><h2 id="3、-RequestMapping"><a href="#3、-RequestMapping" class="headerlink" title="3、@RequestMapping"></a>3、@RequestMapping</h2><p>标志方法的请求路径，在类上和方法上都可以写</p><p><code>@RequestMapping(&quot;/user&quot;,method=RequestMethod.GET)</code>等同于<code>@GetMapping(&quot;/user&quot;)</code></p><h2 id="4、项目打包，部署到服务器"><a href="#4、项目打包，部署到服务器" class="headerlink" title="4、项目打包，部署到服务器"></a>4、项目打包，部署到服务器</h2><p><img src="/../../../image/springboot/16.png"></p><p><img src="/../../../image/springboot/17.png"></p><p>在服务器的&#x2F;usr&#x2F;local目录下，创建一个目录app，将这个jar包放app目录下</p><p>要保证服务器jdk版本不低于打包时使用的jdk版本</p><p>启动项目：java -jar 项目名</p><p>后台启动：<code>nohup java -jar 项目名 &gt; server.log 2&gt;&amp;1 &amp;</code></p><p>后台启动如何关：ps -ef | grep “java-jar”</p><p>找到进程pid，<code>kill -9 进程pid</code></p><h2 id="5、两个级别的配置文件"><a href="#5、两个级别的配置文件" class="headerlink" title="5、两个级别的配置文件"></a>5、两个级别的配置文件</h2><p><img src="/../../../image/springboot/18.png"></p><p>第一个的优先级高于第二个</p><p>如果两个中配置了同样的属性，则第一个覆盖第二个。否则是叠加。第一个文件一般是项目打包到服务器时的配置，第二个是本地测试使用的，有时候配置可能不同</p><hr><p>工程目录的同级的yml文件的配置会覆盖开发的yml</p><p><img src="/../../../image/springboot/19.png"></p><p><img src="/image/springboot/20.png"></p><h2 id="6、开启bean数据校验"><a href="#6、开启bean数据校验" class="headerlink" title="6、开启bean数据校验"></a>6、开启bean数据校验</h2><p><img src="/../../../image/springboot/31.png"></p><p>要对哪个bean做校验，就在哪个bean上添加<code>@Validated</code>注解，在具体的字段上添加校验规则，当添加的属性值不满足这个规则时，就会报错。</p><p><img src="/../../../image/springboot/32.png"></p><h2 id="7、数据源"><a href="#7、数据源" class="headerlink" title="7、数据源"></a>7、数据源</h2><p>SpringBoot提供了3种内嵌的数据源对象供开发者选择</p><ul><li>HikariCP：默认内置数据源对象</li><li>Tomcat提供DataSource： HikariCP不可用的情况下，且在web环境中，将使用tomcat服务器配置的数据源对象。</li><li>Commons DBCP： Hikari不可用，tomcat数据源也不可用，将使用dbcp数据源</li></ul><p>比如</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">111111</span><br></code></pre></td></tr></table></figure><p>如果没有引入driud依赖，使用的就是默认的Hikari数据源。</p><h2 id="8、自定义拦截器"><a href="#8、自定义拦截器" class="headerlink" title="8、自定义拦截器"></a>8、自定义拦截器</h2><p>创建拦截器</p><p><img src="/../../../image/springboot/47.png"></p><p>注册拦截器</p><p><img src="/../../../image/springboot/46.png"></p>]]></content>
    
    
    <categories>
      
      <category>FrameWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>框架</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中间件-nginx</title>
    <link href="/2022/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"/>
    <url>/2022/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/</url>
    
    <content type="html"><![CDATA[<p>下面是nginx的基本使用。原理以后再学。未完待续。。。</p><h1 id="一、nginx环境搭建"><a href="#一、nginx环境搭建" class="headerlink" title="一、nginx环境搭建"></a>一、nginx环境搭建</h1><h2 id="1、nginx运行环境-虚拟机联网"><a href="#1、nginx运行环境-虚拟机联网" class="headerlink" title="1、nginx运行环境-虚拟机联网"></a>1、nginx运行环境-虚拟机联网</h2><p>创建虚拟机的步骤就不再说了。创建完成之后，如何使虚拟机联网。</p><p><img src="/../../image/nginx/1.png"></p><p><code>ip addr</code>查看虚拟机的网卡配置</p><p>lo即本地回环，ens33即虚拟出来的网卡，但是还没有IP地址。</p><ul><li>修改配置网卡配置文件</li></ul><p><code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>下图说明这个IP地址是采取dhcp协议分配的，将会被随机分配，并且每次联网IP地址都可能不同。</p><p><img src="/../../image/nginx/2.png"></p><ul><li>修改ONBOOT&#x3D;yes</li><li>重启网络服务</li></ul><p><code>systemctl restart network</code></p><p><img src="/../../image/nginx/3.png"></p><p>现在虚拟机就有IP地址了<code>192.168.4.129</code></p><p>现在使用xshell连接这台虚拟机</p><p><img src="/../../image/nginx/4.png"></p><h2 id="2、配置静态IP地址"><a href="#2、配置静态IP地址" class="headerlink" title="2、配置静态IP地址"></a>2、配置静态IP地址</h2><p>之前的网络配置是使用dhcp方式分配ip地址，这种方式会在系统每次联网的时候分配一个ip给我们用，也就是说有可能系统下次启动的时候ip会变，这样非常不方便我们管理。</p><p><img src="/../../image/nginx/5.png"></p><p><img src="/../../image/nginx/6.png"></p><p>DNS服务器配置的是阿里云的DNS解析服务器。</p><p>到现在，虚拟机就可以联网了。</p><h2 id="3、下载nginx"><a href="#3、下载nginx" class="headerlink" title="3、下载nginx"></a>3、下载nginx</h2><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p>官网下载tar.gz压缩包。选择<code>Mainline version</code>版本的中间那个。使用FTP工具将文件上传到虚拟机中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf  nginx-1.21.6.tar.gz <span class="hljs-comment">#解压到当前目录</span><br><span class="hljs-built_in">cd</span> nginx-1.21.6 <span class="hljs-comment">#进入解压后的文件夹</span><br><span class="hljs-comment">#安装下载前的依赖</span><br><br><span class="hljs-comment">#安装C编译器</span><br>yum install -y gcc<br><span class="hljs-comment">#安装pcre库</span><br>yum install -y pcre pcre-devel<br><span class="hljs-comment">#安装zlib</span><br>yum install -y zlib zlib-devel<br><br><span class="hljs-comment">#开始安装</span><br>./configure --prefix=/usr/local/nginx <span class="hljs-comment">#使用prefix选项指定安装的目录</span><br>make<br>make install<br><br><span class="hljs-comment">#启动</span><br><span class="hljs-built_in">cd</span> /usr/local/nginx/sbin<br><span class="hljs-built_in">ls</span> <span class="hljs-comment"># 里面是一个nginx的可执行文件</span><br>./nginx <span class="hljs-comment"># 启动这个可执行</span><br></code></pre></td></tr></table></figure><p>nginx其他命令（在sbin目录下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx -s stop #快速停止<br>./nginx -s quit #完成已接受的请求后，停止<br>./nginx -s reload #重新加载配置<br>./nginx -t #检查nginx配置是否正确<br></code></pre></td></tr></table></figure><p>配置nginx服务器开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看nginx状态</span><br>ps -ef|grep nginx<br><span class="hljs-meta prompt_">#</span><span class="language-bash">快速停止</span><br>./nginx -s stop <br>systemctl start nginx<br>systemctl status nginx<br></code></pre></td></tr></table></figure><p><strong>注册系统服务</strong></p><p>通过系统服务的方式启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi usr/lib/systemd/system/nginx.service<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit] <br>Description=nginx<br>After=network.target remote-fs.target nss-lookup.target<br><br>[Service]<br>Type=forking<br>PIDFile=/usr/local/nginx/logs/nginx.pid<br>ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf<br>ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br>ExecReload=/usr/local/nginx/sbin/nginx -s reload<br>ExecStop=/usr/local/nginx/sbin/nginx -s stop<br>ExecQuit=/usr/local/nginx/sbin/nginx -s quit <br>PrivateTmp=true<br>   <br>[Install]   <br>WantedBy=multi-user.target  # 多用户<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable nginx.service #启动<br></code></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld<br></code></pre></td></tr></table></figure><h1 id="二、nginx目录结构"><a href="#二、nginx目录结构" class="headerlink" title="二、nginx目录结构"></a>二、nginx目录结构</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">conf #配置文件<br>｜-nginx.conf # 主配置文件<br>｜-其他配置文件，会被引入到了nginx.conf<br>html #静态页面<br>logs<br>｜-access.log #访问日志(每次访问都会记录)<br>｜-error.log #错误日志<br>｜-nginx.pid #进程号<br>sbin<br>｜-nginx #主进程文件<br>*_temp #运行时，生成临时文件<br></code></pre></td></tr></table></figure><h2 id="1、nginx-conf"><a href="#1、nginx-conf" class="headerlink" title="1、nginx.conf"></a>1、nginx.conf</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">worker_processes  1; # 启动的worker进程数，一般与主机的CPU个数相同<br><br>events &#123;<br>    worker_connections  1024; #每个worker进程的最大连接数<br>&#125;<br><br><br>http &#123;<br>    include       mime.types;#include是引入关键字，可以引入相同目录下的文件，mime.types是用来定义，请求返回的content-type）<br>    default_type  application/octet-stream;#mime.types未定义的，使用默认格式application/octet-stream<br><br>    sendfile        on;<br><br>    keepalive_timeout  65; #长链接超时时间<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">多个域名被解析到同一个服务器上，用nginx来分配显示的首页，servername就是不同的域名</span><br>    server &#123;<br>        listen       80;  #监听端口80<br>        server_name  localhost; #接收的域名<br><br>        location / &#123;<br>            root   html;  #根目录指向html目录<br>            index  index.html index.htm; #http://域名/index 指向 index.html index.htm文件<br>        &#125;<br><br>        error_page   500 502 503 504  /50x.html;# 服务器错误码为500 502 503 504，转到&quot;域名/50x.html&quot;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br>        <br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改完配置文件后，需要重启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl reload nginx<br></code></pre></td></tr></table></figure><h3 id="1、server-name匹配规则"><a href="#1、server-name匹配规则" class="headerlink" title="1、server_name匹配规则"></a>1、server_name匹配规则</h3><p>可以在同一个server_name中配置多个域名。中间用空格隔开。</p><p>匹配方式：</p><ul><li>完整匹配。<code>server_name  haha.cn  huhu.cn;</code></li><li>通配符匹配。<code>server_name  *.haha.cn;</code> 说明sdaidj.haha.cn都会配匹配到这个域名。精确匹配的优先级大于通配符匹配和正则匹配。</li><li>通配符结束匹配。<code>server_name  www.xzj520520.*;</code></li><li>正则匹配。即域名可以写成正则表达式。正则匹配格式，必须以<code>~</code>开头，比如：<code>server_name ~^www\d+\.example\.net$;</code>。如果开头没有<code>~</code>，则nginx认为是精确匹配。</li><li>特殊匹配。<code>server_name &quot;&quot;;</code> 匹配Host请求头不存在的情况。</li></ul><h1 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h1><h2 id="1、配置内网域名"><a href="#1、配置内网域名" class="headerlink" title="1、配置内网域名"></a>1、配置内网域名</h2><p>配置内网域名，暂时先不配置公网域名。</p><p>本机要想能解析这个域名，需要在<code>C:\Windows\System32\drivers\etc</code>中的hosts文件中添加域名的对应信息，其实这个文件也相当于本机的DNS服务器的功能，本地去解析这个域名时首先会看hosts文件中有没有对应IP地址，如果没有，才会继续往上层的DNS服务器去查询。</p><p><code>192.168.4.101 vickkkyz.com</code></p><p>这样访问<code>vickkkyz.com</code>就可以指定到这个IP地址了，然后nginx会将其转到index.html</p><p>注意：这个域名只有在这个主机上才可以转成这个IP地址，换一个主机就不可以了。</p><h2 id="2、配置虚拟主机"><a href="#2、配置虚拟主机" class="headerlink" title="2、配置虚拟主机"></a>2、配置虚拟主机</h2><p>可以配置不同域名，同一个IP地址。也可以配置不同端口号。</p><p><strong>配置不同域名</strong>：</p><p>现在给<code>192.168.4.101</code>配置两个域名。</p><p><code>192.168.4.101 abc.vickkkyz.com</code><br><code>192.168.4.101 def.vickkkyz.com</code></p><p><img src="/../../image/nginx/8.png"></p><p><img src="/../../image/nginx/7.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>        listen       80;<br>        server_name  abc.vickkkyz.com;<br><br>        location / &#123;<br>            root   /www/test01;<br>            index  index.html index.htm;<br>        &#125;<br><br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br>    &#125;<br><br>   server &#123;<br>        listen       80;<br>        server_name  def.vickkkyz.com;<br><br>        location / &#123;<br>            root   /www/test02;<br>            index  index.html index.htm;<br>        &#125;<br><br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../image/nginx/9.png"></p><p><img src="/../../image/nginx/10.png"></p><p>同理，也可以根据访问不通过端口号，来显示不同的资源。</p><p>我发现如果现在还有一个域名对应这个IP地址，但是现在nginx.conf文件中server没有配置，那么会直接匹配第一个server中配置的页面。</p><h2 id="3、反向代理"><a href="#3、反向代理" class="headerlink" title="3、反向代理"></a>3、反向代理</h2><p><img src="/../../image/nginx/11.png"></p><p>代理：nginx帮用户把请求传到指定的业务服务器上，比如Tomcat服务器，即代理用户发送用户的请求。</p><p>反向代理：即用户不能直接访问到tomcat服务器，所以作为服务器方，提供了nginx供用户来访问，就类似于提供一个访问接口。因为是服务器端提供的，所以是反向代理。</p><p>有性能瓶颈，因为所有的数据都经过Nginx，所以Nginx服务器的性能至关重要。</p><p>nginx将请求转发给指定服务器，服务器返回的数据再返回给nginx，由nginx返回给用户。或者是服务器直接返回给用户。</p><p><img src="/../../image/nginx/13.png"></p><p>需要在配置文件中加一个<code>proxy_pass</code>字段，后面的值是你要让nginx代理的地址（具体的网址），可以写多个。一旦加上这个字段，location中的root和index就失效了。</p><p>下面是ngin01的nginx.conf的部分配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>        listen       80;<br>        server_name  abc.vickkkyz.com;<br><br>        location / &#123;<br>        #代理到 http://192.168.4.102，不支持https<br>            proxy_pass http://192.168.4.102;<br>            root   /www/test01;<br>            index  index.html index.htm;<br>        &#125;<br><br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h2><p>把请求，按照一定算法规则，分配给多台业务服务器（即使其中一个坏了&#x2F;维护升级，还有其他服务器可以继续提供服务）</p><p><img src="/../../image/nginx/12.png"></p><p>负载均衡的算法：</p><ul><li>轮询。请求到来后按顺序选择服务器。如果选中的服务器故障，会启动retry机制，尝试分配给下一个服务器。</li><li>配置权重。</li></ul><h2 id="5、反向代理-负载均衡"><a href="#5、反向代理-负载均衡" class="headerlink" title="5、反向代理+负载均衡"></a>5、反向代理+负载均衡</h2><p>同一个域名的反向代理，配置多组服务器域名。**需要定义地址别名 **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream httpds&#123;<br>      server 192.168.4.102:80; #如果是80端口，可以省略不写<br>      server 192.168.4.103:80;<br>   &#125;<br><br>    server &#123;<br>        listen       80;<br>        server_name  abc.vickkkyz.com;<br><br><br>        location / &#123;<br>            proxy_pass http://httpds;<br>            root   /www/test01;<br>            index  index.html index.htm;<br>        &#125;<br><br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>weight配置服务器的不同权重。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream httpds&#123;<br>     server 192.168.4.102:80 weight=6; #如果是80端口，可以省略不写<br>     server 192.168.4.103:80 weight=2;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>down让某些服务器不参与负载均衡。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream httpds&#123;<br>     server 192.168.4.102:80 weight=6 down; <br>     server 192.168.4.103:80 weight=2;<br>  &#125;<br></code></pre></td></tr></table></figure><p>backup配置配用服务器，正常情况不会负载到这个服务器，当没有服务器可以负载时，才会使用这个备用服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream httpds&#123;<br>     server 192.168.4.102:80 weight=6 backup; <br>     server 192.168.4.103:80 weight=2;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="6、动静分离"><a href="#6、动静分离" class="headerlink" title="6、动静分离"></a>6、动静分离</h2><p>原来，当用户请求时，请求通过nginx转发到某个tomcat服务器，然后tomcat服务器将响应资源返回给nginx，nginx再返回给用户，而对于静态资源，比如图片，js，css，如果需要经常访问，那每次都需要tomcat返回，这样比较影响性能。考虑将静态资源放到nginx中，这样静态资源就不用经过那么多链路了。</p><p>即当用户请求时，动态请求分配到Tomcat业务服务器，静态资源请求放在Nginx服务器中。</p><p>也就是让nginx可以找到这些静态文件。</p><ul><li>如果请求的资源地址是<code>location/css/*</code>，就会被匹配到nginx的html目录下的css文件夹中（我们把css静态资源放在这个位置）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>        listen       80;<br>        server_name  localhost;<br><br>location / &#123; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">/的优先级比较低，如果下面的location没匹配到，就会走http://xxx这个地址的机器</span><br>        proxy_pass http://xxx;<br>        &#125;<br>        <br>        location /css &#123; <br>       # root指的是html，location/css指的是root下的css，所以地址就是html/css<br>       # root目录是：/usr/local/nginx<br>        root html;<br>            index  index.html index.htm;<br>        &#125;<br><br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用正则可以同时配置多个静态资源目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">location ~*/(js|css|img)&#123;<br>root html;<br>  index  index.html index.htm;<br>&#125;<br></code></pre></td></tr></table></figure><p>URL重写，使用正则，就是动态匹配url再重定向。</p><p>假设当前主机的IP地址为<code>192.168.4.101</code>，如果现在访问<code>http://192.168.4.101/2.html</code>则会被重定向到<code>http://192.168.4.101//index.jsp?pageNum=$1</code>目的是隐藏uri中的重要信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>        listen       80;<br>        server_name  localhost;#localhost表示请求的域名是这个或请求的IP地址的域名是这个<br><br>location / &#123; <br>rewrite ^/([0-9]+).html$ /index.jsp?pageNum=$1  break;<br>        proxy_pass http://xxx;<br>        &#125;<br>      <br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">rewrite    &lt;regex&gt;   &lt;replacement&gt;  [flag];<br>关键字正则替代内容     flagt标记<br><br>正则：per1森容正则表达式语句进行规则匹配<br>替代内容：将正则匹配的内容替换成replacement<br><br>flag标记说明：<br>last  #本条规则匹配完成后，继续向下匹配新的1ocation URI规则<br>break #本条规则匹配完成即终止，不再匹配后面的任何规则<br><br>redirect #返回302临重定向，游览器地址会显示跳转后的URL地址<br>permanent #返回301永久重定向，测览器地址栏会显示跳转后的URL地址<br></code></pre></td></tr></table></figure><h2 id="7、nginx充当网关服务器"><a href="#7、nginx充当网关服务器" class="headerlink" title="7、nginx充当网关服务器"></a>7、nginx充当网关服务器</h2><p>当业务中要求tomcat服务器不能被外网访问，用户想要访问其中的资源必须先通过nginx服务器，然后再由nginx服务器将请求转发给tomcat，这时候nginx的作用是反向代理，如果有多个tomcat，nginx还有负载均衡的作用。然后因为tomcat外网不能访问，但是需要被nginx访问，所以需要配置防火墙规则。</p><p>启动应用服务器的防火墙，设置其只能接受这台Nginx服务器的请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.174.135&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; accept&quot; #这里的192.168.174.135是网关 服务器地址<br></code></pre></td></tr></table></figure><p>这是移除这个规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.174.135&quot; port port=&quot;8080&quot; protocol=&quot;tcp&quot; accept&quot;<br></code></pre></td></tr></table></figure><p>移除和添加规则都要重启才能生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --reload<br></code></pre></td></tr></table></figure><p><strong>查看所有规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --list-all #所有开启的规则<br></code></pre></td></tr></table></figure><h2 id="8、防盗链"><a href="#8、防盗链" class="headerlink" title="8、防盗链"></a>8、防盗链</h2><p>参考：<a href="https://heyingjiee.github.io/otherLanguage/Nginx%E5%AD%A6%E4%B9%A0.html#%E9%98%B2%E7%9B%97%E9%93%BE">https://heyingjiee.github.io/otherLanguage/Nginx%E5%AD%A6%E4%B9%A0.html#%E9%98%B2%E7%9B%97%E9%93%BE</a></p><h2 id="9、高可用场景"><a href="#9、高可用场景" class="headerlink" title="9、高可用场景"></a>9、高可用场景</h2><h2 id="10、配置证书"><a href="#10、配置证书" class="headerlink" title="10、配置证书"></a>10、配置证书</h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>nginx</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具- maven</title>
    <link href="/2022/09/10/Java/framework/maven/"/>
    <url>/2022/09/10/Java/framework/maven/</url>
    
    <content type="html"><![CDATA[<h1 id="1、maven的作用"><a href="#1、maven的作用" class="headerlink" title="1、maven的作用"></a>1、maven的作用</h1><ol><li>管理庞大的jar包</li><li>在脱离IDE集成开发工具的环境下对项目进行构建。</li></ol><h1 id="2、maven是什么"><a href="#2、maven是什么" class="headerlink" title="2、maven是什么"></a>2、maven是什么</h1><p>maven是阿帕奇软件基金组织维护的一款专门为java项目提供<strong>构建</strong>和<strong>依赖管理</strong>支持的工具。</p><h2 id="2-1、构建"><a href="#2-1、构建" class="headerlink" title="2.1、构建"></a>2.1、构建</h2><p>构建过程包含的主要的环节：</p><ul><li>清理：删除上一次构建的结果，为下一次构建做好准备</li><li>编译：Java 源程序编译成 *.class 字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库</li><li>部署<ul><li>部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上</li><li>部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</li></ul></li></ul><h2 id="2-2、依赖"><a href="#2-2、依赖" class="headerlink" title="2.2、依赖"></a>2.2、依赖</h2><p>如果 A 工程里面用到了 B 工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。</p><p>依赖管理中要解决的具体问题：</p><ul><li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li><li>jar 包之间的依赖：通过依赖的传递性自动完成</li><li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul><p><img src="/../../../image/maven/8.png"></p><h1 id="3、根据坐标创建maven工程-java工程"><a href="#3、根据坐标创建maven工程-java工程" class="headerlink" title="3、根据坐标创建maven工程(java工程)"></a>3、根据坐标创建maven工程(java工程)</h1><h2 id="3-1、maven中的坐标"><a href="#3-1、maven中的坐标" class="headerlink" title="3.1、maven中的坐标"></a>3.1、maven中的坐标</h2><p><strong>使用三个向量在maven仓库中唯一定位到一个jar包。</strong></p><ol><li>groupId：公司或组织的id，即公司或组织的域名的倒序，通常也会加上项目名称</li><li>artifactId：一个项目或者是项目中的一个模块的id</li><li>version：模块的版本号。SNAPSHOT表示快照版本，正在迭代的过程中，是不稳定的版本。RELEASE表示正式版本。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面坐标对应的 jar 包在 Maven 本地仓库中的位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar<br></code></pre></td></tr></table></figure><p>Maven本地仓库根目录是在settings.xml文件中配置的。我这里是<code>D:\Java\maven\MavenRepository</code></p><p>jar包的文件名是以<code>artifactId-版本号</code>来命名的。</p><h2 id="3-2、POM文件中标签详解"><a href="#3-2、POM文件中标签详解" class="headerlink" title="3.2、POM文件中标签详解"></a>3.2、POM文件中标签详解</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--modelVersion:从maven2.0开始就固定是4.0.0，表示当前pom。xml采用的标签结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <br><span class="hljs-comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro01-maven-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span><br>  <span class="hljs-comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span><br>  <span class="hljs-comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>pro01-maven-java<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.apache.org<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- properties标签：在Maven中定义属性值--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <br><span class="hljs-comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p><h3 id="scope"><a href="#scope" class="headerlink" title="&lt; scope&gt;"></a>&lt; scope&gt;</h3><p>表示依赖范围。标签的可选值：<strong>compile</strong>&#x2F;<strong>test</strong>&#x2F;<strong>provided</strong>&#x2F;system&#x2F;runtime&#x2F;<strong>import</strong></p><p>compile：默认就是它。通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</p><p><img src="/../../../image/maven/10.png"></p><h2 id="3-3、maven约定的目录结构"><a href="#3-3、maven约定的目录结构" class="headerlink" title="3.3、maven约定的目录结构"></a>3.3、maven约定的目录结构</h2><p>这个结构在超级POM文件中已经配置，我们自己的maven项目中的pom是子pom，。就不需要再配置了。</p><p><img src="/../../../image/maven/1.png"></p><h2 id="3-4、执行maven的构建命令（命令行）"><a href="#3-4、执行maven的构建命令（命令行）" class="headerlink" title="3.4、执行maven的构建命令（命令行）"></a>3.4、执行maven的构建命令（命令行）</h2><p>mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。</p><ol><li><p>清理操作</p><p><code>mvn clean</code>，删除target目录</p></li><li><p>编译操作</p><p><code>mvn compile</code> 主程序编译</p><p>测试程序编译：<code>mvn test-compile</code></p><p>主体程序编译结果存放的目录：<code>target/classes</code></p><p>测试程序编译结果存放的目录：<code>target/test-classes</code></p></li><li><p>测试操作</p><p><code>mvn test</code> 构建test目录下的代码</p><p>测试的报告(错误信息，成功信息)存放的目录：<code>target/surefire-reports</code></p></li><li><p>打包操作</p><p><code>mvn package</code></p><p>打包的结果——jar 包(java工程)，存放的目录：target，jar包名字是artifitId-version.jar</p></li><li><p>安装操作</p><p><code>mvn install</code></p><p>安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。</p><p>另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p></li></ol><h1 id="4、创建Maven版的web工程"><a href="#4、创建Maven版的web工程" class="headerlink" title="4、创建Maven版的web工程"></a>4、创建Maven版的web工程</h1><p>首先创建一个maven项目。</p><p><img src="/../../../image/maven/9.png"></p><p><img src="/../../../image/maven/2.png"></p><p><img src="/../../../image/maven/3.png"></p><p><img src="/../../../image/maven/13.png"></p><p><img src="/../../../image/maven/4.png"></p><p>main目录下缺少java、resources，src目录下缺少test目录，test目录下缺少java目录，添加上去</p><p><img src="/../../../image/maven/5.png"></p><p><img src="/../../../image/maven/6.png"></p><p><img src="/../../../image/maven/7.png"></p><p>生成的pom.xml文件，多了一个build标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.vickkkyz<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ssm_in<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ssm_in Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- junit测试 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>ssm_in<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果使用Servlet类，需要自己去导入servlet-api依赖。因为以前是配置了tomcat，那里面有这个api，但是现在没有配置tomcat，就需要导入这个依赖。然后将项目编译过之后，将target目录中的项目文件夹放到tomcat中，启动tomcat，就可以在浏览器直接访问链接了。</p><h1 id="5、依赖的传递性"><a href="#5、依赖的传递性" class="headerlink" title="5、依赖的传递性"></a>5、依赖的传递性</h1><p><strong>①概念</strong></p><p>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</p><p><strong>②传递的原则</strong></p><p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p><ul><li>B 依赖 C 时使用 compile 范围：可以传递</li><li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以</li></ul><h1 id="6、依赖排除"><a href="#6、依赖排除" class="headerlink" title="6、依赖排除"></a>6、依赖排除</h1><p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。</p><p><img src="/../../../image/maven/11.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro01-maven-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在A工程中依赖的B工程中排除X-1.0.jar</p><h1 id="7、继承"><a href="#7、继承" class="headerlink" title="7、继承"></a>7、继承</h1><p>Maven工程之间，A 工程继承 B 工程</p><ul><li>B 工程：父工程</li><li>A 工程：子工程</li></ul><p>本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置</p><p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p><ul><li><p>一个 大型 project 下面，创建了很多个 module。</p></li><li><p>每一个 module 都需要配置自己的依赖信息。</p></li><li><p><strong>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一</strong>。</p></li></ul><p>通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力。</p><h2 id="①创建父工程"><a href="#①创建父工程" class="headerlink" title="①创建父工程"></a>①创建父工程</h2><p>创建的过程和前面创建 普通maven项目 一样。</p><p>工程名称：pro03-maven-parent</p><p>工程创建好之后，要修改它的打包方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro03-maven-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br> <span class="hljs-comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</p><h2 id="②创建模块工程"><a href="#②创建模块工程" class="headerlink" title="②创建模块工程"></a>②创建模块工程</h2><p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入 pro03-maven-parent 工程的根目录</strong>，然后创建模块工程。</p><p>假设，我们创建三个模块工程：(就是在这个项目里创建三个模块)</p><p><img src="/../../../image/maven/12.png"></p><h2 id="③查看被添加新内容的父工程-pom-xml"><a href="#③查看被添加新内容的父工程-pom-xml" class="headerlink" title="③查看被添加新内容的父工程 pom.xml"></a>③查看被添加新内容的父工程 pom.xml</h2><p>下面 modules 和 module 标签是聚合功能的配置，在父工程的pom.xml文件中自动生成的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>pro04-maven-module<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>pro05-maven-module<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>pro06-maven-module<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="④解读子工程的pom-xml"><a href="#④解读子工程的pom-xml" class="headerlink" title="④解读子工程的pom.xml"></a>④解读子工程的pom.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用parent标签指定当前工程的父工程，这是自动生成的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 通过指定父工程的坐标找到父工程 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro03-maven-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子工程的坐标 --&gt;</span><br><span class="hljs-comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro04-maven-module<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span><br></code></pre></td></tr></table></figure><h2 id="⑤在父工程中配置依赖的统一管理"><a href="#⑤在父工程中配置依赖的统一管理" class="headerlink" title="⑤在父工程中配置依赖的统一管理"></a>⑤在父工程中配置依赖的统一管理</h2><p>即使在父工程中配置了对依赖的管理，子工程需要使用具体的依赖的话还是需要配置相关的依赖，只是不需要指定版本号了。父工程的作用就是统一版本号。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span><br><span class="hljs-comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="⑥在父工程中声明自定义属性"><a href="#⑥在父工程中声明自定义属性" class="headerlink" title="⑥在父工程中声明自定义属性"></a>⑥在父工程中声明自定义属性</h2><p>在父工程中，自定义标签名字。自定义标签子工程中也可以写。</p><p>标签名就是属性名，标签值就是属性值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">atguigu.spring.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在需要的地方使用${}的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>每个模块之间也可以进行依赖。但是注意不要产生循环依赖。即A模块依赖B模块，B模块也依赖A模块。</p><blockquote><p>如何将项目推送远程库</p><p><a href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro008-Git/lecture/chapter05/verse03.html">http://heavy_code_industry.gitee.io/code_heavy_industry/pro008-Git/lecture/chapter05/verse03.html</a></p></blockquote><h1 id="8、maven的生命周期"><a href="#8、maven的生命周期" class="headerlink" title="8、maven的生命周期"></a>8、maven的生命周期</h1><p>为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p><p><img src="/../../../image/maven/14.png"></p><p>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。</p><h1 id="9、maven中的插件"><a href="#9、maven中的插件" class="headerlink" title="9、maven中的插件"></a>9、maven中的插件</h1><p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p><p>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p><p>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p><h1 id="10、maven的仓库"><a href="#10、maven的仓库" class="headerlink" title="10、maven的仓库"></a>10、maven的仓库</h1><ul><li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li><li>远程仓库：需要联网<ul><li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li><li>Internet<ul><li>中央仓库</li><li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li></ul></li></ul></li></ul><p>建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。</p><h1 id="11、maven配置文件resources"><a href="#11、maven配置文件resources" class="headerlink" title="11、maven配置文件resources"></a>11、maven配置文件resources</h1><p>一般数据库连接信息等等配置需要放在 Maven 约定目录结构中的 resources 目录，这个目录存放各种配置文件。</p><h1 id="12、超级POM"><a href="#12、超级POM" class="headerlink" title="12、超级POM"></a>12、超级POM</h1><p>经过我们前面的学习，我们看到 Maven 在构建过程中有很多默认的设定。例如：源文件存放的目录、测试源文件存放的目录、构建输出的目录……等等。但是其实这些要素也都是被 Maven 定义过的。定义的位置就是：<strong>超级 POM</strong>。</p><p><img src="/../../../image/maven/16.png"></p><p>有效 POM 英文翻译为 effective POM，它的概念是这样的——在 POM 的继承关系中，子 POM 可以覆盖父 POM 中的配置；如果子 POM 没有覆盖，那么父 POM 中的配置将会被继承。按照这个规则，继承关系中的所有 POM 叠加到一起，就得到了一个最终生效的 POM。显然 Maven 实际运行过程中，执行构建操作就是按照这个最终生效的 POM 来运行的。这个最终生效的 POM 就是<strong>有效 POM</strong>，英文叫<strong>effective POM</strong>。</p><p>综上所述，平时我们使用和配置的 POM 其实大致是由四个层次组成的：</p><ul><li>超级 POM：所有 POM 默认继承，只是有直接和间接之分。</li><li>父 POM：这一层可能没有，可能有一层，也可能有很多层。</li><li>当前 pom.xml 配置的 POM：我们最多关注和最多使用的一层。</li><li>有效 POM：隐含的一层，但是实际上真正生效的一层。</li></ul><h1 id="14、build标签"><a href="#14、build标签" class="headerlink" title="14、build标签"></a>14、build标签</h1><p>在实际使用 Maven 的过程中，我们会发现 build 标签有时候有，有时候没，这是怎么回事呢？其实通过有效 POM 我们能够看到，build 标签的相关配置其实一直都在，只是在我们需要定制构建过程的时候才会通过配置 build 标签覆盖默认值或补充配置。这一点我们可以通过打印有效 POM 来看到。</p><p>所以<strong>本质</strong>上来说：我们配置的 build 标签都是对<strong>超级 POM 配置</strong>的<strong>叠加</strong>。那我们又为什么要在默认配置的基础上叠加呢？很简单，在默认配置无法满足需求的时候<strong>定制构建过程</strong>，需要我们在build标签中定制，这样在项目打包到服务器时就可以启动。</p><p>这里是对build标签的总结和应用：</p><p><a href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro002-maven/chapter09/verse04.html">http://heavy_code_industry.gitee.io/code_heavy_industry/pro002-maven/chapter09/verse04.html</a></p><blockquote><p>本文参考：<a href="https://www.bilibili.com/video/BV12q4y147e4?p=149&vd_source=c1b40fa5b4df055a1cae36a0ac4e1d21">https://www.bilibili.com/video/BV12q4y147e4?p=149&amp;vd_source=c1b40fa5b4df055a1cae36a0ac4e1d21</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>FrameWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架-mybatis</title>
    <link href="/2022/09/10/Java/framework/mybatis/"/>
    <url>/2022/09/10/Java/framework/mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mybatis概念"><a href="#一、Mybatis概念" class="headerlink" title="一、Mybatis概念"></a>一、Mybatis概念</h1><p>1&gt;MyBatis 是支持定制化 SQL(需要自己写sql语句)、存储过程以及高级映射的优秀的持久层框架</p><p>2&gt;MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</p><p>3&gt;MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</p><p>4&gt;MyBatis 是一个半自动的ORM（Object Relation Mapping）框架</p><h1 id="二、搭建mybatis"><a href="#二、搭建mybatis" class="headerlink" title="二、搭建mybatis"></a>二、搭建mybatis</h1><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;packaging&gt;jar&lt;/packaging&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>    &lt;!-- Mybatis核心 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">3.5</span><span class="hljs-number">.9</span>&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;!-- junit测试 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;junit&lt;/groupId&gt;<br>        &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">4.12</span>&lt;/version&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    &lt;!-- MySQL驱动 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;mysql&lt;/groupId&gt;<br>        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">8.0</span><span class="hljs-number">.27</span>&lt;/version&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure><h2 id="创建MyBatis核心配置文件"><a href="#创建MyBatis核心配置文件" class="headerlink" title="创建MyBatis核心配置文件"></a>创建MyBatis核心配置文件</h2><p>习惯上命名为<code>mybatis-config.xml</code>，存放的位置是src&#x2F;main&#x2F;resources目录下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置连接数据库的环境--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入映射文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="创建Mapper接口"><a href="#创建Mapper接口" class="headerlink" title="创建Mapper接口"></a>创建Mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。区别在于mapper仅仅是接口，我们不需要提供实现类</p><p><strong>命名规则：表所对应的实体类的类名+Mapper.xml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建MyBatis映射文件"><a href="#创建MyBatis映射文件" class="headerlink" title="创建MyBatis映射文件"></a>创建MyBatis映射文件</h2><ul><li>相关概念：ORM（Object Relationship Mapping）对象关系映射。<ul><li>对象：Java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul></li></ul><p><strong>映射文件的命名规则：表所对应的实体类的类名+Mapper.xml，存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</strong></p><p>这个例子的名字就是<code>UserMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;mybatis.vickkkyz.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        insert into t_user values(1,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!--    如果是查询，返回值是User，需要写resultType--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectID&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;mybatis.vickkkyz.pojo.User&quot;</span>&gt;</span><br>        select * from t_test;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt; mapper namespace=&quot;mybatis.vickkkyz.mapper.UserMapper&quot; &gt;</code>namespace的路径规则是对应Mapper接口的全类名</p><ul><li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml</li><li>因此一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li></ul><h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser();<br>        System.out.println(<span class="hljs-string">&quot;result:&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">log4j</span>:configuration <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;log4j.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">log4j:configuration</span> <span class="hljs-attr">xmlns:log4j</span>=<span class="hljs-string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Encoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConversionPattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.ibatis&quot;</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">log4j:configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="三、核心配置文件详解"><a href="#三、核心配置文件详解" class="headerlink" title="三、核心配置文件详解"></a>三、核心配置文件详解</h1><blockquote><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：<br><strong>顺序为：</strong>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p></blockquote><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>jdbc.properties文件如何创建？</p><p>new -&gt; Resource Bundle 创建出来的文件后缀默认就是properties。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/Mybatis</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> <br>    <span class="hljs-comment">&lt;!--开启延迟加载--&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--如果没有alias设置别名的话，默认别名就是类名，别名不区分大小写--&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.jianjian.pojo.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAlias</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--自定义别名--&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.jianjian.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAlias</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名。且不区分大小写--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.jianjian.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;org.mybatis.example.ExamplePlugin&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入单个映射文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--引入包下所有映射文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.jianjian.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入包下所有映射文件：</p><ul><li>条件1：此方式必须保证mapper接口和mapper映射文件必须在相同的包名下</li><li>条件2：mapper接口要和mapper映射文件的名字一致</li></ul><p>在recources目录下创建包的方法：<code>new -&gt; Directory -&gt; com/atguigu/mybatis/xml</code>这样的话就是一层一层的目录</p><h2 id="plugins-1"><a href="#plugins-1" class="headerlink" title="plugins"></a>plugins</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置分页拦截器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;org.mybatis.example.ExamplePlugin&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="四、Mybatis获取参数的两种方式-和"><a href="#四、Mybatis获取参数的两种方式-和" class="headerlink" title="四、Mybatis获取参数的两种方式${}和#{}"></a>四、Mybatis获取参数的两种方式${}和#{}</h1><ul><li><code>$&#123;&#125;的本质就是字符串拼接</code><ul><li><code>$&#123;&#125;</code>使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，<strong>需要手动添加单引号</strong></li></ul></li><li><code>#&#123;&#125;的本质就是占位符赋值</code><ul><li><code>#&#123;&#125;</code>使用占位符赋值的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，<strong>可以自动添加单引号</strong>，不需要自己添加</li></ul></li></ul><h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByUsername(String username);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>    select * from t_user where username = #&#123;username&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByUsername(String username);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>    select * from t_user where username = &#x27;$&#123;username&#125;&#x27; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p><ul><li>以arg0,arg1…为键，以参数为值，或者以param1,param2…为键，以参数为值；</li><li>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLogin(String username,String password);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>    select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLogin(String username,String password);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>    select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><p>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合</p><p><code>map的规则是以键为字段名，以值为字段值</code></p><p>将这些数据放在map中只需要通过<code>$&#123;&#125;</code>和<code>#&#123;&#125;</code>访问map集合的键就可以获取相对应的值，注意<code>$&#123;&#125;</code>需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLoginByMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLoginByMap</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession(); <br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class); <br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <br>    map.put(<span class="hljs-string">&quot;usermane&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>); <br>    map.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>); <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.checkLoginByMap(map); <br>    System.out.println(user); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><p>若mapper接口中的方法参数为实体类对象时此时可以使用<code>$&#123;&#125;</code>和<code>#&#123;&#125;</code>，通过<strong>访问实体类对象中的属性名</strong>获取属性值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertUser(User user);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span> <br>    insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession(); <br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class); <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>); <br>    userMapper.insertUser(user); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><p>可以通过@Param注解标识mapper接口中的方法参数，此时会将这些参数放在map集合中</p><ul><li>以@Param注解的value属性值为键，以参数为值；在xml文件中就直接使用param注解的值来取就可以得到这个参数传进来的值了</li><li>以param1,param2…为键，以参数为值；</li></ul><p>只需要通过<code>$&#123;&#125;</code>和<code>#&#123;&#125;</code>访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User CheckLoginByParam(@Param(&quot;username1&quot;) String username, @Param(&quot;password2&quot;) String password);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;CheckLoginByParam&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>    select * from t_user where username = #&#123;username_a&#125; and password = #&#123;password_b&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;CheckLoginByParam&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>    select * from t_user where username = #&#123;param1&#125; and password = #&#123;param2&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLoginByParam</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession(); <br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>    mapper.CheckLoginByParam(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、特殊SQL的执行"><a href="#五、特殊SQL的执行" class="headerlink" title="五、特殊SQL的执行"></a>五、特殊SQL的执行</h1><p>这些SQL语句只能使用<code>$&#123;&#125;</code>  而不是 <code>#&#123;&#125;</code>，因为#{}会给字符串自动增加单引号，导致SQL语句不正确。</p><h2 id="1、模糊查询"><a href="#1、模糊查询" class="headerlink" title="1、模糊查询"></a>1、模糊查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据用户名进行模糊查询</span><br>List&lt;User&gt; <span class="hljs-title function_">getUserByLike</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;fuzzy_name&quot;) String username);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--select * from t_user where username like &#x27;%$&#123;fuzzy_name&#125;%&#x27;--&gt;</span> <br>    <span class="hljs-comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;fuzzy_name&#125;,&#x27;%&#x27;)--&gt;</span> <br>    select * from t_user where username like &quot;%&quot;#&#123;fuzzy_name&#125;&quot;%&quot;<span class="hljs-comment">&lt;!--最常用--&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2、批量删除"><a href="#2、批量删除" class="headerlink" title="2、批量删除"></a>2、批量删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据id批量删除</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteMore</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> String ids)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMore&quot;</span>&gt;</span><br>    delete from t_user where id in ($&#123;ids&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果写成#{}，最终的SQL语句是<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，此时<code>1,2,3</code>整体是一个字符串，正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></p><h2 id="3、动态设置表名"><a href="#3、动态设置表名" class="headerlink" title="3、动态设置表名"></a>3、动态设置表名</h2><p>如果传入的参数是表名，只能用${}，而不能用#{}，因为表名不能加引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询指定表中的数据</span><br>List&lt;User&gt; <span class="hljs-title function_">getUserByTable</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--List&lt;User&gt; <span class="hljs-title function_">getUserByTable</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;--&gt; <br>&lt;select id=<span class="hljs-string">&quot;getUserByTable&quot;</span> resultType=<span class="hljs-string">&quot;User&quot;</span>&gt; <br>    select * from $&#123;tableName&#125; <br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h2 id="4、添加功能获取自增的主键"><a href="#4、添加功能获取自增的主键" class="headerlink" title="4、添加功能获取自增的主键"></a>4、添加功能获取自增的主键</h2><p>在mapper.xml中设置两个属性</p><ul><li><code>useGeneratedKeys</code>：设置使用自增的主键</li><li><code>keyProperty</code>：将自增的主键的值赋值给传输到映射文件中参数的某个属性，因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加用户信息</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--void insertUser(User user);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span> <br>    insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在测试类中获取这个user对象，它的id会被自动赋值为数据库中的自增主键的值</p><h1 id="六、自定义映射resultMap"><a href="#六、自定义映射resultMap" class="headerlink" title="六、自定义映射resultMap"></a>六、自定义映射resultMap</h1><h2 id="字段和属性的映射关系不同该如何处理"><a href="#字段和属性的映射关系不同该如何处理" class="headerlink" title="字段和属性的映射关系不同该如何处理"></a>字段和属性的映射关系不同该如何处理</h2><p>数据库字段一般采用下划线，Java属性一般采用驼峰，所以就会造成字段名和属性名不一致，导致映射不了，并不会报错，只是无法映射的字段会显示null</p><ol><li><strong>通过核心配置解决</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--将表中字段的下划线自动转换为驼峰 emp_name：empName--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>通过resultMap解决</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllEmp&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empResultMap&quot;</span>&gt;</span> <br>    select * from t_emp <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>resultMap：设置自定义映射</p><ul><li>属性：<ul><li>id：表示自定义映射的唯一标识，不能重复</li><li>type：查询的数据要映射的实体类的类型</li></ul></li><li>子标签：<ul><li>id：设置主键的映射关系</li><li>result：设置普通字段的映射关系</li></ul></li><li>子标签属性：<ul><li>property：设置映射关系中实体类中的属性名</li><li>column：设置映射关系中表中的字段名</li></ul></li></ul><p>一对多映射和多对一映射详见<a href="https://jwt1399.top/posts/13919.html#toc-heading-52">简简的博客</a></p><h1 id="七、动态SQL"><a href="#七、动态SQL" class="headerlink" title="七、动态SQL"></a>七、动态SQL</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span> <br>    select * from t_emp where 1=1 <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span> <br>        and emp_name = #&#123;empName&#125; <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span> <br>        and age = #&#123;age&#125; <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span> <br>        and sex = #&#123;sex&#125; <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span> <br>        and email = #&#123;email&#125; <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>where和if一般结合使用</p><ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and&#x2F;or去掉</li><li>注意：where标签不能去掉条件后多余的and&#x2F;or</li></ul><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>trim用于去掉或添加标签中的内容</p><ul><li>prefix：在trim标签中的内容的前面添加某些内容</li><li>suffix：在trim标签中的内容的后面添加某些内容</li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容</li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ul><p>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code></p><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul><li>choose、when、otherwise 相当于 if…else if…else</li><li>when 至少要有一个，otherwise 至多只有一个</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span> <br>    select * from t_emp <br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span> <br>                emp_name = #&#123;empName&#125; <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span> <br>                age = #&#123;age&#125; <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span> <br>                sex = #&#123;sex&#125; <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span> <br>                did = 1 <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>对集合进行遍历</p><p>属性：</p><ul><li>collection：设置要循环的数组或集合</li><li>item：表示集合或数组中的每一个数据</li><li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li><li>open：设置foreach标签中的内容的开始符</li><li>close：设置foreach标签中的内容的结束符</li></ul><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>sql语句可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p><ul><li>声明sql片段：<code>&lt;sql&gt;</code>标签</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span> <br>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span> from t_emp <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="八、分页插件"><a href="#八、分页插件" class="headerlink" title="八、分页插件"></a>八、分页插件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置分页插件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在查询功能之前使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能</p><ul><li>pageNum：当前页的页码</li><li>pageSize：每页显示的条数</li></ul><p>在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据</p><h1 id="八、mybatis逆向工程"><a href="#八、mybatis逆向工程" class="headerlink" title="八、mybatis逆向工程"></a>八、mybatis逆向工程</h1><h2 id="①引入依赖和插件"><a href="#①引入依赖和插件" class="headerlink" title="①引入依赖和插件"></a>①引入依赖和插件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 依赖MyBatis核心包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 控制Maven在构建过程中相关配置,对构建过程进行定制 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 构建过程中用到的插件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 插件的依赖 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>                <span class="hljs-comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>                <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>                <span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="②创建核心配置文件"><a href="#②创建核心配置文件" class="headerlink" title="②创建核心配置文件"></a>②创建核心配置文件</h2><p>首先在src&#x2F;main&#x2F;resources目录下创建核心配置文件mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            targetRuntime: 执行生成的逆向工程的版本</span><br><span class="hljs-comment">                    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><br><span class="hljs-comment">                    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库的连接信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://192.168.198.100:3306/db_imperial_court&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;atguigu&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- javaBean的生成策略--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.imperial.court.entity&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.imperial.court.mapper&quot;</span>  <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mapper接口的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.imperial.court.mapper&quot;</span>  <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 逆向分析的表 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br>        <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_memorials&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Memorials&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="③执行逆向生成"><a href="#③执行逆向生成" class="headerlink" title="③执行逆向生成"></a>③执行逆向生成</h2><p><img src="/../../../image/mybatis/15.png"></p>]]></content>
    
    
    <categories>
      
      <category>FrameWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>框架</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架-SpringMVC</title>
    <link href="/2022/07/04/Java/framework/SpringMVC/"/>
    <url>/2022/07/04/Java/framework/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前置知识-Thymeleaf"><a href="#一、前置知识-Thymeleaf" class="headerlink" title="一、前置知识(Thymeleaf)"></a>一、前置知识(Thymeleaf)</h1><h2 id="什么是Thymeleaf"><a href="#什么是Thymeleaf" class="headerlink" title="什么是Thymeleaf"></a>什么是Thymeleaf</h2><p>Thymeleaf是适用于Web和独立环境的现代服务器端<code>Java模板引擎</code>。</p><ul><li><strong>模板引擎</strong>（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的html文档。从字面上理解<code>模板引擎</code>，最重要的就是模板二字，这个意思就是做好一个模板后套入对应位置的数据，最终以html的格式展示出来，这就是模板引擎的作用。</li></ul><p><strong>以前使用的jsp就是一个模板引擎。</strong></p><p>Thymeleaf模板引擎在整个web项目中起到的作用为视图展示(view)。当今web项目较为流行的<strong>MVC</strong>(Model View Controller)架构：模型(model)－视图(view)－控制器(controller)</p><ul><li><p>Model（模型）表示应用程序核心，指工程中的javaBean。</p><p>javaBean分为两类：</p><ul><li>一类为实体类：专门存储业务数据，如Student、User</li><li>一类是业务处理类：指Service或Dao对象，专门用于处理业务逻辑和数据访问</li></ul></li><li><p>View（视图）显示数据，而本篇使用的就是Thymeleaf作为视图。</p></li><li><p>Controller（控制器）处理输入请求，将模型和视图分离。</p></li></ul><blockquote><p><strong>参考：</strong><a href="https://developer.aliyun.com/article/769977#slide-0">https://developer.aliyun.com/article/769977#slide-0</a></p></blockquote><h1 id="二、SpringMVC简介"><a href="#二、SpringMVC简介" class="headerlink" title="二、SpringMVC简介"></a>二、SpringMVC简介</h1><h2 id="1、SpringMVC的特点"><a href="#1、SpringMVC的特点" class="headerlink" title="1、SpringMVC的特点"></a>1、SpringMVC的特点</h2><ul><li>Spring家族原生产品，与IOC容器等基础设施无缝对接</li><li>基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和相应进行统一处理</li><li>内部组件化程度高</li></ul><h2 id="2、HelloWord项目"><a href="#2、HelloWord项目" class="headerlink" title="2、HelloWord项目"></a>2、HelloWord项目</h2><p><strong>创建一个maven项目，导入这些依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ogback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p><strong>新增一个webapp目录</strong></p><p><img src="/image/spring/9.png"></p><p><strong>在webapp目录下加一个web.xml文件，在里面配置servlet的相关信息</strong>，Spring MVC 初始化时将在应用程序的 WEB-INF 目录下查找配置文件，该配置文件的命名规则是“<code>&lt; servlet-name &gt;-servlet.xml</code>”，不过可以根据<code>param-name</code>标签将其改为其他路径</p><p><img src="/image/spring/10.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置SpringMVC配置文件的路径和名称--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:SpringMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--将前端控制器的初始化事件提前到服务器启动时--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--/表示可以接受来自浏览器的所有路径的请求，可以是/login，.html,.css等，但不包括.jsp结尾的路径</span><br><span class="hljs-comment">        /*才是所有的请求，因为jsp文件本身就是servlet，所以我们不需要拦截jsp文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>maven工程中，配置文件应该统一放在resources目录下，所以需要重新配置SpringMVC配置文件的路径。</p><blockquote><p>对于<code>load-on-startup</code>标签的说明：当值为0或大于0时，表示容器在应用启动时就加载并初始化这个DispatcherServlet，正数的值越小，该DispatcherServlet的优先级越高，容器启动时就先加载它。当值小于0或者没有指定时，表示该容器在DispatcherServlet被选择时才会去加载，即第一次访问servlet时加载。</p></blockquote><p>DispatcherServlet的作用是对浏览器发送的请求进行统一的处理，但不同的请求有不同的处理过程，因此需要创建处理具体请求的类，即<strong>请求控制器</strong>。</p><p><strong>SpringMVC配置文件中的配置</strong>(一般放在recources文件夹下)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;springmvc.vickkkyz.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 视图解析器，管理请求跳转到指定页面  配置Thymeleof解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--视图前缀--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br>                    <span class="hljs-comment">&lt;!--视图后缀--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>创建Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//返回要解析的视图，即想要给用户呈现的页面</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建视图页面</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置Tomcat服务器</strong></p><p><img src="/image/spring/11.png"></p><p><img src="/image/spring/12.png"></p><p>一定不要选TomcatEE</p><p><img src="/image/spring/13.png"></p><p><img src="/image/spring/14.png"></p><p> 然后就可以正确访问到<code>WEB/INF/templates/index.html</code>了</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><ul><li><p>浏览器发送请求，首先由前端控制器处理，根据web.xml中设置的可以接受的请求的路径，如果请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。</p></li><li><p>然后前端控制器会读取SpringMVC的配置文件，通过扫描组件找到真正处理请求的控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，如果匹配成功，该注解所标识的控制器方法就是处理请求的方法。</p></li><li><p>处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最后转发到视图所对应的页面。</p></li></ul><h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><ul><li>@RequestMapping放在类上：设置映射请求的请求路径的初始信息</li><li>@RequestMapping放在方法上：设置映射请求请求路径的具体信息</li></ul><h2 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h2><p>value可以是一个值，也可以是一个list，这样的话就任意一个路径都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;a th:href=<span class="hljs-string">&quot;@&#123;/testMaping&#125;&quot;</span>&gt;testMaping&lt;/a&gt;<br>&lt;a th:href=<span class="hljs-string">&quot;@&#123;/haha&#125;&quot;</span>&gt;haha&lt;/a&gt;<br><span class="hljs-comment">//   @&#123;/testMaping&#125;就代表http://localhost:8080/SpringMVC/testMaping</span><br>    <br><span class="hljs-meta">@RequestMapping(value = &#123;&quot;/testMaping&quot;,&quot;/haha&quot;&#125;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sucess&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="method属性"><a href="#method属性" class="headerlink" title="method属性"></a>method属性</h2><ul><li>@RequestMapping注解的method属性通过请求的<strong>请求方式</strong>（get或post）匹配请求映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &#123;&quot;/testMaping&quot;,&quot;/haha&quot;&#125;,method = RequestMethod.GET)</span><br></code></pre></td></tr></table></figure><p>也可以设置多个请求方法，用大括号。</p><p>对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><ul><li>get请求：@GetMapping</li><li>post请求：@PostMapping</li><li>delete请求：@DeleteMapping</li></ul><blockquote><p>目前浏览器只支持get和post请求，对于在form表单中的delete，put请求，都会按照默认的请求方式get处理。</p></blockquote><h2 id="params属性"><a href="#params属性" class="headerlink" title="params属性"></a>params属性</h2><p>params括号内的字符串需要同时满足</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/hehehe(username,password=1234)&#125;&quot;</span>&gt;</span>params<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &#123;&quot;/testMaping&quot;,&quot;/haha&quot;&#125;,params = &#123;&quot;username&quot;,&quot;password=1234&quot;&#125;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sucess&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>!username</code>代表请求参数中不能有username</p><p><code>username!=zhangsan</code>代表要求映射匹配的请求必须携带username并且username的值不能是zhangsan</p><h2 id="header属性"><a href="#header属性" class="headerlink" title="header属性"></a>header属性</h2><p>和params参数基本一样，请求头中的信息。</p><h2 id="ant风格路径"><a href="#ant风格路径" class="headerlink" title="ant风格路径"></a>ant风格路径</h2><ul><li><p>？：表示任意的单个字符 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/t?st&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p>*：表示任意的0个或多个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/t*st&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p>**：表示任意的一层或多层目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/**/test&quot;)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="路径中的占位符"><a href="#路径中的占位符" class="headerlink" title="路径中的占位符"></a>路径中的占位符</h2><ul><li>原始方式：&#x2F;practice?id&#x3D;1</li><li>REST方式：&#x2F;practice&#x2F;1</li></ul><p>占位符{xxx}表示传输的数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/practice/1&#125;&quot;</span>&gt;</span>占位符<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/practice/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test03</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span>String id)</span>&#123;<br>    System.out.println(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success2&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h2 id="通过ServletAPI获取"><a href="#通过ServletAPI获取" class="headerlink" title="通过ServletAPI获取"></a>通过ServletAPI获取</h2><p>将HttpServletRequest作为控制器方法的形参，HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/practice(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>servletAPI方式获取请求参数中的数据<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/practice&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test03</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success2&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通过控制器方法的形参获取"><a href="#通过控制器方法的形参获取" class="headerlink" title="通过控制器方法的形参获取"></a>通过控制器方法的形参获取</h2><p>在控制器方法Controller的形参位置，<strong>设置和请求参数同名的形参</strong>，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam</span><span class="hljs-params">(String username, String password)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/testParam(hobby=&#x27;a&#x27;,hobby=&#x27;b&#x27;)&#125;&quot;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam</span><span class="hljs-params">(String[] hobby)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hobby:&quot;</span>+ Arrays.toString(hobby));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br><span class="hljs-comment">//输出：hobby:[a, b]</span><br><span class="hljs-comment">//如果将hobby定义为String类型，则输出：hobby:a,b</span><br></code></pre></td></tr></table></figure><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>当有请求时，DispatcherServlet中会将请求参数赋值给相应的形参(对应规则就是根据HTML中定义的请求参数的名称来寻找形参中是否有一样名字的参数，将其赋值)。如果请求参数的名称和形参中不一致，就无法映射。因此可以通过@RequestParam来对应</p><p>@RequestParam是将<strong>请求参数</strong>和<strong>控制器方法的形参</strong>创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><ul><li>value：指定为形参赋值的请求参数的参数名</li><li>required：设置是否必须传输此请求参数，默认值为true<ul><li>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；</li><li>若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</li></ul></li><li>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/testParam(user_name=&#x27;admin&#x27;)&#125;&quot;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;user_name&quot;)</span> String username)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><ul><li>@RequestHeader是将<strong>请求头信息</strong>和<strong>控制器方法的形参</strong>创建映射关系</li><li>@RequestHeader注解一共有三个属性：value、required、defaultValue</li><li>用法同@RequestParam</li></ul><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><ul><li>@CookieValue是将<strong>cookie数据</strong>和<strong>控制器方法的形参</strong>创建映射关系</li><li>@CookieValue注解一共有三个属性：value、required、defaultValue</li><li>用法同@RequestParam</li></ul><h2 id="通过POJO获取请求参数"><a href="#通过POJO获取请求参数" class="headerlink" title="通过POJO获取请求参数"></a>通过POJO获取请求参数</h2><p>可以在控制器方法的形参位置设置一个<strong>实体类类型的形参</strong>，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span> <br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <br>    性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span>男<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <br>    邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <br>    <span class="hljs-keyword">private</span> Integer id; <br>    <span class="hljs-keyword">private</span> String username; <br>    <span class="hljs-keyword">private</span> String password; <br>    <span class="hljs-keyword">private</span> String sex; <br>    <span class="hljs-keyword">private</span> Integer age; <br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testpojo&quot;)</span> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testPOJO</span><span class="hljs-params">(User user)</span>&#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    <span class="hljs-comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="请求参数的值乱码处理"><a href="#请求参数的值乱码处理" class="headerlink" title="请求参数的值乱码处理"></a>请求参数的值乱码处理</h2><p>如果是get请求乱码，则只需要在tomcat的<code>conf/server.xml</code>处此位置加上<code>URIEncoding=UTF-8</code></p><p><img src="/image/spring/15.png"></p><p>如果是post请求乱码，则需要在springMVC配置文件中设置过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置springMVC的编码过滤器--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span> <br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h2 id="使用ServletAPI向request域对象共享数据"><a href="#使用ServletAPI向request域对象共享数据" class="headerlink" title="使用ServletAPI向request域对象共享数据"></a>使用ServletAPI向request域对象共享数据</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">//先进到index页面上，然后跳转到success页面<br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/success&#125;&quot;</span>&gt;</span>success<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>//success页面显示success，获取域对象test的值并显示<br>success<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@&#123;test&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;这是设置的test域对象的值&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用ModelAndView向request域对象共享数据"><a href="#使用ModelAndView向request域对象共享数据" class="headerlink" title="使用ModelAndView向request域对象共享数据"></a>使用ModelAndView向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelAndView&quot;)</span> <br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">testModelAndView</span><span class="hljs-params">()</span>&#123; <br>    <span class="hljs-comment">/** * ModelAndView有Model和View的功能 </span><br><span class="hljs-comment">    * Model主要用于向请求域共享数据 </span><br><span class="hljs-comment">    * View主要用于设置视图，实现页面跳转 </span><br><span class="hljs-comment">    */</span> <br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mav</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(); <br>    <span class="hljs-comment">//向请求域共享数据 </span><br>    mav.addObject(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,ModelAndView&quot;</span>); <br>    <span class="hljs-comment">//设置视图，实现页面跳转 </span><br>    mav.setViewName(<span class="hljs-string">&quot;success&quot;</span>); <br>    <span class="hljs-keyword">return</span> mav; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用Model向request域对象共享数据"><a href="#使用Model向request域对象共享数据" class="headerlink" title="使用Model向request域对象共享数据"></a>使用Model向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModel&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testModel</span><span class="hljs-params">(Model model)</span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,Model&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用map向request域对象共享数据"><a href="#使用map向request域对象共享数据" class="headerlink" title="使用map向request域对象共享数据"></a>使用map向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testMap&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span>&#123;<br>    map.put(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,Map&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用ModelMap向request域对象共享数据"><a href="#使用ModelMap向request域对象共享数据" class="headerlink" title="使用ModelMap向request域对象共享数据"></a>使用ModelMap向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelMap&quot;)</span> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testModelMap</span><span class="hljs-params">(ModelMap modelMap)</span>&#123; <br>    modelMap.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,ModelMap&quot;</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>Model、ModelMap、Map类型的参数其实本质上都是 <code>BindingAwareModelMap</code> 类型的</p><p>以上五种方法本质上都是生成一个<code>ModelAndView</code></p><h2 id="向session域共享数据"><a href="#向session域共享数据" class="headerlink" title="向session域共享数据"></a>向session域共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testSession&quot;)</span> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSession</span><span class="hljs-params">(HttpSession session)</span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;testSessionScope&quot;</span>, <span class="hljs-string">&quot;hello,session&quot;</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、SpringMVC中的视图"><a href="#六、SpringMVC中的视图" class="headerlink" title="六、SpringMVC中的视图"></a>六、SpringMVC中的视图</h1><p>SpringMVC视图的种类很多，默认有转发视图<code>InternalResourceView</code>和重定向视图<code>RedirectView</code>。若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><h2 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h2><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。如果SpringMVC配置文件中配置的视图解析器是Thymeleaf，那么就会被Thymeleaf视图解析器解析。</p><h2 id="InternalResourceView"><a href="#InternalResourceView" class="headerlink" title="InternalResourceView"></a>InternalResourceView</h2><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>当控制器方法中所设置的视图名称以”**forward:**“为前缀时，会创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testForward&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testForward</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RedirectView"><a href="#RedirectView" class="headerlink" title="RedirectView"></a>RedirectView</h2><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称以”**redirect:**“为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRedirect&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedirect</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="视图控制器view-controller"><a href="#视图控制器view-controller" class="headerlink" title="视图控制器view-controller"></a>视图控制器view-controller</h2><p>如果发送的请求不想通过controller，只想直接地跳转到目标页面，这时候就可以使用mvc:view-controller标签，在SpringMVC.xml配置文件中配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testView&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span><br></code></pre></td></tr></table></figure><p>等于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(value=&quot;/testView&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用了这个标签后必须开启mvc注解驱动的标签 <code>&lt;mvc:annotation-driven /&gt;</code>，否则会造成所有的@Controller注解无法解析，导致404错误。</li><li>如果请求存在处理器，则这个标签对应的请求处理将不起作用。因为请求是先去找处理器处理，如果找不到才会去找这个标签配置</li></ul><h2 id="访问jsp页面的视图解析器"><a href="#访问jsp页面的视图解析器" class="headerlink" title="访问jsp页面的视图解析器"></a>访问jsp页面的视图解析器</h2><p>即InternalResourceView，需要在SpringMVC配置文件中配置</p><p><img src="/image/spring/16.png"></p><h1 id="七、HttpMessageConverter"><a href="#七、HttpMessageConverter" class="headerlink" title="七、HttpMessageConverter"></a>七、HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将获取请求报文，或将Java对象转换为响应报文(json)</p><p>HttpMessageConverter 提供了两个注解和两个类型：</p><ul><li>@RequestBody，@ResponseBody</li><li>RequestEntity，ResponseEntity</li></ul><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>主要用来接收<strong>前端传递给后端</strong>的<strong>json字符串中的数据的</strong>(请求体中的数据的)；</p><p>@RequestBody可以<strong>获取请求体</strong>，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p>]]></content>
    
    
    <categories>
      
      <category>FrameWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>框架</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架-Spring</title>
    <link href="/2022/07/02/Java/framework/Spring/"/>
    <url>/2022/07/02/Java/framework/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spring框架概述"><a href="#一、Spring框架概述" class="headerlink" title="一、Spring框架概述"></a>一、Spring框架概述</h1><p>1、Spring是轻量级的开源的javaEE框架。</p><p>2、Spring可以解决企业应用开发的复杂性。</p><p>3、Spring的核心：IOC，AOP</p><ul><li>IOC：控制反转(Inversion of Control)，把创建对象的过程交给Spring容器进行管理</li><li>AOP：面向切面，不修改源代码进行功能增强</li></ul><p>4、Spring特点</p><ul><li>方便解耦，简化开发</li><li>AOP编程支持</li><li>方便程序测试(junit)</li><li>方便和其他框架进行整合(mybatis)</li><li>降低API开发难度</li><li>方便进行事务操作</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="Spring架构图"><a href="#Spring架构图" class="headerlink" title="Spring架构图"></a>Spring架构图</h2><p><img src="/../../../image/spring/3.png"></p><h2 id="ioc基本包下载"><a href="#ioc基本包下载" class="headerlink" title="ioc基本包下载"></a>ioc基本包下载</h2><p>IOC基本包有这5个：</p><p><img src="/image/spring/4.png"></p><p><a href="https://spring.io/projects/spring-framework#learn">Spring官网版本说明</a></p><ul><li><p>GA表示稳定版本 ，选这个</p></li><li><p>SNAPSHOT表示快照版本</p></li></ul><p><a href="https://repo.spring.io/ui/native/release/org/springframework/spring">Spring历史版本下载</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#spring下载好后的目录架构</span><br>.<br>├── docs  <span class="hljs-comment">#API文档和开发规范</span><br>├── libs  <span class="hljs-comment">#开发需要的JAR包和源码</span><br>├── license.txt<br>├── notice.txt<br>├── readme.txt<br>└── schema <span class="hljs-comment">#开发所需要的schema文件</span><br></code></pre></td></tr></table></figure><p><img src="/image/spring/2.png"></p><p>第一个是项目需要导入的jar包，javadoc是帮助文档，sources是源码文件</p><p><a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">commons-logging包下载</a></p><h2 id="将jar包导入项目中"><a href="#将jar包导入项目中" class="headerlink" title="将jar包导入项目中"></a>将jar包导入项目中</h2><p><img src="/image/spring/5.png"></p><p><img src="/image/spring/6.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>文件结构：</p><p><img src="/image/spring/7.png"></p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//加载spring配置文件</span><br>        <span class="hljs-comment">//类路径classpath就是在src目录下</span><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean1.xml&quot;</span>);<br><br>        <span class="hljs-comment">//获取容器配置好的bean对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;user1&quot;</span>, User.class);<br><br>        System.out.println(user1);<br>        user1.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、Spring-IOC"><a href="#三、Spring-IOC" class="headerlink" title="三、Spring IOC"></a>三、Spring IOC</h1><h2 id="Spring-提供-IOC-容器两种实现方式：（两个接口）"><a href="#Spring-提供-IOC-容器两种实现方式：（两个接口）" class="headerlink" title="Spring 提供 IOC 容器两种实现方式：（两个接口）"></a>Spring 提供 IOC 容器两种实现方式：（两个接口）</h2><ul><li>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 ，加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</li><li><strong>ApplicationContext</strong>：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用，加载配置文件时候就会把在配置文件对象进行创建，ApplicationContext 接口有实现类</li></ul><p><img src="/image/spring/8.png"></p><h2 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h2><ol><li><p>Spring<strong>创建对象</strong></p></li><li><p>Spring<strong>注入属性</strong></p></li></ol><h2 id="Bean类型"><a href="#Bean类型" class="headerlink" title="Bean类型"></a>Bean类型</h2><p>1、普通bean</p><p>2、工厂bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基础类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Course</span> &#123;<br>    <span class="hljs-keyword">private</span> String cname;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cid;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCname</span><span class="hljs-params">(String cname)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cname = cname;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCid</span><span class="hljs-params">(<span class="hljs-type">int</span> cid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cid = cid;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Course&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cname=&#x27;&quot;</span> + cname + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, cid=&quot;</span> + cid +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//工厂！！！</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Course&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Course <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Course</span> <span class="hljs-variable">course</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Course</span>();<br>        course.setCname(<span class="hljs-string">&quot;哈哈&quot;</span>);<br>        <span class="hljs-keyword">return</span> course;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> Course.class;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> FactoryBean.<span class="hljs-built_in">super</span>.isSingleton();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">//配置文件<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Factory.MyBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试类！！！在配置文件中定义bean类型可以和返回类型不同</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean3.xml&quot;</span>);<br>    <span class="hljs-type">Course</span> <span class="hljs-variable">myBean</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;myBean&quot;</span>, Course.class);<br>    System.out.println(myBean);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h2><p>在Spring中创建的bean默认是单实例的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;user1&quot;</span>,User.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;user1&quot;</span>,User.class);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//spring5.vickkkyz.User@49b0b76</span><br><span class="hljs-comment">//spring5.vickkkyz.User@49b0b76</span><br></code></pre></td></tr></table></figure><p>可以在配置文件中设置这个bean是单实例的还是多实例的</p><p><strong>scope 属性值</strong></p><ul><li>singleton，默认值，表示是单实例对象</li><li>prototype，表示是多实例对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//spring5.vickkkyz.User@769f71a9</span><br><span class="hljs-comment">//spring5.vickkkyz.User@4c9f8c13</span><br></code></pre></td></tr></table></figure><ul><li>设置 scope 为 singleton 的时候，<strong>在加载 Spring 配置文件时候就会创建单实例对象</strong></li><li>如果 scope 为 prototype 的时候，不是在加载 Spring 配置文件的时候创建对象，而是<strong>在调用 getBean 方法的时候创建多实例对象</strong></li></ul><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ul><li><p>生命周期：从对象的创建到对象的销毁的过程。</p></li><li><p>过程：</p><p>（1）通过无参构造器<strong>创建bean实例</strong></p><p>（2）通过set方法为bean的属性设置值和对其他bean的引用<strong>赋值</strong></p><p>（3）调用bean的<strong>初始化</strong>方法</p><p>（4）bean可以使用了</p><p>（5）当容器关闭时，调用bean的<strong>销毁</strong>方法</p></li></ul><p>想自己看整个流程需要在xml配置文件的bean配置中指定初始化和销毁方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;user1&quot;</span> class=<span class="hljs-string">&quot;spring5.vickkkyz.User&quot;</span> init-method=<span class="hljs-string">&quot;&quot;</span> destory-method=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>销毁的话需要在test测试类中context.close()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基础类、、、、、</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">book</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">book</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参构造器....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-built_in">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, num=&quot;</span> + num +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化构造方法....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destoryMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;销毁方法....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Book.book&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destoryMethod&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;童年&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test05</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean3.xml&quot;</span>);<br>    <span class="hljs-type">book</span> <span class="hljs-variable">book1</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;book1&quot;</span>, book.class);<br>    System.out.println(book1);<br>    context.close();<br>&#125;<br><br><span class="hljs-comment">//结果：</span><br><span class="hljs-comment">//无参构造器....</span><br><span class="hljs-comment">//执行set方法赋值</span><br><span class="hljs-comment">//（如果有后置处理器）初始化前，执行后置处理器的before方法</span><br><span class="hljs-comment">//初始化构造方法....</span><br><span class="hljs-comment">//(如果有后置处理器)初始化后，执行后置处理器的after方法</span><br><span class="hljs-comment">//book&#123;name=&#x27;童年&#x27;, num=1&#125;</span><br><span class="hljs-comment">//销毁方法....</span><br></code></pre></td></tr></table></figure><p>后置处理器的实现：定义一个类，实现BeanPostProcesser接口，重写before和after方法，在spring配置文件中配置后置处理器</p><h2 id="Bean管理操作的方式"><a href="#Bean管理操作的方式" class="headerlink" title="Bean管理操作的方式"></a>Bean管理操作的方式</h2><h3 id="1、基于xml配置文件方式"><a href="#1、基于xml配置文件方式" class="headerlink" title="1、基于xml配置文件方式"></a>1、基于xml配置文件方式</h3><h4 id="（1）创建对象"><a href="#（1）创建对象" class="headerlink" title="（1）创建对象"></a>（1）创建对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;user1&quot;</span> class=<span class="hljs-string">&quot;spring5.vickkkyz.User&quot;</span>&gt;&lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>在spring配置文件中，使用bean标签，标签里添加对应的属性，就可以实现spring帮我们进行对象创建。</p><p><strong>bean标签中的属性：</strong></p><ul><li>id：给对象起一个标识名字(唯一)</li><li>class：类的全路径</li></ul><p><strong>创建对象时是利用类的无参构造方法。</strong></p><h4 id="（2）注入属性"><a href="#（2）注入属性" class="headerlink" title="（2）注入属性"></a>（2）注入属性</h4><p>​DI：依赖注入，即注入属性。</p><p><strong>第一种注入方式：使用set方法进行注入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String bname;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bage;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBage</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bage = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBname</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bname = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.User&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--使用property属性完成注入</span><br><span class="hljs-comment">    name的值为类里面属性的名称</span><br><span class="hljs-comment">    value为要注入的值</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第二种注入方法：使用有参构造器进行注入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orders</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orders</span><span class="hljs-params">(String name, String address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Orders&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小张&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;China&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第三种注入方式：p名称空间注入（可以说是set方法注入的简化版）</strong></p><p>增加这个<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span> <span class="hljs-attr">p:bname</span>=<span class="hljs-string">&quot;你好&quot;</span> <span class="hljs-attr">p:bage</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>给属性注入的值的类型</strong></p><ol><li><p>属性的类型是String或者基本数据类型     null</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bname&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>属性的类型是String或基本数据类型      特殊符号(&lt;  &gt;)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bname&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        &lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 输出    &lt;&lt;南京&gt;&gt;     --&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>属性是引用数据类型(对象)       <strong>注入外部bean</strong></p><p><strong>外部bean:直接在beans标签内部直接定义的bean对象，外部bean可以被多个bean对象引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">userService</span> &#123;<br>    <span class="hljs-keyword">private</span> spring5.vickkkyz.Dao.userDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(spring5.vickkkyz.Dao.userDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;userService.....&quot;</span>);<br>        userDao.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">userDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;userDao.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;service&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Service.userService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Dao.userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--  这样写就是级联赋值了</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;bean id=&quot;service&quot; class=&quot;spring5.vickkkyz.Service.userService&quot;&gt;</span><br><span class="hljs-comment">        &lt;property name=&quot;userDao&quot; ref=&quot;dao&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-comment">    &lt;/bean&gt;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    &lt;bean id=&quot;dao&quot; class=&quot;spring5.vickkkyz.Dao.userDao&quot;&gt;</span><br><span class="hljs-comment"> &lt;property name=&quot;name&quot; value=&quot;这是内部bean的案例&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-comment">&lt;/bean&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!--  </span><br><span class="hljs-comment">&lt;bean id=&quot;service&quot; class=&quot;spring5.vickkkyz.Service.userService&quot;&gt;</span><br><span class="hljs-comment">        &lt;property name=&quot;userDao&quot; ref=&quot;dao&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-comment">&lt;property name=&quot;userDao.name&quot; value=&quot;这是内部bean的案例&quot;&gt;&lt;/property&gt;  //写这个需要写get方法</span><br><span class="hljs-comment">    &lt;/bean&gt;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    &lt;bean id=&quot;dao&quot; class=&quot;spring5.vickkkyz.Dao.userDao&quot;&gt;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">&lt;/bean&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>属性是引用数据类型(对象)   <strong>注入内部bean</strong></p><p> <strong>内部bean:在某个bean标签的内部定义的bean对象，内部bean只能被某个对象的某个属性引用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;service&quot;</span> class=<span class="hljs-string">&quot;spring5.vickkkyz.Service.userService&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;userDao&quot;</span>&gt;<br>            &lt;bean id=<span class="hljs-string">&quot;dao&quot;</span> class=<span class="hljs-string">&quot;spring5.vickkkyz.Dao.userDao&quot;</span>&gt;<br>                &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;这是内部bean的案例&quot;</span>&gt;&lt;/property&gt;<br>            &lt;/bean&gt;<br>        &lt;/property&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure></li><li><p>属性是数组类型、List类型、Map集合类型    注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] courses;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; list;<br>    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCourses</span><span class="hljs-params">(String[] courses)</span> &#123;<br>        <span class="hljs-built_in">this</span>.courses = courses;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setList</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMap</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> &#123;<br>        <span class="hljs-built_in">this</span>.map = map;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;courses=&quot;</span> + Arrays.toString(courses) +<br>                <span class="hljs-string">&quot;, list=&quot;</span> + list +<br>                <span class="hljs-string">&quot;, map=&quot;</span> + map +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Collection.student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;courses&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>数组第一个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>数组第二个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>集合第一个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>集合第二个元素<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>list元素是对象的情况下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Course</span> &#123;<br>    <span class="hljs-keyword">private</span> String cname;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cid;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCname</span><span class="hljs-params">(String cname)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cname = cname;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCid</span><span class="hljs-params">(<span class="hljs-type">int</span> cid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cid = cid;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Course&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cname=&#x27;&quot;</span> + cname + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, cid=&quot;</span> + cid +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Collection.student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;course1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;course2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;course1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Collection.Course&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;数学&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cid&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;course2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Collection.Course&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;英语&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cid&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将集合注入部分抽取成公共部分</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:util</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;courselist&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        基本数据类型和String类型就直接用value标签来赋值--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;value&gt;&lt;/value&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spring5.vickkkyz.Collection.student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;courselist&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>自动装配</strong></p><p>上面所有用的方式都是手动装配，即手动给类中的属性设置值。</p><p><strong>只有非字面量（非基本数据类型及其封装类）的属性才能自动装配</strong></p><p>比如现在有两个类A，B。在类A中有一个属性类B，在spring配置文件中配置类A，对于类A的属性B不需要手动配置，而是在bean标签内有一个atuowire标签 自动装配。(需要提前配置好类B)</p><p>自动装配类型：</p><ul><li>byName  注入值 bean 的 id 值和在类A中B的属性名称一样</li><li>byType  根据属性类型注入</li></ul></li></ol><h3 id="2、基于注解方式"><a href="#2、基于注解方式" class="headerlink" title="2、基于注解方式"></a>2、基于注解方式</h3><p>注解的格式：@注解名称(属性名称&#x3D;属性值,属性名称&#x3D;属性值..)</p><p>注解是为了简化xml的配置</p><p><strong>第一步:引入依赖包</strong></p><p>commons-logging-1.2.jar<br>spring-aop-5.3.21.jar<br>spring-beans-5.3.21.jar<br>spring-context-5.3.21.jar<br>spring-core-5.3.21.jar<br>spring-expression-5.3.21.jar</p><p><strong>第二步:开启组件扫描</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- base-package 表示扫描哪个包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;spring5.vickkkyz&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>自定义扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    默认的filter 扫描base-package下指定包路径下的所有注解(4个)</span><br><span class="hljs-comment">    use-default-filters=&quot;false&quot; 表示不使用默认的filter,自己配置</span><br><span class="hljs-comment">        context:include-filter表示只扫描spring5.vickkkyz包下的expression所指示的注解</span><br><span class="hljs-comment">                exclude就是排除出去,不扫描</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;spring5.vickkkyz&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第三步:使用注解</strong></p><p><strong>1类相关的注解:    Spring中针对bean管理中创建对象提供的注解有:</strong></p><p>@Component</p><p>@Service</p><p>@Controller</p><p>@Repository</p><p><strong>2 属性相关的注解</strong></p><p>@Atuowired  按照类型(class)进行自动装配</p><p>@Qualifier  按照名称进行自动装配,需要和Autowired一起使用</p><p>@Resource  可以按照类型,也可以按照名称</p><p>@Value  对String类型的自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;userDao&quot;)</span><br><span class="hljs-keyword">private</span> UserDao userDao;<br><br><span class="hljs-meta">@Value(value = &quot;ad&quot;)</span><br><span class="hljs-keyword">private</span> String hello;<br></code></pre></td></tr></table></figure><p><strong>完全注解模式:不用xml文件</strong></p><p>使用配置类代替xml文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//作为配置类,替代xml文件</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;spring5.vickkkyz&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>    userService.add();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、Spring-AOP"><a href="#四、Spring-AOP" class="headerlink" title="四、Spring AOP"></a>四、Spring AOP</h1><h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p>面向切面编程，基于OOP面向对象编程，底层就是AOP在程序运行期间，将某段代码<strong>（日志代码）</strong>动态地切入（<strong>不把日志代码写死在业务逻辑方法中</strong>）到指定方法的指定位置（方法的开始，结束，异常等位置）进行运行的这种编程方式。</p><p><strong>jdk默认的动态代理：如果目标对象没有实现任何借口，是无法为他创建代理对象的</strong>，因为jdk动态代理与目标对象就是靠实现同一个接口来建立的。</p><p><strong>利用Spring AOP的优点</strong>：实现简单，没有强制要求目标对象必须实现接口</p><h2 id="AOP使用步骤"><a href="#AOP使用步骤" class="headerlink" title="AOP使用步骤"></a>AOP使用步骤</h2><p><strong>1、导包</strong></p><p><strong>Spring基础包</strong></p><p>commons-logging-1.2.jar<br>spring-aop-5.3.21.jar<br>spring-beans-5.3.21.jar<br>spring-context-5.3.21.jar<br>spring-core-5.3.21.jar<br>spring-expression-5.3.21.jar</p><p><strong>AOP相关的包</strong></p><p>spring-aop-5.3.21.jar</p><p>com.springsource.net.sf.cglib-2.2.0.jar</p><p>com.springsource.org.aopalliance-1.0.0.jar</p><p>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</p><p><strong>2、写配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=</span><br><span class="hljs-tag">               <span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--开启包扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;spring5.vickkkyz&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启基于注解的aop功能--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>myCalculator实现接口的情况下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">cheng</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">chu</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a-b;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cheng</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a*b;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chu</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a/b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogUtil</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Before</span> 在目标方法之前运行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@After</span> 在目标方法结束之后</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@AfterReturning</span> 在目标方法正常返回之后</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@AfterThrowing</span> 在目标方法抛出异常之后执行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Around</span> 环绕通知，是上面4个通知的结合</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">//切入点表达式的固定格式：execution(访问权限符 返回值类型 方法全类名(参数表))</span><br>    <span class="hljs-meta">@Before(&quot;execution(public int spring5.vickkkyz.jisuanqi.MyCalculator.*(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logStart</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法开始前。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterReturning(&quot;execution(public int spring5.vickkkyz.jisuanqi.MyCalculator.*(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logReturn</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法正常返回后。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterThrowing(&quot;execution(public int spring5.vickkkyz.jisuanqi.MyCalculator.*(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logExecption</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法抛出异常后。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;execution(public int spring5.vickkkyz.jisuanqi.MyCalculator.*(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logEnd</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法最终结束后。。。&quot;</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br>        <span class="hljs-comment">//注意是接口类型才行，因为是动态代理</span><br>        <span class="hljs-comment">//容器中保存的组件是MyCalculator的代理对象Proxy</span><br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">myCalculator</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;myCalculator&quot;</span>, Calculator.class);<br>        myCalculator.add(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">//spring5.vickkkyz.jisuanqi.MyCalculator@183ec003</span><br><span class="hljs-comment">//class com.sun.proxy.$Proxy19</span><br>        System.out.println(myCalculator);<br>        System.out.println(myCalculator.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>myCalculator没有实现接口的情况下：</strong></p><p>由cglib来创建动态代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br>        <span class="hljs-comment">//注意是接口类型才行，因为有动态代理</span><br>        <span class="hljs-type">MyCalculator</span> <span class="hljs-variable">myCalculator</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;myCalculator&quot;</span>, MyCalculator.class);<br>        myCalculator.add(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-comment">//spring5.vickkkyz.jisuanqi.MyCalculator@638ef7ed</span><br><span class="hljs-comment">//class spring5.vickkkyz.jisuanqi.MyCalculator$$EnhancerBySpringCGLIB$$642353d5</span><br>        System.out.println(myCalculator);<br>        System.out.println(myCalculator.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、测试</strong></p><hr><p><strong>JdbcTemplate</strong>是Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><blockquote><p>本文参考：<a href="https://jwt1399.top/posts/18155.html#toc-heading-16">简简的博客</a>，<a href="https://www.bilibili.com/video/BV1Vf4y127N5?vd_source=c1b40fa5b4df055a1cae36a0ac4e1d21">尚硅谷</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>FrameWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
      <tag>IOC</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2022/05/22/Redis/redis/"/>
    <url>/2022/05/22/Redis/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Redis的简单介绍"><a href="#1-Redis的简单介绍" class="headerlink" title="1.Redis的简单介绍"></a>1.Redis的简单介绍</h1><p>Redis 诞生于 2009 年，全称是 <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver ， 远程词典服务器， 是一个基于内存的键值型 NoSQL 数据库。Redis是一个key-value的数据库</p><p>特征： </p><ul><li>键值（ key-value ） 型， value 支持多种不同数据结构， 功能丰富 </li><li>单线程， 每个命令具备原子性 </li><li>低延迟， 速度快（基于内存、 I O 多路复用、 良好的编码） 。 </li><li>支持数据持久化</li><li>支持主从集群、 分片集群 </li><li>支持多语言客户端</li></ul><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h1><h2 id="2-1-KEYS"><a href="#2-1-KEYS" class="headerlink" title="2.1 KEYS"></a>2.1 KEYS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs redis">127.0.0.1:6379&gt; help keys<br><br>  KEYS pattern<br>  summary: Find all keys matching the given pattern #查找所有符合给定模式的key<br>  since: 1.0.0<br>  group: generic<br></code></pre></td></tr></table></figure><p>比如 <code>keys *</code> 表示查找所有的key，<code>keys a*</code>表示查找所有以a开头的key</p><h2 id="2-2-DEL"><a href="#2-2-DEL" class="headerlink" title="2.2 DEL"></a>2.2 DEL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs redis">127.0.0.1:6379&gt; help del<br><br>  DEL key [key ...]<br>  summary: Delete a key # 删除一个key<br>  since: 1.0.0<br>  group: generic<br></code></pre></td></tr></table></figure><p>比如<code>key age</code>表示删除名为age的key，返回删除的key的个数</p><h2 id="2-3-EXISTS"><a href="#2-3-EXISTS" class="headerlink" title="2.3 EXISTS"></a>2.3 EXISTS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs redis">127.0.0.1:6379&gt; help exists<br><br>  EXISTS key [key ...]<br>  summary: Determine if a key exists #判断一个key是否存在，存在则返回1，不存在返回0<br>  since: 1.0.0<br>  group: generic<br></code></pre></td></tr></table></figure><h2 id="2-4-EXPIRE-TTL"><a href="#2-4-EXPIRE-TTL" class="headerlink" title="2.4 EXPIRE &amp; TTL"></a>2.4 EXPIRE &amp; TTL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs redis">127.0.0.1:6379&gt; help expire<br><br>  EXPIRE key seconds<br>  summary: Set a key&#x27;s time to live in seconds # 给key设置一个有效期，到期自动删除<br>  since: 1.0.0<br>  group:generic<br></code></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs redis">127.0.0.1:6379&gt; help ttl<br><br>  TTL key<br>  summary: Get the time to live for a key #返回key的剩余有效时间，如果到期，会变为-2，如果返回-1表示永久有效<br>  since: 1.0.0<br>  group: generic<br></code></pre></td></tr></table></figure><h2 id="2-5-SET"><a href="#2-5-SET" class="headerlink" title="2.5 SET"></a>2.5 SET</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs redis">127.0.0.1:6379&gt; help set<br><br>  SET key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX] [GET]<br>  summary: Set the string value of a key<br>  since: 1.0.0<br>  group: string<br></code></pre></td></tr></table></figure><p>设置键值对</p><h1 id="3-Redis中的数据结构与对象"><a href="#3-Redis中的数据结构与对象" class="headerlink" title="3.Redis中的数据结构与对象"></a>3.Redis中的数据结构与对象</h1><h2 id="3-1-简单动态字符串-SDS"><a href="#3-1-简单动态字符串-SDS" class="headerlink" title="3.1 简单动态字符串(SDS)"></a>3.1 简单动态字符串(SDS)</h2><p>简单动态字符串(SDS，simple dynamic string)：Redis的默认字符串表示，包含字符串值的键值对在底层都是由SDS实现的。</p><p>一个SDS结构由三部分组成：</p><ul><li>free    记录buf数组中未使用字节的数量</li><li>len      记录buf数组中已使用字节的数量</li><li>buf      字节数组，用于保存字符串，为一个char类型的数组</li></ul><p><img src="/image/redis/redis1.png"></p><p>SDS遵循C字符串以空字符(<code>\0</code>)结尾的习惯，这个空间不算在SDS的len属性中。redis会为空字符分配额外的1字节空间，这个空字符对SDS的使用者来说是完全透明的。</p><hr><p><strong>SDS相较于C字符串的好处</strong></p><ol><li><p><strong>O(1)复杂度获取字符串长度。</strong></p><p>在C语言中普通的字符串如果字符数组的有效长度是N，那实际长度是N+1，最后一个字符是空字符\0，表示字符串的结束。并没有额外记录数组的长度，所以当每次获取字符串长度时，都需要遍历整个字符串，整个遍历操作的时间复杂度是O(N)。而SDS字符串中，使用len属性实时记录了字符串的长度，所以可以直接获取，时间复杂度是O(1)。</p></li><li><p><strong>有效防止缓冲区内存溢出</strong></p><p>如果没有为字符串分配足够的空间，当进行字符串扩展拼接时，多出来的部分就会溢出，可能会覆盖这个内存地址中的其他内容，造成内存溢出。而SDS的API进行字符串扩展拼接时，<strong>会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小</strong>，继续执行，所以这样也不会内存溢出。</p></li><li><p><strong>减少修改字符串时带来的内存分配次数</strong></p><p>由于内存重分配涉及复杂的算法，并且可能需要执行系统调用，比较耗时，所以尽量减少内存分配的次数。在C字符串中，每次拼接&#x2F;裁剪字符串都需要重新进行内存的分配。在SDS中，有一个记录空闲空间的字段free，通过未使用空间，SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略。</p><ul><li><p>空间预分配</p><p>当SDS的API对一个SDS进行修改，并需要对SDS进行空间扩展时，程序会为SDS分配足够的空间，以及一些额外的空间，为下次扩展做准备(这个策略可以减少连续执行字符串增长操作所需的内存重分配次数)。</p><p>额外分配的未使用空间的大小：</p><ul><li>对SDS修改后，它的长度(len)小于1MB，那程序会分配和len一样大的空间，保存到free字段中。</li><li>对SDS修改后，它的长度(len)大于1MB，那么程序会分配1MB的未使用空间(free)</li></ul></li><li><p>惰性空间释放</p><p>用于优化SDS的字符串缩短操作，当需要缩短字符串时，并不直接释放要删除的空间，而是使用free记录，这样避免了缩短字符串时所需的内存重分配操作，并为将来有可能的增长操作提供了优化。</p></li></ul><p>修改字符串长度N次<strong>最多</strong>需要执行N次内存重分配。</p></li><li><p><strong>二进制安全</strong></p><p>C字符串中的字符必须符合某种编码(如ASCII)，并且只有字符串末尾可以是空字符\0，所以C中只能保存文本数据，而不能保存图片、音频等二进制数据。而SDS使用len记录字符串的结尾，byte字节数组记录真实的数据(存放的是二进制数据，而不是一位一位的字符)</p></li><li><p><strong>兼容部分C字符串</strong></p><p>因为SDS同样在字符串末尾加上\0，所以对于C中的部分函数，SDS也可以使用。</p></li></ol><h2 id="3-2-链表"><a href="#3-2-链表" class="headerlink" title="3.2 链表"></a>3.2 链表</h2><p>C语言中没有这种数据结构，因此Redis构建了自己的链表实现。由 <code>list</code> 结构和 <code>listNode</code> 节点组成的链表。</p><p><strong>ListNode的结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct listNode &#123;<br>    <span class="hljs-comment">// 保存前驱节点</span><br>    struct listNode *prev;<br>    <span class="hljs-comment">// 保存后继节点</span><br>    struct listNode *next;<br>    <span class="hljs-comment">// 保存值</span><br>    <span class="hljs-keyword">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><p><strong>list的结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct list &#123;<br>    <span class="hljs-comment">// 头结点</span><br>    listNode *head;<br>    <span class="hljs-comment">// 尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">// 复制函数</span><br>    <span class="hljs-keyword">void</span> *(*dup)(<span class="hljs-keyword">void</span> *ptr);<br>    <span class="hljs-comment">// 释放函数</span><br>    <span class="hljs-keyword">void</span> (*free)(<span class="hljs-keyword">void</span> *ptr);<br>    <span class="hljs-comment">// 匹配函数</span><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">void</span> *key);<br>    <span class="hljs-comment">// 链表长度</span><br>    unsigned <span class="hljs-type">long</span> len;<br>&#125; list;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis2.png"></p><p>双端节点，无环(头结点的prev和尾结点的next都指向NULL)，head指向头结点，tail指向尾结点，len记录链表节点长度，还有三个函数使链表节点可以保存不同类型的值。</p><p>dup、free和match成员则是用于实现多态链表所需的类型特定函数</p><ul><li>dup函数用于复制 链表节点所保存的值</li><li>free函数用于释放 链表节点所保存的值</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等</li></ul><h2 id="3-3-字典"><a href="#3-3-字典" class="headerlink" title="3.3 字典"></a>3.3 字典</h2><p>字典，又称为符号表、关联数组、映射，是一种用于保存键值对的抽象数据结构。</p><p>Redis的数据库使用字典来作为底层实现，对数据库的增删改查操作也是构建在对字典的操作之上的。而<strong>字典使用哈希表作为底层实现。</strong></p><hr><h3 id="3-3-1-Redis中字典的结构"><a href="#3-3-1-Redis中字典的结构" class="headerlink" title="3.3.1 Redis中字典的结构"></a>3.3.1 Redis中字典的结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct dict &#123;<br>    <span class="hljs-comment">//类型特定函数</span><br>    dictType *type;<br>    <span class="hljs-comment">//私有数据</span><br>    <span class="hljs-keyword">void</span> *privdata;<br>    <span class="hljs-comment">//哈希表</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//rehash索引，没有进行rehash时，值为-1</span><br>    <span class="hljs-type">long</span> rehashidx; <br>&#125; dict;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis5.png"></p><h4 id="1-type"><a href="#1-type" class="headerlink" title="(1) type"></a>(1) type</h4><p>一个指向dictType结构的指针，每个dictType结构保存了一些用于操作特定类型键值对的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct dictType &#123;<br>    <span class="hljs-comment">// 计算哈希值的函数</span><br>    uint64_t (*hashFunction)(const <span class="hljs-keyword">void</span> *key);<br>    <br>    <span class="hljs-comment">// 复制键的函数</span><br>    <span class="hljs-keyword">void</span> *(*keyDup)(<span class="hljs-keyword">void</span> *privdata, const <span class="hljs-keyword">void</span> *key);<br>    <br>    <span class="hljs-comment">// 复制值的函数</span><br>    <span class="hljs-keyword">void</span> *(*valDup)(<span class="hljs-keyword">void</span> *privdata, const <span class="hljs-keyword">void</span> *obj);<br>    <br>    <span class="hljs-comment">// 对比键的函数</span><br>    <span class="hljs-type">int</span> (*keyCompare)(<span class="hljs-keyword">void</span> *privdata, const <span class="hljs-keyword">void</span> *key1, const <span class="hljs-keyword">void</span> *key2);<br>    <br>    <span class="hljs-comment">// 销毁键的函数</span><br>    <span class="hljs-keyword">void</span> (*keyDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *key);<br>    <br>   <span class="hljs-comment">// 销毁值的函数</span><br>    <span class="hljs-keyword">void</span> (*valDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *obj);<br>&#125; dictType;<br></code></pre></td></tr></table></figure><h4 id="2-privdata"><a href="#2-privdata" class="headerlink" title="(2) privdata"></a>(2) privdata</h4><p>保存了需要传给类型特定函数的可选参数。</p><h4 id="3-dictht-ht-2"><a href="#3-dictht-ht-2" class="headerlink" title="(3) dictht ht[2]"></a>(3) dictht ht[2]</h4><p>字典中保存两个哈希表，哈希表的结构如下：</p><p><img src="/image/redis/redis4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//哈希表的结构：</span><br>typedef struct dictht &#123;<br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br>    <br>    <span class="hljs-comment">// 哈希表大小</span><br>    unsigned <span class="hljs-type">long</span> size;<br>    <br>    <span class="hljs-comment">// 哈希表掩码，大小为size-1，用于计算索引值</span><br>    unsigned <span class="hljs-type">long</span> sizemask;<br>    <br>    <span class="hljs-comment">// 哈希表中已有的节点数</span><br>    unsigned <span class="hljs-type">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><ul><li><p><strong>table</strong>       table为一个dictEntry类型的一维数组，数组中的每个元素都是一个指向dictEntry结构的指针，每个dictEntry中保存了一个键值对。</p><p>dictEntry的结构为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每个dictEntry节点</span><br>typedef struct dictEntry &#123;<br>    <span class="hljs-comment">// 键</span><br>    <span class="hljs-keyword">void</span> *key;<br>    <span class="hljs-comment">// 值</span><br>    union &#123;<br>        <span class="hljs-keyword">void</span> *val;<br>        uint64_t u64;<br>        int64_t s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-comment">// 指向下一个哈希节点，形成链表</span><br>    struct dictEntry *next;<br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>key属性保存键值对中的键，v属性保存键值对中的值，它的类型可以是这几种。</p><p>next属性是指向另一个哈希表节点的指针，这个指针可以将<strong>多个哈希值相同的键值对连接在一起</strong>，来解决键冲突，这是<strong>链地址法</strong></p></li><li><p><strong>size</strong>          哈希表大小</p></li><li><p><strong>sizemask</strong>       哈希表掩码，大小为size-1，用于计算索引值(哈希值&amp;sizemark)</p></li><li><p><strong>used</strong>         哈希表中已有的节点数</p></li></ul><h4 id="4-rehashidx"><a href="#4-rehashidx" class="headerlink" title="(4) rehashidx"></a>(4) rehashidx</h4><p>rehash索引，没有进行rehash时，值为-1</p><h3 id="3-3-2-哈希算法"><a href="#3-3-2-哈希算法" class="headerlink" title="3.3.2 哈希算法"></a>3.3.2 哈希算法</h3><p>当要将一个新的键值对添加到字典里时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表的指定桶上。</p><p><strong>步骤：</strong></p><ol><li><strong>计算哈希值</strong>      <code>hash=dict-&gt;type-&gt;hashFunction(key);</code>   在这个函数里面，Redis使用的是MurmurHash2算法来计算键的哈希值。</li><li><strong>计算索引值(桶下标)</strong>      <code>index=hash &amp; dict-&gt;ht[0].sizemark;</code>  当有两个或两个以上的键被分配到了哈希表数组的同一个索引上面，则这些键发生了<strong>哈希冲突(collision)<strong>。Redis的哈希表使用</strong>链地址法</strong>来解决键冲突，单向链表，新的节点被插入到链表的头部(这是因为链表没有指向链表尾结点的指针，所以为了提高速度，每次就将新节点插入表头位置)</li></ol><h3 id="3-3-3-渐进式rehash-扩容或缩容"><a href="#3-3-3-渐进式rehash-扩容或缩容" class="headerlink" title="3.3.3 渐进式rehash(扩容或缩容)"></a>3.3.3 渐进式rehash(扩容或缩容)</h3><p>哈希表的负载因子&#x3D;哈希表已保存节点数量&#x2F;哈希表大小</p><p><strong>扩容&#x2F;缩容的目标容量的规定：</strong></p><p>即要为ht[1]分配的空间大小。</p><ul><li>扩容，ht[1]的大小为第一个大于等于(ht[0].used*2)的2的n次方，比如ht[0]中有4个节点，则ht[0].used×2&#x3D;8，则第一个大于等于8，并且需要是2的n次方的数就是8，所以容量就是8。</li><li>缩容，ht[1]的大小为第一个大于等于ht[0].used的2的n次方，比如ht[0]中有4个节点，则ht[0].used&#x3D;4，则第一个大于等于4，并且是2的n次方的数是4，所以ht[1]的容量是4。</li></ul><p><strong>以下情况，程序会自动对哈希表进行rehash操作：</strong></p><ul><li>服务器目前没有在执行BGSAVE或BGREWRITEAOF命令，并且哈希表的负载因子&gt;&#x3D;1     扩容</li><li>服务器目前正在执行BGSAVE或BGREWRITEAOF命令，并且哈希表的负载因子&gt;&#x3D;5     扩容</li><li>哈希表的负载因子&lt;0.1   缩容</li></ul><p><strong>步骤：</strong></p><ol><li>为ht[1]分配空间(指定容量)，此时字典同时拥有两个哈希表：ht[1]和ht[0]</li><li>在字典中维护一个索引计数器变量rehashidx，初值为0，表示从ht[0]的数组的0位置开始。</li><li>在rehash期间，用户依旧可以对redis数据库中的数据进行增删改查更新等操作，数据库在响应用户请求的同时，会将ht[0]哈希表的rehashidx索引上的所有键值对rehash到ht[1]，这里需要重新计算索引下标。当这次的rehash完成后，rehashidx的值加1，然后继续执行后面的桶。</li><li>当ht[0]上的所有键值对都被rehash到了ht[1]后，rehashidx的值被设为-1，表示rehash完成。</li><li>现在ht[0]是空表， 释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个哈希表，为下次rehash做准备。</li></ol><blockquote><p>渐进式rehash</p><p>rehash不是一次性完成的，而是渐进式完成的。用户操作(增删改查更新)和节点迁移是并发执行的。</p><p>字典会同时使用ht[0]和ht[1]，<strong>对字典的删改查会在这两个哈希表上进行</strong>，比如要在字典中查找一个键，程序会现在ht[0]中查找，如果没有，就到ht[1]中查找。<strong>对于新添加到字典的键值对，都会被直接保存到ht[1]中，ht[0]中不再进行任何的添加操作。</strong></p></blockquote><h2 id="3-4-跳跃表-skiplist"><a href="#3-4-跳跃表-skiplist" class="headerlink" title="3.4 跳跃表(skiplist)"></a>3.4 跳跃表(skiplist)</h2><p>跳跃表是一个<strong>有序并联链表</strong>，它以随机化数据结构为基础，通过在每个节点中维持多个指向其他不同的节点的的指针，来达到快速访问的目的。</p><p>Redis在实现<code>有序集合键</code>和在<code>集群节点</code>中用作内部数据结构。</p><blockquote><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>——-《redis的设计与实现》</p></blockquote><h3 id="1、结构"><a href="#1、结构" class="headerlink" title="1、结构"></a>1、结构</h3><p><img src="/image/redis/redis6.png"></p><p>相同颜色的是同一层。</p><p>Redis的跳跃表是由<code>zskiplistNode</code>和<code>zskiplist</code>两个结构定义，<code>zskiplisNode</code>是一个跳跃表节点，跳跃表由许多个跳跃表节点构成，然后有一个<code>zskiplist</code>来保存跳跃表节点的相关信息，就类似于虚拟头结点dummyNode，有指向链表的头结点和尾结点的指针，以及其他信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">zadd key score1 obj1 score2 obj2 ...<br></code></pre></td></tr></table></figure><hr><p><strong>zskiplistNode结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct zskiplistNode &#123;<br>    <span class="hljs-comment">//成员对象</span><br>    robj *obj;<br>    <br>    <span class="hljs-comment">// 分值,就是语句中的score</span><br>    <span class="hljs-type">double</span> score;<br>    <br>    <span class="hljs-comment">// 指向前驱节点prev</span><br>    struct zskiplistNode *backward;<br>    <br>    <span class="hljs-comment">// 层，每个节点有1~32个层，除头结点外（32层），其他节点的层数是随机的</span><br>    struct zskiplistLevel &#123;<br>        <span class="hljs-comment">// 每个层都保存了该节点的后继节点</span><br>        struct zskiplistNode *forward;<br>        <br>        <span class="hljs-comment">// 跨度，用于记录该节点的前进指针所指向节点和当前节点的距离</span><br>        <span class="hljs-comment">//即指向的节点编号(自己取的)-当前节点的编码</span><br>        unsigned <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>    <br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><ul><li><p><strong>level[]数组</strong></p><p>是一个结构体数组，结构体有两个成员，forward和span。数组的每个元素代表这个节点所在的层，level[0]是第一层，level[1]是第二层，以此类推。</p><p>数组的大小：每次创建一个新跳跃表节点时，程序都根据幂次定律随机生成一个1-32之间的值作为level数组的大小，这个大小就是节点的层高。</p><ul><li><p><strong>前进指针forward</strong></p><p>指向后面的某个节点，用于快速访问节点(可以跳着访问)</p></li><li><p><strong>跨度</strong></p><p>用于记录两个节点之间的距离，这两个节点，一个是当前节点，一个是forward指针指向的节点，跨度的值等于两节点中间相隔的节点个数+1。forward指针指向NULL，则跨度为0。跨度是用来计算当前节点在跳跃表中的排位的。第一个节点(头节点后的节点)的排名为1，第三个节点的排位为2….</p></li></ul></li><li><p><strong>后退指针backward</strong></p></li></ul><p>后退指针没有跨度，所以只能挨个访问。访问方法是先通过tail找到尾结点，然后访问后退指针指向的节点，一个一个倒着访问。</p><ul><li><strong>分值和成员</strong></li></ul><p>跳跃表中的所有结点都按照分值<strong>从小到大</strong>来排序，double类型的浮点数。</p><p><strong>节点的成员对象<code>obj</code>是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值，即简单动态字符串</strong></p><p>关于排序问题：在同一个跳跃表中，各个结点保存的成员对象必须是唯一的，但分值可以相同。如果两个节点的分值不同，则按照分值从小到大排序，如果分值相等，则按照成员对象在字典序中的大小进行排序，小的排在前面。</p><hr><p><strong>zskiplist</strong></p><p>多个跳跃表节点组成了一个跳跃表list，用zskiplist来维护这个表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct zskiplist &#123;<br>    <span class="hljs-comment">// 头尾指针，用于保存头结点和尾节点</span><br>    struct zskiplistNode *header, *tail;<br>    <br>    <span class="hljs-comment">// 跳跃表的长度，即除头结点以外的节点数</span><br>    unsigned <span class="hljs-type">long</span> length;<br>    <br>    <span class="hljs-comment">// 最大层数，保存了节点中拥有的最大层数（不包括头结点）</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><h3 id="2、跳表的核心操作"><a href="#2、跳表的核心操作" class="headerlink" title="2、跳表的核心操作"></a>2、跳表的核心操作</h3><p>N为跳跃表的长度，即节点个数，不包括头结点。</p><ul><li>插入一个数据；平均O(logN)</li><li>删除一个数据；平均O(logN)</li><li>查找一个数据；平均O(logN)</li><li>按照区间查找数据（比如查找值在[100, 356]之间的数据）；平均O(logN)</li></ul><p><img src="/image/redis/redis7.png"></p><p><img src="/image/redis/redis8.png"></p><p>新加入的节点，层数是随机的，假如随机生成的层数是2，则level0、level1三层有这个节点。</p><p><img src="/image/redis/redis9.png"></p><p>如果要实现这个效果，我们要分两步去做：</p><ul><li>找到新节点在每一层的上一个节点（即：对于level0，应该先找到节点9；对于level1，应该先找到节点8）</li><li>将新节点插入到每一层的上一个节点和下一个节点之间</li></ul><blockquote><p>redis的跳跃表在插入节点时，会随机生成节点的层数，通过控制每一层的概率，控制每一层的节点个数，也就是保证第一层的节点个数，之后逐层增加。生成n+1的概率是生成n的概率的4倍。我觉得这是为了避免最差情况下退化为链表的结构，所以尽可能的要多生成几层。</p><p>引用大佬文章：<a href="https://djqueue.blog.csdn.net/article/details/105476382">https://djqueue.blog.csdn.net/article/details/105476382</a></p></blockquote><h3 id="3、相关问题"><a href="#3、相关问题" class="headerlink" title="3、相关问题"></a>3、相关问题</h3><h3 id="为什么Redis用跳跃表而不用链表？"><a href="#为什么Redis用跳跃表而不用链表？" class="headerlink" title="为什么Redis用跳跃表而不用链表？"></a>为什么Redis用跳跃表而不用链表？</h3><p>储存数据时，数组容量有限且有序数组增加元素时效率比较低，所以存储数据时常选用链表。但是因为查询链表中某个节点的时间复杂度是O(N)，无论链表中的元素是否有序。</p><p>但是使用红黑树，二叉搜索树，B树，B+树，实现他们又过于复杂。所以使用跳表，利用空间换时间的方式，提高查询效率。</p><h3 id="为什么Redis用跳跃表而不用B-树？"><a href="#为什么Redis用跳跃表而不用B-树？" class="headerlink" title="为什么Redis用跳跃表而不用B+树？"></a>为什么Redis用跳跃表而不用B+树？</h3><p><em>从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因</em></p><p><strong>MySQL是从磁盘中读取数据。</strong>所以MySQL要解决的问题是尽可能的减少磁盘IO的次数，在MySQL中，叶子节点存储数据，即数据库中的每条记录，非叶子结点存储索引，每个节点可以存储多条记录，MySQL将节点大小设置为磁盘页的大小，所以每次读取磁盘页就会读取整个叶子节点，为的是最大限度的降低磁盘IO次数，B+树只需要查到最后一层的某些页面，然后逐个遍历(记录与记录之间是单向链表的形式，页面和页面之间是双向链表的形式)。</p><p>b+树一个节点可以存多个keyvalue结构，其他很多数据结构，这也保证了B+树的稳定性。</p><p><strong>而Redis是从内存中读取数据，</strong>不涉及IO，从内存读取比从磁盘读取快得多，所以不必那么麻烦，就使用跳跃表。</p><blockquote><p><strong>部分引用</strong><a href="https://nyimac.gitee.io/2020/11/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/#3%E3%80%81Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8">https://nyimac.gitee.io/2020/11/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/#3%E3%80%81Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8</a></p></blockquote><h3 id="为什么Redis使用单线程"><a href="#为什么Redis使用单线程" class="headerlink" title="为什么Redis使用单线程"></a>为什么Redis使用单线程</h3><p>redis本身是基于<strong>内存</strong>的，所以redis的性能瓶颈更多的是在于内存和网络带宽，而不是CPU。而单线程的实现更加简单和经济，指令串行，不用维护额外的锁机制，资源竞争，避免了不必要的上下文切换和竞争条件，减少了CPU的消耗。即Redis是基于内存的操作，没有I&#x2F;O操作，所以单线程执行效率更高。</p><blockquote><p><strong>单线程下串行更快的原因：</strong></p><p>对于单CPU来说，线程的串行比并行更快，因为只有一个CPU，只能单线程，此时的并行相当于先执行A一段时间，再执行B一段时间，再执行A，再执行B，….，在切换线程时，会导致上下文切换，CPU需要保存切换线程的信息，这个操作也很耗时，所以对于单线程 串行比较快。</p></blockquote><hr><blockquote><p><strong>对于I&#x2F;O操作，并发执行效率更高</strong></p></blockquote><blockquote><p>因为I&#x2F;O操作主要有以下两个过程</p><ul><li>等待I&#x2F;O准备就绪</li><li>真正操作I&#x2F;O资源</li></ul><p><strong>等待I&#x2F;O准备就绪</strong>这个阶段，CPU是空闲的，这时便可以去执行其他任务，这样也就提高了CPU的利用率</p></blockquote><h2 id="3-5-整数集合-intset"><a href="#3-5-整数集合-intset" class="headerlink" title="3.5 整数集合(intset)"></a>3.5 整数集合(intset)</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含<strong>整数值</strong>元素，并且<strong>这个集合的元素数量不多</strong>时，Redis就会只用整数集合作为集合键的底层实现。</p><p>整数集合可以保存的整数类型是int16_t、int32_t、int64_t，集合中元素从小到大有序排列，并且没有重复的元素。</p><p><code>命令：SADD numbers 1 3 5 7 //创建整数集合</code></p><p><code>smumbers numbers //查看整数集合</code></p><h3 id="1、结构-1"><a href="#1、结构-1" class="headerlink" title="1、结构"></a>1、结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct intset &#123;<br>    <span class="hljs-comment">// 编码方式</span><br>    uint32_t encoding;<br>    <span class="hljs-comment">// contents数组的长度</span><br>    uint32_t length;<br>    <span class="hljs-comment">// 保存元素的数组，也就是set集合</span><br>    int8_t contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><ul><li><p><strong>encoding</strong></p><p>集合采用的编码方式，可以是INSERT_ENC_INT16(int16_t)、INSERT_ENC_INT32(int32_t)、INSERT_ENC_INT64(int64_t)</p></li><li><p><strong>length</strong></p><p>集合的长度，即数组contents的长度</p></li><li><p><strong>contents[]</strong></p><p>数组的真正类型取决于encoding的值，而不是int8_t</p></li></ul><p><img src="/image/redis/redis10.png"></p><h3 id="2、升级"><a href="#2、升级" class="headerlink" title="2、升级"></a>2、升级</h3><p>当我们要将一个新元素添加到整数集合中，且新元素的类型比整数集合现有的所有元素类型都长，整数集合需要先进行升级，然后再添加这个新的元素。</p><p>比如现在整数集合的类型是int16_t，但是要添加的元素的长度类型是int_32t，所以需要先将其升级为int_32t类型。</p><hr><p>当向一个包含三个 <code>int16_t</code> 类型的值**(每个元素占16位)**的整数集合添加一个 <code>int32_t</code> 类型的值时， 整数集合的扩展和转换过程如下。(注意！ 在转换过程中底层数组的有序性不变)</p><p><strong>初始数组状态：</strong></p><p><img src="/image/redis/redis11.png"></p><p>这时，需要将65535添加到整数集合里面，因为int16_t能够表示的范围为(-32768~32767)，无法容纳该数字，所以<strong>需要升级</strong>。</p><p><strong>1、</strong>扩展content的分配的内存空间，由3x16 扩展为 4x32</p><p><img src="/image/redis/redis12.png"></p><p><strong>2、</strong>按照元素索引由高到低的顺序将16位的元素移动至新的位置(32位)。最后添加新插入的元素。</p><p><img src="/image/redis/redis13.png"></p><p><img src="/image/redis/redis14.png"></p><p><img src="/image/redis/redis15.png"></p><p><img src="/image/redis/redis16.png"></p><p>最后，改变intset中encoding和length的值</p><ul><li>encoding由INTSET_ENC_INT16改为INTSET_ENC_INT32</li><li>lentg由3改为4</li></ul><p>最终结果：</p><p><img src="/image/redis/redis17.png"></p><blockquote><p>升级后新元素的位置</p><p>因为新元素的长度大于数组中所有其他元素的长度，所以新元素的值要么大于所有现有元素，要么就小于所有现有元素。</p><ul><li>若为最小值，放在数组开头</li><li>若为最大值，放在数组末尾</li></ul></blockquote><hr><p>升级好处：</p><ol><li>提高灵活性。整数集合可以通过自动升级底层数组来适应新元素，即你可以存放多种类型大小的整数值。</li><li>节约内存。自适应，只有在有大元素需要添加时才会升级为大类型数组。</li></ol><p>整数集合不支持降级操作，一旦升级，就会一直保持这个状态，直到下次升级。</p><h2 id="3-6-压缩列表"><a href="#3-6-压缩列表" class="headerlink" title="3.6 压缩列表"></a>3.6 压缩列表</h2><p><strong>压缩列表(ziplist)是列表键(list)和哈希键(hash)的底层实现之一</strong>。前提是一个列表键只包含少量的列表项，并且每个列表项要么是小的整数值，要么是长度比较短的字符串；或哈希键中只包含少量键值对，并且每个键值对的键和值要么是小整数值，要么是长度比较短的字符串，才会使用压缩列表来实现列表键。</p><p>否则，压缩列表的查询效率会很低。那时就会选择跳表或其他方法来实现列表键和哈希键了。</p><p>ziplist使用<strong>紧凑的连续内存块顺序存储数据</strong>，在list或者hash结构中，未使用listNode（24字节）和dictEntry（24字节）结构体来存储元素项(这些内存占用存储的并不是数据，而是一些定义和指针)，因此会节省内存。</p><h3 id="1、结构-2"><a href="#1、结构-2" class="headerlink" title="1、结构"></a>1、结构</h3><p><img src="/image/redis/redis18.png"></p><ul><li><p><strong>zlbytes</strong>     unit32_t     4字节，用来记录整个压缩列表占用的内存字节数。</p></li><li><p><strong>zltail</strong>      unit32_t      4字节，尾结点到列表起始节点的距离(偏移量)，<strong>一个指向压缩列表起始地址的指针p，则<code>p + zltail</code>就是表尾结点的地址。</strong></p></li><li><p><strong>zlen</strong>        unit16_t    2字节，记录压缩列表中的节点数量，小于65535(2的16次方)时是真实节点的数量，大于等于时，则需要遍历整个列表才可以得到总的节点数量。</p></li><li><p><strong>entryX</strong>      列表节点，每个压缩列表节点可以保存<strong>一个整数值</strong>或者<strong>一个字节数组</strong>。</p><p>​<img src="/image/redis/redis19.png"></p><ul><li><p>previous_entry_length</p><p>单位是字节，记录压缩列表中前一个节点的长度。</p><p>如果前一个节点长度小于254(2的8次方)字节，那该属性的长度为1字节(8bit)，里面保存前一个节点 长度。</p><p>如果前一个节点长度大于等于254字节，则该属性的长度为5字节，属性的第一个字节为0xFE(254)，后面4字节用来保存前一个字节的长度。</p><p>压缩列表的访问是<strong>从表尾到表头</strong>的顺序，因为每个节点中记录了前一个节点的长度，所以当指针指p向当前结点时，则前一个节点的起始地址为<code>p - previous_entry_length</code>，</p></li><li><p>encoding      </p><p>1.记录节点的content属性保存的数据的类型(字节数组还是整数值)和长度。</p><p>最高位为00 or 01 or 10，则content保存的是字节数组，除去这两位，剩下的位表示数组的长度。</p><p>2.最高位是11，则content保存的是整数值，去除这两位，剩余的位数决定整数的类型。</p></li><li><p>content       </p><p>保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p></li></ul></li><li><p><strong>zlend</strong>    unit8_t    1字节，永远等于0xFF，标记压缩列表的末尾</p></li></ul><h3 id="2、连锁更新"><a href="#2、连锁更新" class="headerlink" title="2、连锁更新"></a>2、连锁更新</h3><p>连锁更新就是指添加一个节点导致所有节点的<code>previous_entry_length</code>都要更新的现象。</p><p>一个压缩列表的所有节点的长度在250~253之间，<code>previous_entry_length</code>都是1字节，如果现在添加一个长度大于253字节的节点到表头，那后面的节点的<code>previous_entry_length</code>长度变成5字节，则这个节点的长度超过254字节，则它后面的节点也需要修改，引发<strong>连锁更新</strong>。</p><p>添加新节点到压缩列表或者从压缩列表中删除节点，可能会引发连锁更新操作，不过这种操作出现的几率不高。</p><p>不过由于这种情况很少见，而且假如出现了，只要更新的节点个数不多，也不会产生什么太大的影响。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程-Netty</title>
    <link href="/2022/05/20/Netty/netty/"/>
    <url>/2022/05/20/Netty/netty/</url>
    
    <content type="html"><![CDATA[<p>官网上给Netty的定义是：</p><blockquote><p>Netty is <em>an asynchronous event-driven network application framework</em><br> for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p>即Netty是一个异步的、基于事件驱动的、网络应用框架，是用来快速的开发高性能的客户端和服务器。</p><p>Netty对JDK自带的API进行了封装，解决了使用NIO出现的代码比较繁琐的问题。</p><h1 id="1-线程模型"><a href="#1-线程模型" class="headerlink" title="1.线程模型"></a>1.线程模型</h1><p>目前存在的线程模型有：传统阻塞IO服务模型，Reactor模式。不同的线程模型对程序的性能影响很大。</p><h2 id="1-1-传统阻塞IO服务模型"><a href="#1-1-传统阻塞IO服务模型" class="headerlink" title="1.1 传统阻塞IO服务模型"></a>1.1 传统阻塞IO服务模型</h2><p>其实在上篇讲NIO的时候提到过阻塞IO模型。即阻塞模式下，相关方法都会导致线程暂停。</p><p>比如在实现客户端服务器的时候，服务器监听一个特定端口，相关方法是accpet，如果没有连接，服务器就会一直阻塞到这里，当一个客户端与服务器进行连接时，这个方法才会继续往下运行，然后服务器监听是否有客户端进行写入数据，即read方法，在没有数据可读时会让线程暂停。</p><p>如果在单线程情况下，又来一个客户端想要与服务器进行连接，那么现在就不能进行连接，因为服务器正在read方法处阻塞，等待第一个客户端发送数据，只有当第一个客户端发送完数据，服务器才会处理新的accpet事件。</p><p>在多线程情况下，每次当有连接建立时，服务端都需要创建一个新的线程来处理客户端的业务，但是这样也很不好，因为系统最大的线程数是有限的，对于突发的大量客户端连接不可能创建很多线程去处理连接。并且线程的频繁上下文切换也极度浪费系统资源。</p><p>线程池在一定程度上解决了这个问题</p><h2 id="1-2-Reactor模式"><a href="#1-2-Reactor模式" class="headerlink" title="1.2 Reactor模式"></a>1.2 Reactor模式</h2><h3 id="1-2-1-单Reactor单线程"><a href="#1-2-1-单Reactor单线程" class="headerlink" title="1.2.1 单Reactor单线程"></a>1.2.1 单Reactor单线程</h3><p><img src="/image/netty/reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png"></p><p>Reactor就类似于NIO中的selector，因为服务器线程只有一个，所以是单Reactor，它可以同时监听多路请求，一次性将监听到的事件都取出来然后依次处理。但是如果在处理一个事件时发生阻塞，其他事件还是需要等待。</p><p><strong>优点：</strong>服务器端用<strong>一个线程</strong>通过多路复用完成所有的io操作(连接，读，写等)，模型简单</p><p><strong>缺点：</strong>性能问题，无法发挥多核CPU的性能，服务器线程在处理一个客户端上的事件时，无法处理其他客户端的事件。也不太可靠，如果线程意外终止或者进入死循环，则整个系统通信模块不可以使用，造成节点故障。</p><p>使用NIO实现的聊天室就是单reactor单线程模型。</p><h3 id="1-2-2-单Reactor多线程"><a href="#1-2-2-单Reactor多线程" class="headerlink" title="1.2.2 单Reactor多线程"></a>1.2.2 单Reactor多线程</h3><p><img src="/image/netty/reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png"></p><p>服务器通过select监听客户端请求事件，将不同的请求分发给不同的线程处理。</p><p><strong>优点：</strong>可以充分利用多核CPU的处理能力</p><p><strong>缺点：</strong>多线程数据共享和访问比较复杂，reactor处理所有事件的监听和响应，是在单线程下运行的，在高并发场景下容易出现性能瓶颈。</p><h3 id="1-2-3-主从Reactor多线程"><a href="#1-2-3-主从Reactor多线程" class="headerlink" title="1.2.3 主从Reactor多线程"></a>1.2.3 主从Reactor多线程</h3><p><img src="/image/netty/%E4%B8%BB%E4%BB%8EReactor.png"></p><p>可以有多个reactor子线程</p><p><strong>优点：</strong>父线程与子线程的数据交互简单，Reactor父线程只需要接收新连接，子线程完成后序的业务处理。</p><p><strong>缺点：</strong>编程复杂度高</p><h1 id="2-Netty"><a href="#2-Netty" class="headerlink" title="2.Netty"></a>2.Netty</h1><p>netty主要基于主从Reactor(反应器)多线程模型，并做了一定改进</p><p>以下是netty中重要的组件</p><h2 id="2-1-Channel"><a href="#2-1-Channel" class="headerlink" title="2.1 Channel"></a>2.1 Channel</h2><p>Netty不直接使用java nio中的Channel组件，而是对Channel组件进行了自己的封装。服务器编程应用中使用最多的是通信协议是TCP，对应的netty传输通道类型是NioSocketChannel类，netty服务器监听通道类型为NioServerSocketChannel。</p><p>在netty的NioSocketChannel内部封装了一个java nio的SelectableChannel成员，对NioSocketChannel通道上的所有io操作最终都会落地到java nio 中的SelectableChannel底层通道。</p><p>一个Channel绑定一个EventLoop，以后的所有关于这个channel的请求处理的事件都是由绑定的EventLoop接收。</p><h2 id="2-2-EventLoop"><a href="#2-2-EventLoop" class="headerlink" title="2.2 EventLoop"></a>2.2 EventLoop</h2><p>EventLoop，即事件循环，是一个单线程执行器，其中维护了一个Selector，里面有run方法处理Channel上源源不断的io事件。</p><p>EventLoopGroup是一组EventLoop，即事件循环组，Channel会调用EventLoopGroup的register方法来绑定其中的一个EventLoop，以后这个channel上的io事件都由此EventLoop来处理。<strong>一个EventLoop可以管理多个Channel</strong></p><h3 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建事件循环组,可以处理io事件、普通事件、定时事件</span><br><span class="hljs-comment">//每个事件循环是一个线程</span><br><span class="hljs-comment">//selector+线程池</span><br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioEventLoopGroup</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//所以如果不指定事件循环对象的个数，默认创建的个数是NettyRuntime.availableProcessors() * 2个，即cpu的核心数×2</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_EVENT_LOOP_THREADS</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>    <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、处理普通事件、定时事件"><a href="#2、处理普通事件、定时事件" class="headerlink" title="2、处理普通事件、定时事件"></a>2、处理普通事件、定时事件</h3><p><strong>处理普通任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEventLoop</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>);<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 输出结果：说明只有两个EventLoop</span><br><span class="hljs-comment">         * io.netty.channel.nio.NioEventLoop@4facf68f</span><br><span class="hljs-comment">         * io.netty.channel.nio.NioEventLoop@76508ed1</span><br><span class="hljs-comment">         * io.netty.channel.nio.NioEventLoop@4facf68f</span><br><span class="hljs-comment">         * io.netty.channel.nio.NioEventLoop@76508ed1</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">//通过EventLoop执行普通任务</span><br>        group.next().execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;event&quot;</span>);<br>        &#125;);<br><br>        group.next().execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;event2&quot;</span>);<br>        &#125;);<br><br>        group.next().execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;event3&quot;</span>);<br>        &#125;);<br><br>        log.debug(<span class="hljs-string">&quot;main&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 17:06:22.731 [nioEventLoopGroup-2-1] DEBUG vickkkyz.TestEventLoop - event</span><br><span class="hljs-comment">         * 17:06:22.731 [nioEventLoopGroup-2-2] DEBUG vickkkyz.TestEventLoop - event2</span><br><span class="hljs-comment">         * 17:06:22.732 [main] DEBUG vickkkyz.TestEventLoop - main</span><br><span class="hljs-comment">         * 17:06:22.732 [nioEventLoopGroup-2-1] DEBUG vickkkyz.TestEventLoop - event3</span><br><span class="hljs-comment">         */</span><br>        <br>         优雅地关闭<br>         group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>处理定时任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEventLoop</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//通过EventLoop执行普通任务</span><br>        group.next().scheduleAtFixedRate(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;event&quot;</span>);<br>        &#125;,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br>        log.debug(<span class="hljs-string">&quot;main&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 17:09:50.779 [main] DEBUG vickkkyz.TestEventLoop - main</span><br><span class="hljs-comment">         * 17:09:50.780 [nioEventLoopGroup-2-1] DEBUG vickkkyz.TestEventLoop - event</span><br><span class="hljs-comment">         * 17:09:51.781 [nioEventLoopGroup-2-1] DEBUG vickkkyz.TestEventLoop - event</span><br><span class="hljs-comment">         * 17:09:52.775 [nioEventLoopGroup-2-1] DEBUG vickkkyz.TestEventLoop - event</span><br><span class="hljs-comment">         * 17:09:53.778 [nioEventLoopGroup-2-1] DEBUG vickkkyz.TestEventLoop - event</span><br><span class="hljs-comment">         * 17:09:54.776 [nioEventLoopGroup-2-1] DEBUG vickkkyz.TestEventLoop - event</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、处理IO事件"><a href="#3、处理IO事件" class="headerlink" title="3、处理IO事件"></a>3、处理IO事件</h3><p>io事件就是客户端服务器事件。客户端发送数据，服务器接收数据。</p><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>            .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>            .channel(NioSocketChannel.class)<br>            .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                &#125;<br>            &#125;)<br>            .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>            .sync()<br>            .channel();<br>        System.out.println(channel);<br>        <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>服务器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>            .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>            .channel(NioServerSocketChannel.class)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                            log.debug(buf.toString(StandardCharsets.UTF_8));<br>                            <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;)<br>            .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、分工"><a href="#3、分工" class="headerlink" title="3、分工"></a>3、分工</h3><p>创建两个EventLoopGroup，一个只负责accept事件(称为boss)，另一个负责读写事件(称为worker)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//启动器，负责装配netty组件，将它们组合起来，启动服务器</span><br><span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><span class="hljs-comment">//创建 NioEventLoopGroup组件()，第一个是boss，第二个是worker</span><br><span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">group1</span> <span class="hljs-operator">=</span> serverBootstrap.group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>());<br></code></pre></td></tr></table></figure><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理,只需要将这个eventLoop的处理结果传递给这个非NioEventLoop处理即可(DefaultEventLoop)</p><p><img src="/image/netty/netty1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventLoop</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                                log.debug(buf.toString(StandardCharsets.UTF_8));<br>                                <span class="hljs-comment">// 调用下一个handler</span><br>                                ctx.fireChannelRead(msg);<br>                            &#125;<br>                        &#125;).addLast(group,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                                log.debug(buf.toString(StandardCharsets.UTF_8));<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 18:49:28.514 [nioEventLoopGroup-3-2] DEBUG vickkkyz.Server - 1</span><br><span class="hljs-comment"> * 18:49:28.514 [defaultEventLoop-1-1] DEBUG vickkkyz.Server - 1</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="4、如何切换EventLoop"><a href="#4、如何切换EventLoop" class="headerlink" title="4、如何切换EventLoop"></a>4、如何切换EventLoop</h3><p>channelRead事件的传播流程, channelRead方法是在AbstractChannelHandlerContext类的invokeChannelRead方法中被调用。这里会判断当前handler和下一个handler是否是同一个，如果是，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelRegistered</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeChannelRegistered();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                next.invokeChannelRegistered();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-Future-Promise"><a href="#2-3-Future-Promise" class="headerlink" title="2.3 Future &amp; Promise"></a>2.3 Future &amp; Promise</h2><h2 id="2-4-Handler-Pipeline"><a href="#2-4-Handler-Pipeline" class="headerlink" title="2.4 Handler &amp; Pipeline"></a>2.4 Handler &amp; Pipeline</h2><h2 id="2-5-ByteBuf"><a href="#2-5-ByteBuf" class="headerlink" title="2.5 ByteBuf"></a>2.5 ByteBuf</h2>]]></content>
    
    
    <categories>
      
      <category>Java-网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty</tag>
      
      <tag>NIO</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2022/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/KMP/"/>
    <url>/2022/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1.发现问题"></a>1.发现问题</h1><p>给定一个字符串s1 “aaaaaab”，以及一个模式字符串s2  “aaab”，如果要判断字符串2是否是字符串1的子串，即两个字符串是否匹配，正常情况下，我们会挨个比较，比如先判断s1[0]&#x3D;&#x3D;s2[0]，然后判断s1[1]&#x3D;&#x3D;s2[1]，然后是s1[2]&#x3D;&#x3D;s2[2]，然后是s1[3]!&#x3D;s2[3]，所以我们会从s1的第二个位置为起始位置，重新开始比较，即s1[1] &#x3D;&#x3D; s2[0], s1[2]&#x3D;&#x3D;s2[1], s1[3]&#x3D;&#x3D;s2[2], s1[4]!&#x3D;s2[3]，然后会从s1的第三个位置为起始位置开始比较，……..，最终，时间复杂度是O(mn)，m是s1的长度，n是s2的长度。</p><p><img src="/image/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE.jpg"></p><hr><h1 id="2-找到规律"><a href="#2-找到规律" class="headerlink" title="2.找到规律"></a>2.找到规律</h1><p>上面这个例子我们可以发现，字符串的某些部分被重复比较了很多次，每次失败都是重头开始。我们发现其实只需要比较部分字符串即可，那些前缀后缀相等的字符就不用比较了。比如<code>acbacx..</code>和<code>acbaca...</code>，比较到字符x和字符a时，不相等，按照我们前缀和后缀相等，就直接跳过前缀，直接比较后缀。即直接从串1的x字符和串2的b字符开始比较，即比较<code>acx...</code>和<code>acbaca...</code></p><h1 id="3-如何求最长前缀后缀数组"><a href="#3-如何求最长前缀后缀数组" class="headerlink" title="3.如何求最长前缀后缀数组"></a>3.如何求最长前缀后缀数组</h1><p>前缀后缀数组的特点是前缀和后缀的字符相等，比如<code>acbac</code>的前缀后缀是<code>ac</code>，所以这个字符的最长前缀后缀就是<code>ac</code>。所以每个数组元素的值就是以当前位置index对应字符结尾的字符串的最长前缀后缀的长度。</p><p>比如<code>acbac</code>的最长前缀后缀数组为[0,0,0,1,2]  (index&#x3D;0位置默认为0)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] computeTemporaryArray(<span class="hljs-type">char</span> pattern[])&#123;<br>    <span class="hljs-type">int</span> [] lps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[pattern.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt; pattern.length;)&#123;<br>        <span class="hljs-keyword">if</span>(pattern[i] == pattern[index])&#123;<br>            lps[i] = index + <span class="hljs-number">1</span>;<br>            index++;<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span>)&#123;<br>                index = lps[index-<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                lps[i] =<span class="hljs-number">0</span>;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lps;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4.KMP算法"></a>4.KMP算法</h1><p>利用前缀后缀数组，避免当不匹配时重新从模式字符串的头部开始匹配，也避免了从给定字符串的匹配位置的下一个位置开始。时间复杂度是O(m+n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">KMP</span><span class="hljs-params">(<span class="hljs-type">char</span> []text, <span class="hljs-type">char</span> []pattern)</span>&#123;<br><br>    <span class="hljs-type">int</span> lps[] = computeTemporaryArray(pattern);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; text.length &amp;&amp; j &lt; pattern.length)&#123;<br>        <span class="hljs-keyword">if</span>(text[i] == pattern[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>)&#123;<br>                j = lps[j-<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j == pattern.length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码参考：<a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/string/SubstringSearch.java">https://github.com/mission-peace/interview/blob/master/src/com/interview/string/SubstringSearch.java</a></p></blockquote><h1 id="5-例子"><a href="#5-例子" class="headerlink" title="5.例子"></a>5.例子</h1><p><img src="/image/leetcode/kmp1.jpg"></p><p><img src="/image/leetcode/kmp2.jpg"></p><p><img src="/image/leetcode/kmp3.jpg"></p><hr>]]></content>
    
    
    <categories>
      
      <category>DateStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程-NIO</title>
    <link href="/2022/04/27/Java/IO/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/27/Java/IO/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>网络编程实际上是进程间的通信。</p><h1 id="1-IO"><a href="#1-IO" class="headerlink" title="1.IO"></a>1.IO</h1><p><img src="/image/netty/1.png"></p><p>计算机处理数据的基本单位是字节。如果我们想要表示一个字符，比如char类型的，就需要使用2个字节表示，或者汉字，在utf8编码中需要3个字节表示。为了让计算机能直接处理字符，io流中就提供了字符流，即<strong>数据源是字符</strong>，在计算机中再把这些字符转换成字节进行处理。</p><hr><p><strong>字符流</strong></p><p><img src="/image/netty/2.png"></p><p>CharArrayReader，数据源是字符数组，从这里读取数据。</p><p>CharArrayWriter，数据源是字符数组，往里面写入数据</p><p><img src="/image/netty/3.png"></p><hr><p><strong>字节流</strong></p><p><img src="/image/netty/4.png"></p><p><img src="/image/netty/5.png"></p><h1 id="2-NIO"><a href="#2-NIO" class="headerlink" title="2.NIO"></a>2.NIO</h1><p>即非阻塞(non-blocking) IO，也可以叫做new IO </p><h2 id="2-1-三大组件"><a href="#2-1-三大组件" class="headerlink" title="2.1 三大组件"></a>2.1 三大组件</h2><h3 id="2-1-1-Channel"><a href="#2-1-1-Channel" class="headerlink" title="2.1.1 Channel"></a>2.1.1 Channel</h3><p>Channel：读写数据的双向通道，可以从channel中将数据读取数据，即向buffer中写入数据，也可以将buffer中的数据写入Channel。</p><p><strong>常见的Channel有以下四种</strong>，其中FileChannel主要用于文件传输，其余三种用于网络通信</p><ul><li>FileChannel(只能工作在阻塞模式)</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//阻塞模式下........</span><br><span class="hljs-comment">//一个方法的调用会影响其他的方法</span><br><br><span class="hljs-comment">//下面都是在服务器中的逻辑</span><br><span class="hljs-comment">//服务器通道</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocketChannel</span>();<br><span class="hljs-comment">//绑定监听端口</span><br>serverChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><span class="hljs-comment">//开始监听..</span><br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> serverChannel.accpet();<span class="hljs-comment">//阻塞方法，线程会停止运行，等待一个新连接的建立，只要没有新连接，就会一直等待</span><br><span class="hljs-comment">//将clientChannel通道中的数据读出来，写入服务器端的buffer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> clientChannel.read(buffer);<span class="hljs-comment">//阻塞方法，只要没有客户端向服务器发送数据就会阻塞</span><br></code></pre></td></tr></table></figure><p>Channel可以是阻塞的，也可以是非阻塞的，默认是阻塞的，可以将ServerSocketChannel手动设置为非阻塞模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非阻塞模式下.........</span><br>serverChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>...<br><span class="hljs-comment">//现在如果没有连接建立，返回的是null，非阻塞，线程会继续往下运行</span><br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> serverChannel.accpet();<br>...<br><span class="hljs-comment">//将客户端通道也设置为非阻塞，那当调用该通道的read的时候，也不会阻塞，线程仍然会继续运行，如果没有读到数据，read返回0</span><br>clientChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> clientChannel.read(buffer);<br></code></pre></td></tr></table></figure><h3 id="2-1-2-ByteBuffer"><a href="#2-1-2-ByteBuffer" class="headerlink" title="2.1.2 ByteBuffer"></a>2.1.2 ByteBuffer</h3><p><strong>Buffer迎来缓冲读写数据，支持不同数据类型的缓冲区，有以下几种</strong>，其中使用较多的是ByteBuffer</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><hr><p>所以下面都以ByteBuffer为例</p><h4 id="2-1-2-1-属性"><a href="#2-1-2-1-属性" class="headerlink" title="2.1.2.1 属性"></a>2.1.2.1 属性</h4><p>ByteBuffer中重要的属性：<strong>capacity</strong>(缓冲区容量)，<strong>position</strong>(当前的读写位置指针，指向下一次要读写的位置)，<strong>limit</strong>(读入写入限制大小指针)</p><p><img src="/image/netty/bytebuffer.png"></p><p>bytebuffer默认是写模式，当写入数据后，flip()切换为<strong>读模式</strong></p><p><img src="/image/netty/bytebuffer2.png"></p><p> clean()是切换<strong>写模式</strong>从头开始写，不管上次是否读完</p><p><img src="/image/netty/bytebuffer3.png"></p><p>compact()也是切换为<strong>写模式</strong>，会把上次未读完的放到缓冲区前面</p><hr><p>反正始终记住，读前面先切换为读模式，写前切换为写模式</p><h4 id="2-1-2-2-常见方法"><a href="#2-1-2-2-常见方法" class="headerlink" title="2.1.2.2 常见方法"></a>2.1.2.2 常见方法</h4><ol><li><p>allocate(大小)</p><p><strong>创建buffer并给buffer分配空间。</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuffer buffer <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>)<span class="hljs-comment">; //HeapByteBuffer</span><br>ByteBuffer byteBuffer <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">16</span>)<span class="hljs-comment">;//DirectByteBuffer</span><br></code></pre></td></tr></table></figure><p>HeapByteBuffer(使用java堆内存分配空间，读写效率低，会受到GC影响)</p><p>DirectByteBuffer(使用直接内存分配空间，读写效率高，不会受到GC影响)</p></li><li><p>read()&#x2F;put()</p><p><strong>向buffer写入数据。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// readBytes实际读到的字节数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readByets</span> <span class="hljs-operator">=</span> channel.read(buffer);<span class="hljs-comment">//从通道中读取数据，写入buffer</span><br>buffer.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<span class="hljs-comment">//调用buffer自己的put方法</span><br></code></pre></td></tr></table></figure></li><li><p>write()&#x2F;get()</p><p><strong>从buffer中读取数据。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//writeBytes实际写入channel的字节数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buffer);<span class="hljs-comment">//从buffer中读数据，写入通道中</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buffer.get();<span class="hljs-comment">//会让position读指针向后移动一位，get(i)只会获取索引为i的数，而不会移动指针，rewind(),把position置0，重新读</span><br></code></pre></td></tr></table></figure></li><li><p>bytebuffer和字符串的转换</p><p><img src="/image/netty/bytebuffer4.png"></p><p>第一种方法将字符串放入buffer后，buffer还是写模式，如果想读，需要切换为读模式。</p><p>第二种和第三种添加完会自动改为读模式。</p></li></ol><h3 id="2-1-3-Selector"><a href="#2-1-3-Selector" class="headerlink" title="2.1.3 Selector"></a>2.1.3 Selector</h3><p>管理Channel并监听Channel上是否有事件发生</p><p>1.阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br></code></pre></td></tr></table></figure><p>2.阻塞直到绑定事件发生，或者超时，事件单位是ms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select(Long timeout);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多路复用.........</span><br><br><span class="hljs-comment">//创建buffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>); <span class="hljs-comment">//HeapByteBuffer</span><br><span class="hljs-comment">//创建channel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocketChannel</span>();<br>serverChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">//创建selector，管理多个channel</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">//建立selector与channel的联系，即将channel注册在selector上</span><br><span class="hljs-comment">//SelectionKey唯一绑定一个channel，通过它可以 知道事件和哪个channel的事件</span><br>  <span class="hljs-comment">//0表示不关注任何事件</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">serverKey</span> <span class="hljs-operator">=</span> serverChannel.register(selector,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//表示这个key只关注accept事件</span><br>serverKey.interestOps(SelectionKey.OP_ACCEPT);<br><span class="hljs-comment">//绑定监听端口</span><br>serverChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">//开始监听，没有事件发生，线程阻塞，有事件，线程才会运行</span><br>    <span class="hljs-comment">//在事件未处理时，不会阻塞，会重新将事件放到selectionKeys中，让服务器处理</span><br>    selector.select();<br>    <span class="hljs-comment">//被触发的事件集合</span><br>    <span class="hljs-comment">//在发生事件后selector会往selectionKeys里面加事key，但是不会删除</span><br>selectionKeys = selector.selectedKeys();<br>    <span class="hljs-keyword">for</span> (SelectionKey key :<br>         selectionKeys) &#123;<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            <span class="hljs-comment">//获得事件对应的channel</span><br>            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverChannel</span> <span class="hljs-operator">=</span> key.channel();<br>            <span class="hljs-comment">//服务器端处理事件</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> serverChannel.accpet();<br>            clientChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>); <br>            <span class="hljs-comment">//attachment,附件，将bytebuffer作为附件关联到clientKey上</span><br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">clientKey</span> <span class="hljs-operator">=</span> clientChannel.register(selector,<span class="hljs-number">0</span>,buffer);<br>            clientChannel.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">//key.cancel();把事件取消</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isReadable())&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//当前是读事件，说明客户端向服务器发送数据了</span><br>                <span class="hljs-comment">//拿到触发事件的channel</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                <span class="hljs-comment">//获取key上关联的附件</span><br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer)key.attachment();<br>                <span class="hljs-comment">//将客户端通道中的数据写入服务器端的buffer</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> clientChannel.read(buffer);<br>                <span class="hljs-comment">//如果是正常断开，read的值为-1</span><br>                <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>)&#123;<br>                    key.cancel();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//正常情况，没有断开，buffer切换为读模式</span><br>                    buffer.flip();<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>                e.printStackTrace();<br>                key.channel();<span class="hljs-comment">//异常断开。因为客户端断开，因此需要将key取消</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//处理完key集合后，需要删除</span><br>    selectionKeys.clear();<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>事件种类</strong>：</p><p>accpet：会在有连接请求时触发</p><p>connect：是客户端，连接建立时触发</p><p>read：可读事件</p><p>write：可写事件</p><hr><p><img src="/image/netty/selector.png"></p><h2 id="2-2-阻塞-非阻塞-多路复用"><a href="#2-2-阻塞-非阻塞-多路复用" class="headerlink" title="2.2 阻塞&amp;非阻塞&amp;多路复用"></a>2.2 阻塞&amp;非阻塞&amp;多路复用</h2><p><img src="/image/netty/%E9%98%BB%E5%A1%9E.png"></p><p>阻塞模式下，一个方法会影响其他方法，阻塞住无法继续运行。</p><p><img src="/image/netty/%E9%9D%9E%E9%98%BB%E5%A1%9E.png"></p><p>非阻塞模式下，如果没有事件发生，也会继续运行，会一直进行空循环，非常浪费cpu性能</p><p><img src="/image/netty/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p><p>多路复用模式下，只有事件发生了，selector.select()才会继续运行，处理事件，如果没有事件，这里会阻塞住，不会让事件白忙活~</p><blockquote><p>引用：<a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=39&spm_id_from=pageDriver">https://www.bilibili.com/video/BV1py4y1E7oA?p=39&amp;spm_id_from=pageDriver</a></p></blockquote><h2 id="2-3-Stream-vs-Channel"><a href="#2-3-Stream-vs-Channel" class="headerlink" title="2.3 Stream vs Channel"></a>2.3 Stream vs Channel</h2><ol><li>strean不会自动缓冲数据，channel会利用系统提供的发送缓冲区和接受缓冲区，将通道中的数据暂存到缓冲区中</li><li>stream仅支持阻塞模式，channel可以支持阻塞和非阻塞，网络channel可以配合selector实现多路复用</li><li>二者均为全双工，即读写可以同时进行</li></ol><h2 id="2-4-IO模型"><a href="#2-4-IO模型" class="headerlink" title="2.4 IO模型"></a>2.4 IO模型</h2><p>当用户调用一次channel.read(没有设置为非阻塞的情况)或stream.read时，会切换到操作系统内核来完成数据的真正读取，而读取又分为等待数据和复制数据阶段。</p><h3 id="2-4-1-阻塞IO"><a href="#2-4-1-阻塞IO" class="headerlink" title="2.4.1 阻塞IO"></a>2.4.1 阻塞IO</h3><p>用户线程阻塞住，阻塞IO在做一件事的时候不能做另一件事</p><p><img src="/image/netty/%E9%98%BB%E5%A1%9EIO.png"></p><h3 id="2-4-2-非阻塞IO"><a href="#2-4-2-非阻塞IO" class="headerlink" title="2.4.2 非阻塞IO"></a>2.4.2 非阻塞IO</h3><p>在等待数据阶段，用户线程会一直询问是否有数据，如果没有就会返回0，然后继续询问，这之间多次进行用户态和内核态的切换，非常耗费CPU性能，当有数据后，还是会阻塞住，等待内核复制数据。</p><p><img src="/image/netty/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png"></p><h3 id="2-4-3-多路复用"><a href="#2-4-3-多路复用" class="headerlink" title="2.4.3 多路复用"></a>2.4.3 多路复用</h3><p><img src="/image/netty/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO.png"></p><hr><p>多路复用和阻塞IO的区别</p><p><img src="/image/netty/%E9%98%BB%E5%A1%9EIO2.png"></p><p><img src="/image/netty/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO2.png"></p><hr><h3 id="2-4-4-同步和异步"><a href="#2-4-4-同步和异步" class="headerlink" title="2.4.4 同步和异步"></a>2.4.4 同步和异步</h3><p>同步：线程自己去获取结果(只有一个线程)</p><p>异步：线程自己不去获取结果，而是由其他线程送结果(至少两个线程)</p><p>上面三种都是同步的，即由线程自己发起的动作，也是由它主动接收结果。</p><p>异步：用户线程自己发起动作，并且由操作系统调用回调方法，由操作系统将最终的结果通过回调方法返回给用户线程。如图：</p><p><img src="/image/netty/%E5%BC%82%E6%AD%A5IO.png"></p><h2 id="2-5-零拷贝"><a href="#2-5-零拷贝" class="headerlink" title="2.5 零拷贝"></a>2.5 零拷贝</h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存(用户缓冲区)中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><hr><p><strong>传统io</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()];<br>file.read(buf);<br><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ...;<br>socket.getOutputStream().write(buf);<br></code></pre></td></tr></table></figure><p><img src="/image/netty/%E9%9B%B6%E6%8B%B7%E8%B4%9D1.png"></p><hr><p><strong>NIO优化</strong></p><p>ByteBuffer.<strong>allocateDirect</strong>(10)  </p><ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul><p><strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><p>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</p><p><img src="/image/netty/%E9%9B%B6%E6%8B%B7%E8%B4%9D2.png"></p><hr><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p><strong>①</strong>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo&#x2F;transferFrom</strong> 方法拷贝数据</p><p><img src="/image/netty/%E9%9B%B6%E6%8B%B7%E8%B4%9D3.png"></p><p><strong>②linux 2.4</strong> 对上述方法再次进行了优化</p><p><img src="/image/netty/%E9%9B%B6%E6%8B%B7%E8%B4%9D4.png"></p>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
      <tag>总结</tag>
      
      <tag>BIO</tag>
      
      <tag>AIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-java内存模型</title>
    <link href="/2022/04/18/Java/JUC/JMM/"/>
    <url>/2022/04/18/Java/JUC/JMM/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JMM"><a href="#1-JMM" class="headerlink" title="1.JMM"></a>1.JMM</h1><p><strong>java内存模型</strong>：JMM是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序，如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。</p><p><code>JMM最重要的3点内容是：原子性，可见性，有序性。</code></p><p>jvm内存结构：堆、虚拟机栈、方法区、本地方法栈、程序计数器</p><p>java对象模型：java对象自身的存储模型，是一个逻辑抽象。</p><blockquote><p>JMM的抽象：<strong>主内存和工作内存</strong>(这仅仅是JMM中的概念)</p><p>主存和工作内存的关系</p><ol><li><p>所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝。</p></li><li><p>线程不能直接读写主内存中的变量,而是只能操作自己工作内存中的变量，然后再同步到主内存中。</p></li><li><p>主内存是多个线程共享的，但线程间不共享工作内存,如果线程间需要通信，必须借助主内存中转来完成。</p></li><li><p>所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。</p></li></ol></blockquote><p>volatile、synchronized、Lock等的原理都是JMM</p><h1 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2.原子性"></a>2.原子性</h1><p>保证指令不会收到线程上下文切换的影响。最明白的体现就是synchronized，线程拿着锁，其他线程不能访问临界区的代码。</p><h1 id="3-可见性"><a href="#3-可见性" class="headerlink" title="3.可见性"></a>3.可见性</h1><p>保证指令不会受到CPU缓存的影响。</p><p>如下代码中子线程不会停止运行，因为main函数对run值的修改对子线程不可见。为什么会不可见呢？是因为每当子线程执行的时候都会去<strong>主内存</strong>中读取run的值，即时编译器觉得太麻烦了，就将run的值缓存到线程的工作内存中，每次从这里读取，因此主线程修改了主内存中run的值，并不会改变工作内存中run的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">//如果run为真，则一直执行</span><br>&#125;<br>&#125;).start();<br><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>run = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>如何解决？</font></p><p>在变量前面加上volatile关键字(易变)，这样子线程就不会将run缓存到工作内存中了，而是每次都需要去主内存中读取。</p><blockquote><p>volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为。</p></blockquote><p><code>volatile</code>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量就是直接操作主存。</p><p>volatile最好用在一个线程写，多个线程读的情况，因为它无法保证原子性。</p><p>synchronized语句块既可以保证代码块的原子性，也可以保证代码块内变量的可见性，但全店是synchronized属于重量级操作，性能低。</p><h1 id="4-有序性"><a href="#4-有序性" class="headerlink" title="4.有序性"></a>4.有序性</h1><p>保证指令不会受到CPU指令并行优化的影响。</p><p>指令重排序是因为CPU底层会将指令并行处理，以达到最大效率。流水线模式</p><p>JVM 在<strong>不影响正确性</strong>的前提下，会<strong>调整</strong>语句的执行<strong>顺序</strong>，进行指令重排。<strong>多线程下『指令重排』会影响正确性</strong>。</p><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排，保证有序性。</p><h1 id="5-volatile原理"><a href="#5-volatile原理" class="headerlink" title="5.volatile原理"></a>5.volatile原理</h1><h2 id="5-1-volatile可见性底层如何实现"><a href="#5-1-volatile可见性底层如何实现" class="headerlink" title="5.1 volatile可见性底层如何实现"></a>5.1 volatile可见性底层如何实现</h2><p>不同的物理CPU硬件所提供的内存屏障指令差异很大， JMM定义了一套相对独立的内存屏障指令，用于屏蔽不同硬件的差异，然后在volatile关键字中包含这些指令。然后在不同的硬件平台上，JMM内存屏障指令会要求jvm为不同平台生成相应的硬件层的内存屏障指令。</p><p><strong>比如</strong>在X86处理器上，volatile被JVM编译过之后，它的汇编代码中会被插入一条lock addl 前缀指令，来实现全屏障的目的。</p><p>lock addl指令的作用：</p><ol><li><p>将当前CPU缓存行(在JMM中是工作内存)的数据立即写回系统内存(在JMM中是主存)</p></li><li><p>lock指令会引起在其他CPU中缓存了该内存地址的数据无效</p></li><li><p>lock前缀指令禁止指令重排(作为内存屏障)</p></li></ol><h2 id="5-2-重排序"><a href="#5-2-重排序" class="headerlink" title="5.2 重排序"></a>5.2 重排序</h2><p><img src="/image/juc/%E9%87%8D%E6%8E%92%E5%BA%8F.jpg" alt="重排序"></p><p>主要是CPU重排序导致的数据不一致问题。</p><ul><li><p>指令级重排序</p><p>在不影响执行结果的情况下，CPU内核采用ILP指令级并行运算技术来将多条指令重叠执行，前提是指令之间不存在数据依赖性。</p><p>编译器和CPU都遵循As-if-Serial规则，即可以保证在单核CPU执行下他们不会对有数据依赖的指令进行重排序，但是多核并发的情况下，CPU的一个内核无法分辨其他内核上指令序列的数据依赖关系，因此可能会乱序执行。</p></li><li><p>内存系统重排序</p><p>内存重排序实际上并不是真的相关操作被排序了，而是因为CPU引入缓存还没来得及刷新导致。</p><p>每个CPU都有自己的缓存，为了提高共享变量的写操作，CPU把整个操作变成异步的了，如果写入操作还没来的及同步到其它CPU，就有可能发生其它CPU读取到的是旧的值，因此看起来这条指令还没执行一样。</p><blockquote><p>内存重排序这里引用<a href="https://cloud.tencent.com/developer/article/18571747">https://cloud.tencent.com/developer/article/18571747</a></p></blockquote></li></ul><p><strong>所以要加入内存屏障来禁止多线程环境下的指令重排</strong></p><hr><p>硬件层面的内存屏障是如何实现的？</p><p><strong>读屏障：</strong>在<strong>指令前</strong>插入读屏障，可以让高速缓存中的数据失效，强制重新从主存加载数据，并且，读屏障会告诉CPU和编译器，先于这个屏障的指令必须先执行。</p><p><strong>写屏障：</strong>在<strong>指令后</strong>插入写屏障指令能让能让高速缓存中的最新数据更新到主存，让其他线程可见，并且写屏障会告诉CPU和编译器，后于这个屏障的指令必须后执行。</p><p><strong>全屏障：</strong>读屏障+写屏障。</p><p>先于这个屏障的指令必须先执行，后于这个屏障的指令必须后执行，即禁止屏障两侧的指令重排。</p><p>高速缓存的最新数据写回到主存，其他核心的高速缓存中的数据会失效，强制从主存中加载数据。</p><p>volatile关键字修饰的变量，它的读屏障加在这个变量所在行的前面，写屏障加在这个变量所在行的后面。</p><blockquote><p>在X86处理器上，lock前缀指令、mfence指令具有全屏障功能。</p></blockquote><hr><p>volatile的底层实现原理是<strong>内存屏障</strong></p><p><font color='purple '>保证可见性</font></p><ul><li>在读取用volatile修饰的变量时，在这一行前面加上读屏障，则jvm对共享变量的读取，加载的是主存中的最新数据。</li><li>在给用volatile修饰的变量赋值时，在这一行后面加上写屏障，则对共享变量的改动赋值等都会同步到主存中。</li></ul><blockquote><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote><p><font color='purple '>保证有序性</font></p><ul><li>在读取用volatile修饰的变量时，在这一行前面加上读屏障，则读屏障会确保指令重排时，不会将读屏障之后的代码排在读屏障之前。</li><li>在给用volatile修饰的变量赋值时，在这一行后面加上写屏障，则写屏障会保证指令重排时，不会将写屏障之前的代码排在写屏障之后。</li></ul><blockquote><p>另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p></blockquote><p><img src="/image/juc/volatile.jpg"></p><p>StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中；并禁止上面的普通写和volatile写进行重排序。<br>StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序<br>LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序<br>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序</p><blockquote><p>Load是读屏障，Store是写屏障</p></blockquote><p>还有一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。</p><h2 id="5-3-为什么volatile不保证原子性？"><a href="#5-3-为什么volatile不保证原子性？" class="headerlink" title="5.3 为什么volatile不保证原子性？"></a>5.3 为什么volatile不保证原子性？</h2><p><img src="/image/juc/%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7.jpg"></p><p>现在有两个线程，都对value自增1，最终结果应该是2，但是实际上并不是。</p><p>他们都将value&#x3D;0读取到了自己的工作内存，然后线程A将value改为1，但还没有进行写入主存，此时线程B拿到时间片，将value改为1并写入主存，再到线程A，它将脏数据1写入到了主存，最终value的值是1</p><h2 id="5-4-Happens-Before规则"><a href="#5-4-Happens-Before规则" class="headerlink" title="5.4 Happens-Before规则"></a>5.4 Happens-Before规则</h2><p>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 <strong>happens-before  原则</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><p>　下面就来具体介绍下happens-before原则（先行发生原则）：</p><ul><li>程序次序规则(As-if-serial规则)：同一个线程内，按照代码顺序，对于有依赖关系的语句，书写在前面的操作先行发生于书写在后面的操作，保证了单线程下的有序性。</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，如果线程A执行了线程B的Thread.join并成功，那线程B的任意操作都先行于线程A执行的Thread.join。</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><blockquote><p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-CAS</title>
    <link href="/2022/04/15/Java/JUC/CAS/"/>
    <url>/2022/04/15/Java/JUC/CAS/</url>
    
    <content type="html"><![CDATA[<h1 id="1-乐观锁-悲观锁"><a href="#1-乐观锁-悲观锁" class="headerlink" title="1.乐观锁&#x2F;悲观锁"></a>1.乐观锁&#x2F;悲观锁</h1><p>他们不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p><strong>悲观锁：</strong>总是假设最坏的情况，每次拿数据都认为别人会修改数据，所以当自己进入临界区的时候要加锁，别人只能等待，直到我释放锁才能拿到锁；<code>悲观的认为，不加锁的并发操作一定会出问题。</code><strong>synchronized和ReentrantLock是悲观锁的思想。</strong></p><p><strong>乐观锁：</strong>总是假设最好的情况，每次拿数据都认为别人不会修改数据，所以不会加锁，<code>乐观的认为，不加锁的并发操作是没有事情的。</code>但是更新的时候，会判断在此期间有没有人修改过；一般基于版本号机制实现。乐观锁是无锁的，<strong>乐观锁用到的机制是CAS</strong></p><h1 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2.CAS"></a>2.CAS</h1><p>CAS：compare and set 或者是compare and swap 的缩写，即比较并交换。</p><p>CAS 体现的是<strong>无锁并发、无阻塞并发</strong></p><ul><li>因为没有使用 synchronized，所以<code>线程不会陷入阻塞</code>，这是效率提升的因素之一 </li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul><p>CAS需要借助volatile才能得到共享变量的最新值，试下无锁并发。适用于线程数少，多核CPU的场景下。</p><p><code>无锁并发</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">compareAndSet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(count);<br><br>    <span class="hljs-comment">//减去acount</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Integer acount)</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//获取最新值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> count.get();<br>            <span class="hljs-comment">//修改后的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newNum</span> <span class="hljs-operator">=</span> prev - acount;<br>            <span class="hljs-comment">//compareAndSet：比较prev和主存中的值是否一样，如果一样，就设置newNum为现在的值，否则不修改（因为已经有其他线程修改了这个共享变量的值）</span><br>            <span class="hljs-keyword">if</span>(count.compareAndSet(prev,newNum))&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>CAS是一种无锁算法，该算法的关键依赖两个值，期望的旧值和新值，底层CPU利用<strong>原子操作</strong>判断内存原值与期望值是否相等**(正因为该指令具备原子性，所以使用CAS操作数据时不会造成数据不一致的问题)**，如果相等就给内存地址赋新值，否则不做任何处理。</p><p>下面这些使用CAS机制实现的操作的原子性的工具类的实现原理是：<strong>底层调用Unsafe提供的相关CAS方法，这些方法封装了底层CPU的CAS操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Object var1：需要操作的字段所在的对象</span><br><span class="hljs-comment">* long var2：需要操作的字段的偏移量，相对于对象头</span><br><span class="hljs-comment">* int var4：期望的旧值</span><br><span class="hljs-comment">* int var5：目标的新值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用于获取静态属性Field在Class对象中的偏移量，还有一个方法objectFieldOffset0是获取非静态属性的偏移量(非静态属性在对象体中)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">staticFieldOffset0</span><span class="hljs-params">(Field var1)</span>;<br></code></pre></td></tr></table></figure><p>可以通过反射调用Unsafe中的CAS方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetUnsafe</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;<br><span class="hljs-comment">// 通过反射获得Unsafe对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">unsafeClass</span> <span class="hljs-operator">=</span> Unsafe.class;<br><span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> unsafeClass.getDeclaredConstructor();<br><span class="hljs-comment">// 设置为允许访问私有内容</span><br>constructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 创建Unsafe对象</span><br><span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) constructor.newInstance();<br><br><span class="hljs-comment">// 创建Person对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-comment">// 获得其属性 name 的偏移量</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(field);<br><br><span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br>unsafe.compareAndSwapObject(person, offset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Nyima&quot;</span>);<br>System.out.println(person);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br> <span class="hljs-keyword">volatile</span> String name;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br><span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br><span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-使用CAS机制实现的工具类"><a href="#3-使用CAS机制实现的工具类" class="headerlink" title="3.使用CAS机制实现的工具类"></a>3.使用CAS机制实现的工具类</h1><h2 id="3-1-原子整数"><a href="#3-1-原子整数" class="headerlink" title="3.1 原子整数"></a>3.1 原子整数</h2><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ol><p> <strong>只能保证一个共享变量的原子操作</strong></p><p><strong>循环时间长开销大</strong>。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>CAS自旋+volatile实现了线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">U</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 最终调用的是Unsafe类中的CAS方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expectedValue, <span class="hljs-type">int</span> newValue)</span> &#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSetInt(<span class="hljs-built_in">this</span>, VALUE, expectedValue, newValue);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-原子引用"><a href="#3-2-原子引用" class="headerlink" title="3.2 原子引用"></a>3.2 原子引用</h2><ol><li><p>AtomicReference</p><p>传入泛型，指定要保护的对象，AtomicReference<String> str;</p></li><li><p>AtomicMarkableReference</p></li><li><p>AtomicStampedReference</p></li></ol><hr><p><strong>ABA问题：</strong>现在有一个共享变量<code>AtomicReference&lt;String&gt; str = new AtomicReference(&quot;aaa&quot;);</code>  </p><p>首先线程C获取到str的值为”aaa”，线程A将str的值改为”bbb”，线程B将str的值改为”aaa”，当线程C去改时，比较并设置，以为str没有被更改过，所以将值设置为”ccc”，但是实际上它已经被修改了，只是值一样而已。</p><p>如果想达到只要线程修改，本次就不能再修改的原则，则不仅要比较值，还需要比较版本号，每次修改共享变量时版本号就加1。使用<strong>AtomicStampedReference</strong>，追踪原子引用的整个变化过程。</p><p>AtomicMarkableReference使用布尔值来标志共享变量是否被更改过，只使用于知道对象是否被修改过，不使用对象被修改</p><h2 id="3-3-原子数组"><a href="#3-3-原子数组" class="headerlink" title="3.3 原子数组"></a>3.3 原子数组</h2><p>如果我们向修改引用对象内部的内容，而不是对象本身的地址。</p><ol><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ol><hr><p>但是在竞争激烈的场景下，会导致大量的CAS空自旋，由于线程在自旋的过程中并没有阻塞而放弃CPU，因此大量的空自旋会浪费大量的CPU资源，大大降低了程序的性能。</p><p>对于AtomicInteger来说，可以使用LongAdder来代替。</p><h2 id="3-4-LongAdder"><a href="#3-4-LongAdder" class="headerlink" title="3.4 LongAdder"></a>3.4 LongAdder</h2><p>以空间换时间，核心思想是热点分离，将value值分成一个数组，当多线程访问时，通过Hash算法将不同的线程映射到数组的不同元素上进行操作，通过将数组的元素求和来获取最终的value</p><p>LongAdder继承Striped64</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Striped64内的成员变量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Striped64.Cell[] cells;<br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><p>内部成员包含一个base变量和一个cells数组，当没有竞争的时候，只操作base，当线程执行CAS失败，说明有竞争，开始初始化cells数组，每个cell的值为0，每个线程被映射到cells[threadLocalRandomProbe &amp; cells.length]，线程对这个cell进行操作，最终所有cell的和加上base的值就是最终的value</p><p>cells数组第一次初始化容量为2，以后每次扩容变为二倍，最终不能超过CPU核心数。</p><p>cellsBusy是标志cells数组正在初始化或者扩容，为1表示正在创建或者扩容，不能进行新cell元素的设置，其他线程需要阻塞，为0表示没有</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>cas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-Synchronized</title>
    <link href="/2022/04/14/Java/JUC/synchronized/"/>
    <url>/2022/04/14/Java/JUC/synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Synchronized的作用"><a href="#1-Synchronized的作用" class="headerlink" title="1.Synchronized的作用"></a>1.Synchronized的作用</h1><p>Synchronized是同步、在时间上一致的意思。能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。</p><p>Synchronized可以保证数据的<strong>可见性</strong>，即一个线程执行一系列操作后，另一个线程获取到正确的结果。</p><h1 id="2-Synchronized的两个用法"><a href="#2-Synchronized的两个用法" class="headerlink" title="2.Synchronized的两个用法"></a>2.Synchronized的两个用法</h1><h2 id="2-1-对象锁"><a href="#2-1-对象锁" class="headerlink" title="2.1 对象锁"></a>2.1 对象锁</h2><h3 id="2-1-1-方法锁"><a href="#2-1-1-方法锁" class="headerlink" title="2.1.1 方法锁"></a>2.1.1 方法锁</h3><p>在方法签名上加锁，synchronized修饰普通方法，默认锁对象为当前实例对象this。</p><p>如果实例化多个Runnable接口的实现类，那么他们不会互相等待，因为synchronized默认锁对象是当前实例this，而他们现在已经是不同的实例对象了，自然this也不一样了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedPractice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        syn();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syn</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始休眠&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;结束休眠，放弃锁&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这是两个线程同时访问一个对象的同步方法</span><br>        <span class="hljs-type">SynchronizedPractice</span> <span class="hljs-variable">synchronizedPractice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPractice</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synchronizedPractice);<br>        thread1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synchronizedPractice);<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>开始休眠<br>Thread-<span class="hljs-number">0</span>结束休眠，放弃锁<br>Thread-<span class="hljs-number">1</span>开始休眠<br>Thread-<span class="hljs-number">1</span>结束休眠，放弃锁<br></code></pre></td></tr></table></figure><h3 id="2-1-2同步代码块锁"><a href="#2-1-2同步代码块锁" class="headerlink" title="2.1.2同步代码块锁"></a>2.1.2同步代码块锁</h3><p>手动指定锁对象。也可以手动指定this对象为锁对象</p><p>为什么要手动指定呢？因为有可能在业务逻辑中多段代码都是不能同步执行的，但是他们之间又不互相干，所以要分别加锁，而不是全部只加一个锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedPractice2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//synchronized (this)&#123; 这个等同于在方法上加synchronized</span><br>        <span class="hljs-keyword">synchronized</span> (lock1)&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;得到lock1锁，开始休眠&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;结束休眠，马上放弃lock1锁&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (lock2)&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;得到lock2锁，开始休眠&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;结束休眠，马上放弃lock2锁&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedPractice2</span> <span class="hljs-variable">synchronizedPractice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPractice2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synchronizedPractice);<br>        thread1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synchronizedPractice);<br>        thread2.start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>得到lock1锁，开始休眠<br>Thread-<span class="hljs-number">0</span>结束休眠，马上放弃lock1锁<br>Thread-<span class="hljs-number">1</span>得到lock1锁，开始休眠<br>Thread-<span class="hljs-number">0</span>得到lock2锁，开始休眠<br>Thread-<span class="hljs-number">1</span>结束休眠，马上放弃lock1锁<br>Thread-<span class="hljs-number">0</span>结束休眠，马上放弃lock2锁<br>Thread-<span class="hljs-number">1</span>得到lock2锁，开始休眠<br>Thread-<span class="hljs-number">1</span>结束休眠，马上放弃lock2锁<br></code></pre></td></tr></table></figure><h2 id="2-2-类锁"><a href="#2-2-类锁" class="headerlink" title="2.2 类锁"></a>2.2 类锁</h2><p>类锁是对于Class对象的锁。</p><p>一个java类可以有多个实例化对象，但是他们本质都是这个java类，即<strong>只有一个Class对象</strong>。</p><p><strong>类锁的形式：</strong></p><ol><li>synchronized加在这个类的static方法上</li><li>synchronized代码块</li></ol><p>这样就算是这个类的不同的实例对象，类锁对他们都是有效的。</p><p>synchronized代码块的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedPractice3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (SynchronizedPractice3.class)&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;得到类锁，开始休眠&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;结束休眠，马上放弃类锁&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这是两个线程同时访问两个对象的同步方法</span><br>        <span class="hljs-type">SynchronizedPractice3</span> <span class="hljs-variable">synchronizedPractice1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPractice3</span>();<br>        <span class="hljs-type">SynchronizedPractice3</span> <span class="hljs-variable">synchronizedPractice2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPractice3</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synchronizedPractice1);<br>        thread1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synchronizedPractice2);<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>得到类锁，开始休眠<br>Thread-<span class="hljs-number">0</span>结束休眠，马上放弃类锁<br>Thread-<span class="hljs-number">1</span>得到类锁，开始休眠<br>Thread-<span class="hljs-number">1</span>结束休眠，马上放弃类锁<br></code></pre></td></tr></table></figure><p><strong>方法抛出异常后会释放锁</strong></p><h1 id="3-Synchronized的性质"><a href="#3-Synchronized的性质" class="headerlink" title="3.Synchronized的性质"></a>3.Synchronized的性质</h1><h2 id="3-1-可重入"><a href="#3-1-可重入" class="headerlink" title="3.1 可重入"></a>3.1 可重入</h2><p>同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。<code>（一次获取，只要不放弃这个锁，可以多次利用）</code></p><p><strong>好处</strong>：避免死锁，提升封装性。</p><p><strong>解释</strong>：假设方法一被synchronized关键字修饰，方法二也被synchronized修饰，此时当线程一运行方法一拿到了这个锁，而在方法一中调用了方法二，假设不具备可重入，线程一想要去访问方法二需要使用这个锁，但是线程一不能直接使用本身已经获得的这个锁，可是线程一已经拿到了这个锁，所以这里线程一既想获得这个锁，又释放不了它，所以就死锁了。</p><p>所以可重入就避免了死锁和一次一次获取锁的操作。</p><p><strong>原理：</strong>加锁次数计数器</p><p>jvm会记录被加锁的次数（锁对象被每一个线程获取了几次），当第一次加锁时，次数从0变为1，以后再加锁就依次加1，当退出一层同步代码块时，计数减一，当计数为0时，锁被释放。</p><h2 id="3-2-不可中断"><a href="#3-2-不可中断" class="headerlink" title="3.2 不可中断"></a>3.2 不可中断</h2><p>当一个线程获得了这个锁，其他线程<strong>必须</strong>等待它释放这个锁后才能使用它。</p><h1 id="4-加锁和释放锁"><a href="#4-加锁和释放锁" class="headerlink" title="4.加锁和释放锁"></a>4.加锁和释放锁</h1><h2 id="4-1-时机"><a href="#4-1-时机" class="headerlink" title="4.1 时机"></a>4.1 时机</h2><p>获取锁和释放锁的时机：进入和退出由synchronized修饰的方法和同步代码块（包括抛出异常）</p><h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2 原理"></a>4.2 原理</h2><p><strong>使用monitorenter获得锁，monitorexit释放锁。</strong>有两个monitorexit是因为一个是正常释放锁，一个是抛出异常后释放锁，jvm虚拟机会检查是哪种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">parctice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">()</span>;<br>   descriptor: ()V<br>   flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>   Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: aload_0<br>        <span class="hljs-number">1</span>: dup<br>        <span class="hljs-number">2</span>: astore_1<br>        <span class="hljs-number">3</span>: monitorenter<br>        <span class="hljs-number">4</span>: aload_1<br>        <span class="hljs-number">5</span>: monitorexit<br>        <span class="hljs-number">6</span>: goto          <span class="hljs-number">14</span><br>        <span class="hljs-number">9</span>: astore_2<br>       <span class="hljs-number">10</span>: aload_1<br>       <span class="hljs-number">11</span>: monitorexit<br>       <span class="hljs-number">12</span>: aload_2<br>       <span class="hljs-number">13</span>: athrow<br>       <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h1 id="5-Synchronized的缺点"><a href="#5-Synchronized的缺点" class="headerlink" title="5.Synchronized的缺点"></a>5.Synchronized的缺点</h1><p><strong>效率低：</strong>锁的释放情况少，视图获得锁时无法设定超时，不能中断一个正在试图获得锁的线程。</p><p><strong>不够灵活：</strong>加锁和释放的时机单一，每个锁仅有单一的条件，就是这个锁是哪个对象的锁</p><p><strong>无法知道是否成功获取到锁</strong></p><h1 id="6-原理"><a href="#6-原理" class="headerlink" title="6.原理"></a>6.原理</h1><h2 id="6-1-java对象结构"><a href="#6-1-java对象结构" class="headerlink" title="6.1 java对象结构"></a>6.1 java对象结构</h2><p>java对象(Object实例)结构包括三个部分：<strong>对象头</strong>，<strong>对象体</strong>，<strong>对齐字节</strong></p><p><img src="/image/juc/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg"></p><h3 id="6-1-2-对象头"><a href="#6-1-2-对象头" class="headerlink" title="6.1.2 对象头"></a>6.1.2 对象头</h3><p>对象头的结构：</p><ol><li>Mark Word</li><li>Class Pointer</li><li>Array Length(这个只有数组对象才有，普通对象就只有上面两个)</li></ol><hr><p><strong>Mark Word</strong></p><p>作用：用于存储自身运行时的数据，例如GC标志位、哈希码、锁状态。</p><p>长度：与JVM的位数有关，Mark Word的长度为JVM的一个字的大小，即32位的JVM的Mark Word为32位，64位的JVM的Mark Word长度为64位。</p><p>下面我们都以64位的Mark Word为例：</p><p>java内置锁的状态有4种，级别由低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。</p><p><img src="/image/juc/synchronized2.png"></p><p>从低位到高位依次表示的是：</p><p>（1）lock：锁状态标记位，2bit</p><p>（2）biased_lock：对象是否启用偏向锁标记。1bit，为1表示启用了偏向锁，其他状态下该位均为0</p><p>lock和biased_lock共同决定了是否使用偏向锁，因为偏向锁状态和无锁状态的lock为都是01，无法判断是否使用偏向锁，因此当001是无锁，101是偏向锁。</p><p>（3）age：java的分代年龄，4bit，因此最大为15，并行GC的年龄阈值为15就会晋升到老年代。</p><p>（4）hashcode：对象的哈希码，31bit，采用延迟加载技术，刚开始创建对象的时候这个参数值为空，只有当调用了计算哈希的方法后才会被写入到对象头。</p><p>（5）thread：线程id，是拥有这个偏向锁的线程id</p><p>（6）ptr_to_lock_record：在轻量级锁状态下指向栈帧中锁记录的指针</p><p>（7）ptr_to_heavyweight_monitor：在重量级锁的状态下指向对象监视器的指针。每个java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级锁）后，，则对象会尝试找一个Monitor与之关联，关联成功，该对象头的Mark Word中就被设置指向Monitor对象的指针。</p><hr><p><strong>Class Pointer</strong></p><p>作用：类对象指针，执行方法区中的类的klass对象，jvm通过这个指针确定这个对象是哪个类的实例。</p><p>长度：与JVM的位数有关，Class Pointer的长度为JVM的一个字的大小，即32位的JVM的Class Pointer为32位，64位的JVM的Class Pointer长度为64位。</p><p>因为64位的类对象指针会占据大量内存，因此一般对该字段会采取指针压缩的方法，即<strong>Oop对象指针压缩</strong>(可以手动关闭)，压缩至32位。</p><hr><p><strong>Array Length</strong></p><p>只有数组对象才有这个字段。</p><p>也会指针压缩</p><h3 id="6-1-2-对象体"><a href="#6-1-2-对象体" class="headerlink" title="6.1.2 对象体"></a>6.1.2 对象体</h3><p>包含对象的成员变量。</p><h3 id="6-1-3-对齐字节"><a href="#6-1-3-对齐字节" class="headerlink" title="6.1.3 对齐字节"></a>6.1.3 对齐字节</h3><p>填充字节，保证java对象所占用的内存字节数为8的倍数。</p><p>6.2 Monitor</p><p>Monitor被翻译为<strong>监视器</strong>或<strong>管程</strong>。（操作系统层面的对象）</p><p>Monitor内部有WaitSet、EntryList（等待队列：希望获取Monitor锁，但是现在Monitor已经被其他线程所有，所以这个线程会进入这个等待队列，BLOCKED）、Owner（获得这个锁的线程指向它）</p><p>当拥有这个锁的线程把临界区代码执行完之后会释放这个锁，具体过程是按照Monitor地址找到Monitor对象，设置Owner为null，唤醒等待队列的线程，选一个线程拥有这个Monitor锁。</p><p><img src="/image/juc/synchronized1.png"></p><h2 id="6-2-偏向锁"><a href="#6-2-偏向锁" class="headerlink" title="6.2 偏向锁"></a>6.2 偏向锁</h2><p>为什么要引入偏向锁？当一个同步代码块或者方法没有多个线程竞争，总是由一个线程多次重入申请获得锁，这样比较耗费性能。</p><p><strong>偏向锁的核心原理：</strong>当锁对象第一次被线程获取时，</p><blockquote><p>线程ID是由操作系统设置的，不是我们使用thread.getId得到的那个thread实例的id。</p></blockquote><p>以后这个线程想要再进入同步块中，只需要判断锁对象中的线程ID和偏向标志位，就可以直接进入代码块中，不需要cas、进行申请锁等一系列操作。</p><p>如果线程ID不是当前线程的，有两种情况，1.线程ID为空</p><blockquote><p>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态，所以在4s之后创建的对象才是在匿名偏向状态，即偏向标志位为1，thread id为0</p><p>因为jvm在启动的时候需要加载资源，这些对象加上偏向锁没有意义，不起用偏向锁能减少大量偏向锁撤销的成本。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>我测试的偏向锁并没有延迟加载，现在可能是已经改了，都是立刻加载的，不过可以通过设置参数Run-&gt;Edit Configurations-&gt;VM options-&gt; -XX:BiasedLockingStartupDelay&#x3D;4000来开启偏向锁的延迟加载</p></blockquote><p><strong>撤销偏向</strong></p><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>其他线程使用偏向锁对象时，会将偏向锁升级为<strong>轻量级锁</strong></li><li><strong>调用了wait&#x2F;notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><p><strong>批量重偏向</strong></p><p>假设n个对象都是thread1的偏向锁对象，但是这n个对象被多个线程访问，但没有竞争，那其他线程访问时，会将偏向锁撤销，升级成轻量级锁。</p><ul><li><p>当撤销偏向锁的次数超过20次以后，这时剩下的偏向thread1的对象偏向给thread1的对象可能会重新<strong>批量重偏向</strong>给后来访问线程1的对象的线程。（因为每次撤销的消耗太大了）</p></li><li><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong>（001），新建的对象也是不可偏向的。</p></li></ul><h2 id="6-3-轻量级锁"><a href="#6-3-轻量级锁" class="headerlink" title="6.3 轻量级锁"></a>6.3 轻量级锁</h2><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。但是如果又有了竞争，轻量级锁会升级成重量级锁。优先使用轻量级锁。</p><p><strong>轻量级锁对使用者是透明的，语法上还是使用synchronized代码块</strong></p><p><strong>使用原理：</strong>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word。</p><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas(原子操作，线程安全)去替换Object中的mark word，将此mark word放入lock record中保存。如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁。</p><p>所以替换成功的结果就是锁对象中的 lock record地址  00 与Object对象中的Make word交换。</p><p><img src="/image/juc/synchronized4.png"></p><p><strong>锁重入</strong>就是该线程run方法中synchronized代码块中再次包裹synchronized代码块，即再次锁住这个对象。</p><p>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>有两种情况：</p><ul><li>此时其他线程已经给对象加了轻量级锁的情况，此时该线程就会进入<strong>锁膨胀</strong>过程。</li><li>自己执行了synchronized锁重入，那么会再加一条Lock Record对象，它的Object reference也指向这个object对象，线程中Lock Record对象的个数作为锁重入的计数。</li></ul><p><img src="/image/juc/synchronized9.png"></p><p>每次锁重入的时候都需要cas，开销较大。所以引入了偏向锁。</p><p>只有第一次使用CAS将线程ID设置到对象的Mark word头中，之后如果发生了锁重入，发现这个线程ID是自己的就表示没有竞争，不用再cas，线程ID是由操作系统设置的，不是我们使用thread.getId得到的那个。</p><p><img src="/image/juc/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E8%BE%93%E5%87%BA6.png"></p><h2 id="6-4-重量级锁"><a href="#6-4-重量级锁" class="headerlink" title="6.4 重量级锁"></a>6.4 重量级锁</h2><p>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（此时其他线程已经给对象加了轻量级锁的情况），此时该线程就会进入<strong>锁膨胀</strong>过程。</p><p>这个线程为Object申请Monitor锁，让Object的Mark word中保存Monitor地址，并指向Monitor，然后自己进入Monitor的EntryList中阻塞，当Thread0退出同步代码块时，需要解锁，尝试使用cas将Mark Word的值恢复给对象，失败，会进入重量级锁解锁流程。根据Object reference找到锁对象object，然后根据Mark word中的地址找到Monitor对象，设置Owner为null，唤醒等待队列的线程，选一个线程拥有这个Monitor锁。</p><p><img src="/image/juc/synchronized5.png"></p><p><img src="/image/juc/synchronized6.png"></p><p>在重量级锁竞争时，线程不会直接BLOCKED，而是先自旋重新尝试获得Monitor锁，如果在几次自旋后获得了锁，就开始执行，如果没有获得，就进入阻塞状态。</p><p><img src="/image/juc/synchronized7.png"></p><p><img src="/image/juc/synchronized8.png"></p><h2 id="6-5-例子"><a href="#6-5-例子" class="headerlink" title="6.5 例子"></a>6.5 例子</h2><p><strong>创建完锁对象后，默认是匿名偏向状态。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">aaa</span> &#123;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//设置开启偏向锁的延迟时间，4s</span><br>        <span class="hljs-comment">//Run-&gt;Edit Configurations-&gt;VM options-&gt; -XX:BiasedLockingStartupDelay=4000</span><br><br>        log.info(<span class="hljs-string">&quot;在开启之前创建的对象&quot;</span>);<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>   log.info(ClassLayout.parseInstance(dog1).toPrintable());<br><br>        Thread.sleep(<span class="hljs-number">5000</span>);<br><br>        log.info(<span class="hljs-string">&quot;在开启之后创建的对象&quot;</span>);<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>   log.info(ClassLayout.parseInstance(dog2).toPrintable());<br>        <br>        <span class="hljs-comment">//LITTLE_ENDIAN：cpu采用小端序输出</span><br>        <span class="hljs-comment">//16进制中，两个数就是一字节</span><br>        System.out.println(ByteOrder.nativeOrder());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>小端：数据的高字节保存在内存的高地址中</p><p>大端：数据的高字节保存在内存的低地址中  &#x2F;&#x2F;它们都是以字节为单位存放的</p><p><img src="/image/juc/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E8%BE%93%E5%87%BA1.png"></p><p>所以上面的数据是以小端的形式输出的，我们可以转换为正常习惯的方式，即大端来看。</p><p>对于第二个对象布局，首先，第一行和第二行是Mark Word，第三行是Class Pointer</p><p>Mark Word的大端形式(8B)：00 00 00 00 00 00 00 05</p><p>转化为二进制就是 <code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101</code>，所以是<strong>匿名偏向状态</strong>，即可偏向，但是还没有线程偏向于这个锁对象。</p><hr><p><strong>线程A先获得了锁对象，则锁对象偏向于它，这时再来一个线程B竞争，锁升级为轻量级锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">aaa</span> &#123;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        log.info(ClassLayout.parseInstance(dog3).toPrintable());<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (dog3)&#123;<br>                log.info(Thread.currentThread().getName()+<span class="hljs-string">&quot;获取到了锁对象&quot;</span>);<br>                log.info(ClassLayout.parseInstance(dog3).toPrintable());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">105</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.info(ClassLayout.parseInstance(dog3).toPrintable());<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br><br>        Thread.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable2</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (dog3)&#123;<br>                log.info(Thread.currentThread().getName()+<span class="hljs-string">&quot;获取到了锁对象&quot;</span>);<br>                log.info(ClassLayout.parseInstance(dog3).toPrintable());<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable2).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/image/juc/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E8%BE%93%E5%87%BA2.png"></p><p>这里测试了好几次…..因为在锁对象状态为偏向锁的时候，有另外一个线程B来竞争锁对象，此时锁就会升级为轻量级锁，但是只要线程A不放弃锁，锁就还是它的，线程B会进行自旋，尝试获取锁，默认情况下自旋的次数为10次，如果超过10次还没有获得锁，就进行轻量级锁膨胀为重量级锁。</p><p>但是这个自旋时间也太不好把握了，稍微超过了自旋时间还没获得锁，就变成重量级锁了…..测试了半天才有一个000</p><blockquote><p>轻量级锁有两种：普通自旋锁，自适应自旋锁</p><p>1.普通自旋锁：当有线程来竞争锁时，假如此时锁已经被另一个线程占用，这个抢锁线程就会在原地循环等待，而不会被阻塞，多次尝试获得锁，默认自旋次数为10次</p><p>2.自适应自旋锁：自旋次数不是固定的，而是根据1.如果抢锁线程在同一个锁对象上曾经获得过锁，那jvm就认为这次自旋很可能再次成功，因此自旋时间会更长，2.如果对于某个锁，抢锁线程很少成功获得过，那jvm就可能减少自旋时间甚至不自旋，以节约资源。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">aaa</span> &#123;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        log.info(ClassLayout.parseInstance(dog3).toPrintable());<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (dog3)&#123;<br>                log.info(Thread.currentThread().getName()+<span class="hljs-string">&quot;获取到了锁对象&quot;</span>);<br>                log.info(ClassLayout.parseInstance(dog3).toPrintable());<br><br>                <span class="hljs-comment">//log.info(ClassLayout.parseInstance(dog3).toPrintable());</span><br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br><br>        Thread.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable2</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (dog3)&#123;<br>                log.info(Thread.currentThread().getName()+<span class="hljs-string">&quot;获取到了锁对象&quot;</span>);<br>                log.info(ClassLayout.parseInstance(dog3).toPrintable());<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable2).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这没有竞争，线程A先持有锁，接着释放锁之后线程B再持有</p><p><img src="/image/juc/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E8%BE%93%E5%87%BA4.png"></p><p>这里其实有可能是000 也可能是101</p><p><img src="/image/juc/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E8%BE%93%E5%87%BA3.png"></p><hr><p>偏向锁膨胀的步骤：</p><p><img src="/image/juc/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E8%BE%93%E5%87%BA5.png"></p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>Synchronized关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Comparator比较器</title>
    <link href="/2022/04/10/Problems/comparator/"/>
    <url>/2022/04/10/Problems/comparator/</url>
    
    <content type="html"><![CDATA[<p>需要重写compare(Object o1,Object o2)方法。</p><p>一般是用于java对象的排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1 - o2;<br>        <span class="hljs-comment">//等同于</span><br>        <span class="hljs-comment">/*if(o1 &gt; o2) &#123;</span><br><span class="hljs-comment">            return 1;</span><br><span class="hljs-comment">        &#125;else if(o1 == o2)</span><br><span class="hljs-comment">            return 0;</span><br><span class="hljs-comment">        else return -1;*/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Arrays.sort()</code></p><p>Arrays类有一个静态方法sort，利用这个方法我们可以传入我们要排序的数组进去排序，因为我们传入的是一个数组的引用，所以排序完成的结果也通过这个引用的来更改数组。对于整数、字符串排序，jdk提供了默认的实现，但是<code>如果要对一个对象数组排序，则要自己实现java.util.Comparator接口。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(nums,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;E&gt;()&#123;<span class="hljs-comment">//E是泛型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(E o1,E o2)</span>&#123;<br>        <span class="hljs-keyword">return</span> o2 - o1;<span class="hljs-comment">//降序</span><br>        <span class="hljs-comment">//return o1 - o2; 升序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p>在Comparator内部，交换的标准是依据返回值的大小，大于0就交换，小于等于0就不交换。</p><p>如果返回值是o1-o2，当返回值是大于0，交换这两个数，说明o1&gt;o2，交换过之后是升序，说明这次排序是升序。</p><p>如果返回值是o2-o1，当返回值是大于0，交换这两个数，说明o2&gt;o1，交换过之后是降序，说明这次排序是降序。</p>]]></content>
    
    
    <categories>
      
      <category>比较器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程- ConcurrentHashMap</title>
    <link href="/2022/04/10/Java/JUC/ConcurrentHashMap/"/>
    <url>/2022/04/10/Java/JUC/ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<p>基础容器类ArrayList、LinkedList、HashMap都是非线程安全的，在多线程环境下使用这些容器会出现线程安全问题，为了保证线程安全，java使用内置锁Synchronized提供了一套线程安全的同步容器类，比如Vector、<strong>HashTable</strong>、Stack，这些同步容器实现线程安全的方式是在需要同步的方法上添加关键字synchronized，而在线程征用的场景下synchronized会变成重量级锁，严重影响性能，因此有了<strong>juc高并发容器</strong></p><p><strong>juc高并发容器</strong>是基于无锁编程算法实现的容器类，通过CAS保证操作的原子性，通过volatile保障内存的可见性。</p><p>ConcurrentHashMap就是juc包中的一个高并发容器类，是一种线程安全的哈希表。</p><p>ConcurrentHashMap对应的基础容器是HashMap</p><h1 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h1><p>基础容器HashMap是线程不安全的，在扩容的时候会导致死链。</p><p>默认负载因子是0.75，即当HashMap的元素个数(使用的桶的个数)超过容量(一共的桶的个数)的3&#x2F;4时会触发扩容。</p><p>下面均以jdk7为例</p><p>假如现在HashMap的桶个数为16，添加元素，直到使用的桶个数为12时，如果再添加元素需要放在新的桶中(根据key的hash值磨桶总个数得到的桶的下标值)，需要扩容了，假如现在桶下标为1的位置有3个key-value键值对，链为<code>(1,null)-&gt;(35,null)-&gt;(16,null)</code>，在jdk7中后加入的键值对放在链表头，这个添加的顺序就是16,35,1</p><p>就在此时，假如有两个线程都要同时往HashMap中添加一个键值对，会先触发扩容，( 扩容后(1,null)和(35,null) 还是在桶下标为1的位置 )</p><p><img src="/image/juc/hashmap.png"></p><p>对于线程1，e：1-&gt;35-&gt;16-&gt;null</p><p>​next：35-&gt;16-&gt;null</p><p>对于线程2，e：1-&gt;35-&gt;16-&gt;null</p><p>​next：35-&gt;16-&gt;null</p><p>假设线程1先扩容完毕，此时桶下标为1的位置的链是<code>(35,null)-&gt;(1,null)</code></p><p>所以现在线程2的节点引用变为：</p><p>​e：1-&gt;null</p><p>​next： 35-&gt;1-&gt;null</p><p>新的桶1：1-&gt;null</p><p>​e：35-&gt;1-&gt;null</p><p>​next：1-&gt;null</p><p>接着桶1的状况：35-&gt;1-&gt;null</p><p>​e：1-&gt;null</p><p>​next：null</p><p>接着桶1的状况：1-&gt;35-&gt;1-&gt;null</p><p>​e：35-&gt;1-&gt;null</p><p>​next：1-&gt;null</p><p><strong>注意：</strong>现在已经造成死链了！！</p><h1 id="2-Hashtable"><a href="#2-Hashtable" class="headerlink" title="2.Hashtable"></a>2.Hashtable</h1><p>Hashtable实现同步是利用synchronized关键字进行锁定，即给整个哈希表进行锁定，每次锁住整张表让线程独占，虽然解决了线程安全问题，但是造成了巨大的资源浪费。</p><p>当一个线程正在访问HashTable的同步方法时，其他访问Hashtable同步方法的所有线程都必须进入阻塞或轮询状态，相当于将所有的操作串行化。</p><p><strong>Hashtable不允许key和value为null</strong></p><h1 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3.ConcurrentHashMap"></a>3.ConcurrentHashMap</h1><h2 id="3-1-JDK1-8中"><a href="#3-1-JDK1-8中" class="headerlink" title="3.1 JDK1.8中"></a>3.1 JDK1.8中</h2><p><img src="/image/juc/jdk8concurrenthashmap.jpg"></p><p><strong>重要的属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1073741824</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2147483639</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75F</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TRANSFER_STRIDE</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RESIZERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">65535</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESIZE_STAMP_SHIFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-comment">//表示正在转移</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOVED</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//表示已经转换成树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEBIN</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESERVED</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">2147483647</span>;<br><span class="hljs-comment">//保存元素，数组的每个元素都是一个桶bucket</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> ConcurrentHashMap.Node&lt;K, V&gt;[] table;<br><span class="hljs-comment">//转移时(扩容时)使用的数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> ConcurrentHashMap.Node&lt;K, V&gt;[] nextTable;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> baseCount;<br><span class="hljs-comment">//默认为0，当初始化时，为-1，当扩容时为-(1+扩容线程数)，当初始化或扩容完成后，值为下一次扩容的阈值</span><br><span class="hljs-comment">//     sizeCtl = -1，表示有线程正在进行真正的初始化操作</span><br><span class="hljs-comment">//     sizeCtl = -(1 + nThreads)，表示有nThreads个线程正在进行扩容操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<br><span class="hljs-comment">//参数 transferIndex 控制各线程迁移哪些节点，从 n 开始，每来一个线程扩容，就减小 一个步长（stride ），即整个数组被分成若干段，一个线程迁移一小段。支持并发扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> transferIndex;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> ConcurrentHashMap.CounterCell[] counterCells;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConcurrentHashMap.KeySetView&lt;K, V&gt; keySet;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConcurrentHashMap.ValuesView&lt;K, V&gt; values;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConcurrentHashMap.EntrySetView&lt;K, V&gt; entrySet;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe U;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SIZECTL;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> TRANSFERINDEX;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> BASECOUNT;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> CELLSBUSY;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> CELLVALUE;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ABASE;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ASHIFT;<br></code></pre></td></tr></table></figure><hr><p><strong>一些重要的静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Entry</span>&lt;K, V&gt; &#123;....&#125;<br><br><span class="hljs-comment">//扩容时如果某个桶迁移完毕，用它作为旧的table bin的头结点，防止其他线程影响，ForwardingNode节点的哈希值是-1</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConcurrentHashMap</span>.Node&lt;K, V&gt; &#123;<br>    ForwardingNode(ConcurrentHashMap.Node&lt;K, V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">super</span>(-<span class="hljs-number">1</span>, (Object)<span class="hljs-literal">null</span>, (Object)<span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.nextTable = tab;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//红黑树，作为treebin的头结点，存储root和first</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConcurrentHashMap</span>.Node&lt;K, V&gt; &#123;....&#125;<br><br><span class="hljs-comment">//作为treebin的节点，寻出parent，left，right</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConcurrentHashMap</span>.Node&lt;K, V&gt; &#123;....&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (loadFactor &gt; <span class="hljs-number">0.0F</span> &amp;&amp; initialCapacity &gt;= <span class="hljs-number">0</span> &amp;&amp; concurrencyLevel &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//桶的个数至少要保证并发度的大小，即最多有concurrencyLevel个线程同时操作这个哈希表</span><br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel) &#123;<br>            initialCapacity = concurrencyLevel;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(<span class="hljs-number">1.0D</span> + (<span class="hljs-type">double</span>)((<span class="hljs-type">float</span>)((<span class="hljs-type">long</span>)initialCapacity) / loadFactor));<br>        <span class="hljs-comment">//因为上面计算的size很大概率不是2的n次方，所以把他转换成2的n次方</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> size &gt;= <span class="hljs-number">1073741824L</span> ? <span class="hljs-number">1073741824</span> : tableSizeFor((<span class="hljs-type">int</span>)size);<br>        <span class="hljs-comment">//设置table的大小</span><br>        <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对initialCapacity有点疑惑，很奇怪他存在的意义。问了一下同学，觉得应该是这样的。<br>定义哈希表在容纳下initialCapacity那么多个元素之前不能扩容，并且哈希表的容量刚开始就大于等于initialCapacity，又因为上面initialCapacity &#x3D; concurrencyLevel; 保证了至少有concurrencyLevel的容量，也就是这么大的并发度</p><p>initialCapacity的作用就是   提前预估table的大小，防止后面多次扩容，消耗性能</p></blockquote><hr><p><strong>get()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    ConcurrentHashMap.Node[] tab;<br>    ConcurrentHashMap.Node e;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">// tabAt(tab, n - 1 &amp; h)：获取Node[] tab中第(n - 1 &amp; h)个node,就是取模</span><br>    <span class="hljs-keyword">if</span> ((tab = <span class="hljs-built_in">this</span>.table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (e = tabAt(tab, n - <span class="hljs-number">1</span> &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">int</span> eh;<br>        Object ek;<br>        <span class="hljs-comment">//头节点的哈希码等于我们要查找的这个节点的哈希码</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-comment">//头节点的key等于我们要查找的这个key，即这个头节点就是我们要找的那个节点</span><br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)) &#123;<br>                <span class="hljs-keyword">return</span> e.val;<br>            &#125;<br>            <span class="hljs-comment">//eh为负数表示该头节点正在扩容中，扩容完的头结点是forwardingnode，则调用find到新的哈希表中找，treebin是-2</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>) &#123;<br>            ConcurrentHashMap.Node p;<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        &#125;<br><span class="hljs-comment">//上面的都不满足，则到桶的链表中挨个查找</span><br>        <span class="hljs-keyword">while</span>((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))) &#123;<br>                <span class="hljs-keyword">return</span> e.val;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>put方法</strong></p><p>使用synchronized锁住链表头节点，不影响其他线程操作其他链表</p><p>多线程无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">//不允许有空的key和value</span><br>    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; value != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//链表长度</span><br>        ConcurrentHashMap.Node[] tab = <span class="hljs-built_in">this</span>.table;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>(tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//懒惰创建哈希表，使用cas初始化</span><br>                tab = <span class="hljs-built_in">this</span>.initTable();<br>            &#125;<br><br>            ConcurrentHashMap.Node f;<br>            <span class="hljs-type">int</span> i;<br>            <span class="hljs-comment">//创建链表头节点</span><br>            <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = n - <span class="hljs-number">1</span> &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//添加链表头使用了cas，如果这时其他线程先创建了头结点，就cas失败，重新进入while循环，这些失败的线程并不会阻塞</span><br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, (ConcurrentHashMap.Node)<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>.Node(hash, key, value))) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> fh;<br>                <span class="hljs-comment">//这个头节点是forwardingnode，正在扩容</span><br>                <span class="hljs-comment">//线程帮忙扩容</span><br>                <span class="hljs-keyword">if</span> ((fh = f.hash) == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">//锁住当前链表帮忙扩容</span><br>                    tab = <span class="hljs-built_in">this</span>.helpTransfer(tab, f);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//桶下标冲突，需要对这个桶的链表进行遍历</span><br>                    Object fk;<br>                    Object fv;<br>                    <span class="hljs-keyword">if</span> (onlyIfAbsent &amp;&amp; fh == hash &amp;&amp; ((fk = f.key) == key || fk != <span class="hljs-literal">null</span> &amp;&amp; key.equals(fk)) &amp;&amp; (fv = f.val) != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span> fv;<br>                    &#125;<br><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-comment">//只锁住链表头节点</span><br>                    <span class="hljs-keyword">synchronized</span>(f) &#123;<br>                        <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                            <span class="hljs-keyword">if</span> (fh &lt; <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;<br>                                    binCount = <span class="hljs-number">2</span>;<br>                                    ConcurrentHashMap.TreeNode p;<br>                                    <span class="hljs-keyword">if</span> ((p = ((ConcurrentHashMap.TreeBin)f).putTreeVal(hash, key, value)) != <span class="hljs-literal">null</span>) &#123;<br>                                        oldVal = p.val;<br>                                        <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                                            p.val = value;<br>                                        &#125;<br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> ConcurrentHashMap.ReservationNode) &#123;<br>                                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Recursive update&quot;</span>);<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//fh &gt;= 0</span><br>                                label124: &#123;<br>                                    binCount = <span class="hljs-number">1</span>;<br><br>                                    ConcurrentHashMap.Node e;<br>                                    Object ek;<br>                                    <span class="hljs-keyword">for</span>(e = f; e.hash != hash || (ek = e.key) != key &amp;&amp; (ek == <span class="hljs-literal">null</span> || !key.equals(ek)); ++binCount) &#123;<br>                                        <span class="hljs-comment">//没找到这个节点，追加</span><br>                                        ConcurrentHashMap.Node&lt;K, V&gt; pred = e;<br>                                        <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                            pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>.Node(hash, key, value);<br>                                            <span class="hljs-keyword">break</span> label124;<br>                                        &#125;<br>                                    &#125;<br><br>                                    oldVal = e.val;<br>                                    <span class="hljs-comment">//更新值</span><br>                                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                                        e.val = value;<br>                                    &#125;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= <span class="hljs-number">8</span>) &#123;<br>                            <span class="hljs-comment">//链表长度大于树化阈值8，将链表转换成红黑树</span><br>                            <span class="hljs-comment">//不过不是直接转换，是先扩容，但是等table的长度超过64后，链表长度还是大于8，就会将链表转化成红黑树</span><br>                            <span class="hljs-built_in">this</span>.treeifyBin(tab, i);<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-keyword">return</span> oldVal;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.addCount(<span class="hljs-number">1L</span>, binCount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>helpTransfer</strong></p><p>其他线程帮忙扩容，并发扩容</p><p>Cmap 支持并发扩容，实现方式是，将哈希表拆分，让每个线程处理自己的区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ConcurrentHashMap.Node&lt;K, V&gt;[] helpTransfer(ConcurrentHashMap.Node&lt;K, V&gt;[] tab, ConcurrentHashMap.Node&lt;K, V&gt; f) &#123;<br>    ConcurrentHashMap.Node[] nextTab;<br>    <span class="hljs-keyword">if</span> (tab != <span class="hljs-literal">null</span> &amp;&amp; f <span class="hljs-keyword">instanceof</span> ConcurrentHashMap.ForwardingNode &amp;&amp; (nextTab = ((ConcurrentHashMap.ForwardingNode)f).nextTable) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(tab.length);<br><br>        <span class="hljs-type">int</span> sc;<br>        <span class="hljs-keyword">while</span>(nextTab == <span class="hljs-built_in">this</span>.nextTable &amp;&amp; <span class="hljs-built_in">this</span>.table == tab &amp;&amp; (sc = <span class="hljs-built_in">this</span>.sizeCtl) &lt; <span class="hljs-number">0</span> &amp;&amp; sc &gt;&gt;&gt; <span class="hljs-number">16</span> == rs &amp;&amp; sc != rs + <span class="hljs-number">1</span> &amp;&amp; sc != rs + <span class="hljs-string">&#x27;\uffff&#x27;</span> &amp;&amp; <span class="hljs-built_in">this</span>.transferIndex &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-built_in">this</span>.transfer(tab, nextTab);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nextTab;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.table;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(ConcurrentHashMap.Node&lt;K, V&gt;[] tab, ConcurrentHashMap.Node&lt;K, V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> stride;<br>    <span class="hljs-keyword">if</span> ((stride = NCPU &gt; <span class="hljs-number">1</span> ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; <span class="hljs-number">16</span>) &#123;<br>        stride = <span class="hljs-number">16</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ConcurrentHashMap.Node&lt;K, V&gt;[] nt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>.Node[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var27) &#123;<br>            <span class="hljs-built_in">this</span>.sizeCtl = <span class="hljs-number">2147483647</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.nextTable = nextTab;<br>        <span class="hljs-built_in">this</span>.transferIndex = n;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>addCount</strong></p><p>维护哈希表的size，增加size的计数，如果超过阈值，扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCount</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span> check)</span> &#123;<br>        ConcurrentHashMap.CounterCell[] cs;<br>        <span class="hljs-type">long</span> b;<br>        <span class="hljs-type">long</span> s;<br>        <span class="hljs-type">int</span> sc;<br>        <span class="hljs-keyword">if</span> ((cs = <span class="hljs-built_in">this</span>.counterCells) != <span class="hljs-literal">null</span> || !U.compareAndSetLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = <span class="hljs-built_in">this</span>.baseCount, s = b + x)) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            ConcurrentHashMap.CounterCell c;<br>            <span class="hljs-type">long</span> v;<br>            <span class="hljs-keyword">if</span> (cs == <span class="hljs-literal">null</span> || (sc = cs.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> || (c = cs[ThreadLocalRandom.getProbe() &amp; sc]) == <span class="hljs-literal">null</span> || !(uncontended = U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) &#123;<br>                <span class="hljs-built_in">this</span>.fullAddCount(x, uncontended);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            s = <span class="hljs-built_in">this</span>.sumCount();<br>        &#125;<br><br>        <span class="hljs-type">int</span> n;<br>        ConcurrentHashMap.Node[] tab;<br>        <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span>(; s &gt;= (<span class="hljs-type">long</span>)(sc = <span class="hljs-built_in">this</span>.sizeCtl) &amp;&amp; (tab = <span class="hljs-built_in">this</span>.table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &lt; <span class="hljs-number">1073741824</span>; s = <span class="hljs-built_in">this</span>.sumCount()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>                <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//别的线程正在扩容，帮助扩容</span><br>                    ConcurrentHashMap.Node[] nt;<br>                    <span class="hljs-keyword">if</span> (sc &gt;&gt;&gt; <span class="hljs-number">16</span> != rs || sc == rs + <span class="hljs-number">1</span> || sc == rs + <span class="hljs-string">&#x27;\uffff&#x27;</span> || (nt = <span class="hljs-built_in">this</span>.nextTable) == <span class="hljs-literal">null</span> || <span class="hljs-built_in">this</span>.transferIndex &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;<br>                        <span class="hljs-built_in">this</span>.transfer(tab, nt);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">2</span>)) &#123;<span class="hljs-comment">//扩容</span><br>                    <span class="hljs-built_in">this</span>.transfer(tab, (ConcurrentHashMap.Node[])<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><hr><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap.Node&lt;K, V&gt;[] initTable() &#123;<br>    ConcurrentHashMap.Node[] tab;<br>    <span class="hljs-keyword">while</span>((tab = <span class="hljs-built_in">this</span>.table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> sc;<br>        <span class="hljs-comment">//sizeCtl=-1说明有其他线程正在初始化table</span><br>        <span class="hljs-keyword">if</span> ((sc = <span class="hljs-built_in">this</span>.sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;<br>            Thread.<span class="hljs-keyword">yield</span>();<span class="hljs-comment">//放弃cpu</span><br>            <span class="hljs-comment">//尝试将sizeCtl设置为-1，表示初始化table</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = <span class="hljs-built_in">this</span>.table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc &gt; <span class="hljs-number">0</span> ? sc : <span class="hljs-number">16</span>;<br>                    ConcurrentHashMap.Node&lt;K, V&gt;[] nt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>.Node[n];<br>                    tab = nt;<br>                    <span class="hljs-built_in">this</span>.table = nt;<br>                    <span class="hljs-comment">//sc现在代表为下一次要扩容时的阈值</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-built_in">this</span>.sizeCtl = sc;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>扩容</strong></p><p>在此处使用synchronized锁住链表头节点，并不影响其他线程操作其他的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(ConcurrentHashMap.Node&lt;K, V&gt;[] tab, ConcurrentHashMap.Node&lt;K, V&gt;[] nextTab)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length;<br>        <span class="hljs-type">int</span> stride;<br>        <span class="hljs-keyword">if</span> ((stride = NCPU &gt; <span class="hljs-number">1</span> ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; <span class="hljs-number">16</span>) &#123;<br>            stride = <span class="hljs-number">16</span>;<br>        &#125;<br><span class="hljs-comment">//nextTable也是懒惰加载，为空就创建一个容量为2倍的table</span><br>        <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;...&#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>        ConcurrentHashMap.ForwardingNode&lt;K, V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>.ForwardingNode(nextTab);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> sc;<br>                <span class="hljs-keyword">while</span>(!advance) &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; i + n &lt; nextn) &#123;<br>                        ConcurrentHashMap.Node f;<br>                        <span class="hljs-comment">//这个桶位置的链表已经被处理完了，需要将这个位置替换为forwardingnode</span><br>                        <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>) &#123;<br>                            advance = casTabAt(tab, i, (ConcurrentHashMap.Node)<span class="hljs-literal">null</span>, fwd);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-type">int</span> fh;<br>                            <span class="hljs-comment">//链表头已经是forwardingnode了(因为它的hash值是-1)</span><br>                            <span class="hljs-keyword">if</span> ((fh = f.hash) == -<span class="hljs-number">1</span>) &#123;<br>                                <span class="hljs-comment">//进入下一轮循环，遍历下一个桶</span><br>                                advance = <span class="hljs-literal">true</span>;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-comment">//链表头有元素，就需要将它们移动到新的table中，这时候需要将链表锁住，保证线程安全</span><br>                                <span class="hljs-keyword">synchronized</span>(f) &#123;<br>                                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                                        <span class="hljs-comment">//这个节点是普通链表中的节点，进行普通节点的挪动</span><br>                                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                                            ...<br>                                            advance = <span class="hljs-literal">true</span>;<br>                                            <span class="hljs-comment">//节点是treebin，需要进行树节点的挪动</span><br>                                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;.... <br>                                            advance = <span class="hljs-literal">true</span>;&#125;<br>                                    &#125;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;...&#125;<br>                &#125;<br><br>                --i;<br>                <span class="hljs-keyword">if</span> (i &lt; bound &amp;&amp; !finishing) &#123;<br>                    ...<br>                        advance = <span class="hljs-literal">false</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                       ...<br>                            advance = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    advance = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-JDK1-7及以前"><a href="#3-2-JDK1-7及以前" class="headerlink" title="3.2 JDK1.7及以前"></a>3.2 JDK1.7及以前</h2><p><strong>jdk7</strong></p><p><img src="/image/juc/jdk7concurrenthashmap.jpg"></p><hr><p><strong>下面是jdk1.6</strong></p><p>它基于Segment分段锁来提高多并发程序性能。</p><p>分段锁是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap，分段锁技术将key分成一个个小的Segment存储，给每一段数据分配一把锁，当一个线程占用锁访问其中一段数据的时候，其他段的数据也能被其他线程访问，能实现真正的并发。</p><p>Segment继承了ReentrantLock，Segment内部拥有一个HashEntry数组类型的成员table，要想对table内的节点修改时需要先获取Segment锁。</p><p>ConcurrentHashMap在默认并发级别会创建包含16个Segment对象的数组，其中第N个哈希桶由第N mod 16个锁来保护，这个容量初始化指定后就不能改变了，而且不是懒加载的。</p><blockquote><p>采用锁分段技术，每一个Segment读写操作高度自治，<strong>互不影响</strong>，同一Segment的写和读是可以并发执行的。但Segment的<strong>写入是需要上锁的</strong>，因此对同一Segment的并发写入会被阻塞。每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p></blockquote><hr><p><strong>ConcurrentHashMap成员变量</strong></p><p>ConcurrentHashMap实际上是一个Segment数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Mask value for indexing into segments. The upper bits of a</span><br><span class="hljs-comment">     * key&#x27;s hash code are used to choose the segment.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> segmentMask;  <span class="hljs-comment">// 用于定位段，大小等于segments数组的大小减 1，是不可变的</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Shift value for indexing within segments.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> segmentShift;    <span class="hljs-comment">// 用于定位段，大小等于32(hash值的位数)减去对segments的大小取以2为底的对数值，是不可变的</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The segments, each of which is a specialized hash table</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;   <span class="hljs-comment">// ConcurrentHashMap的底层结构是一个Segment数组</span><br></code></pre></td></tr></table></figure><hr><p><strong>Segment的定义</strong></p><p>Segment是一个小的哈希表<code>HashEntry&lt;K,V&gt;[] table</code>，Segment类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。</p><blockquote><p><strong>通过使用段(Segment)将ConcurrentHashMap划分为不同的部分，ConcurrentHashMap就可以使用不同的锁来控制对哈希表的不同部分的修改，从而允许多个修改操作并发进行, 这正是ConcurrentHashMap锁分段技术的核心内涵。</strong></p><p><a href="https://github.com/CodePrometheus/Starry-Notes/blob/master/KeyPoints/ConcurrentHashMap1.6&1.7.md">https://github.com/CodePrometheus/Starry-Notes/blob/master/KeyPoints/ConcurrentHashMap1.6&amp;1.7.md</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Segments are specialized versions of hash tables.  This</span><br><span class="hljs-comment">     * subclasses from ReentrantLock opportunistically, just to</span><br><span class="hljs-comment">     * simplify some locking and avoid separate construction.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-comment">//Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The number of elements in this segment&#x27;s region.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> count;    <span class="hljs-comment">// Segment中元素的数量，可见的</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Number of updates that alter the size of the table. This is</span><br><span class="hljs-comment">         * used during bulk-read methods to make sure they see a</span><br><span class="hljs-comment">         * consistent snapshot: If modCounts change during a traversal</span><br><span class="hljs-comment">         * of segments computing size or checking containsValue, then</span><br><span class="hljs-comment">         * we might have an inconsistent view of state so (usually)</span><br><span class="hljs-comment">         * must retry.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;  <span class="hljs-comment">//对count的大小造成影响的操作的次数（比如put或者remove操作）</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The table is rehashed when its size exceeds this threshold.</span><br><span class="hljs-comment">         * (The value of this field is always &lt;tt&gt;(int)(capacity *</span><br><span class="hljs-comment">         * loadFactor)&lt;/tt&gt;.)</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> threshold;      <span class="hljs-comment">// 阈值，段中元素的数量超过这个值就会对Segment进行扩容</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The per-segment table.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;  <span class="hljs-comment">// 链表数组</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The load factor for the hash table.  Even though this value</span><br><span class="hljs-comment">         * is same for all segments, it is replicated to avoid needing</span><br><span class="hljs-comment">         * links to outer object.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;  <span class="hljs-comment">// 段的负载因子，其值等同于ConcurrentHashMap的负载因子</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>HashEntry</strong></p><p>HashEntry用来封装具体的键值对，它的属性中key、hash、next都是<strong>final</strong>修饰的，所以这些属性一旦赋值了就不能再改变了，因此当<strong>进行新节点的插入时是插入到头节点</strong>，如果进行链表的删除节点，需要重新创建所有节点，再连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> K key;                       <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;                   <br>    <span class="hljs-keyword">volatile</span> V value;               <br>    <span class="hljs-keyword">final</span> HashEntry&lt;K,V&gt; next;     <br><br>    HashEntry(K key, <span class="hljs-type">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; HashEntry&lt;K,V&gt;[] newArray(<span class="hljs-type">int</span> i) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>初始化</strong></p><p>主要的参数是初始容量，负载因子，并发级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                         <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)              <br>        concurrencyLevel = MAX_SEGMENTS;<br><br>    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-comment">// 大小为 lg(ssize) </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;            <span class="hljs-comment">// 段的数目，segments数组的大小(2的幂次方)</span><br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    segmentShift = <span class="hljs-number">32</span> - sshift;      <span class="hljs-comment">// 用于定位段</span><br>    segmentMask = ssize - <span class="hljs-number">1</span>;      <span class="hljs-comment">// 用于定位段</span><br>    <span class="hljs-built_in">this</span>.segments = Segment.newArray(ssize);   <span class="hljs-comment">// 创建segments数组，不是懒加载</span><br><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;    <span class="hljs-comment">// 总的桶数/总的段数</span><br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;     <span class="hljs-comment">// 每个段所拥有的桶的数目(2的幂次方)</span><br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.segments.length; ++i)      <span class="hljs-comment">// 初始化segments数组</span><br>        <span class="hljs-built_in">this</span>.segments[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(cap, loadFactor);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>put</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key.hashCode());<br>    <span class="hljs-keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">final</span> Segment&lt;K,V&gt; <span class="hljs-title function_">segmentFor</span><span class="hljs-params">(<span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];<br>&#125;<br>V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    lock();    <span class="hljs-comment">// 上锁</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count;<br>        <span class="hljs-keyword">if</span> (c++ &gt; threshold) <span class="hljs-comment">// ensure capacity</span><br>            rehash();<br>        HashEntry&lt;K,V&gt;[] tab = table;    <span class="hljs-comment">// table是Volatile的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hash &amp; (tab.length - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 定位到段中特定的桶</span><br>        HashEntry&lt;K,V&gt; first = tab[index];   <span class="hljs-comment">// first指向桶中链表的表头</span><br>        HashEntry&lt;K,V&gt; e = first;<br><br>        <span class="hljs-comment">// 检查该桶中是否存在相同key的结点</span><br>        <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  <br>            e = e.next;<br><br>        V oldValue;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-comment">// 该桶中存在相同key的结点</span><br>            oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                <span class="hljs-comment">// 更新value值</span><br>                e.value = value;        <br>        &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// 该桶中不存在相同key的结点</span><br>            oldValue = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 结构性修改，modCount加1</span><br>            ++modCount;     <br>            <span class="hljs-comment">// 创建HashEntry并将其链到表头</span><br>            tab[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(key, hash, first, value); <br>            <span class="hljs-comment">// write-volatile，count值的更新一定要放在最后一步(volatile变量)</span><br>            count = c;      <br>        &#125;<br>        <span class="hljs-comment">// 返回旧值(该桶中不存在相同key的结点，则返回null)</span><br>        <span class="hljs-keyword">return</span> oldValue;    <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 在finally子句中解锁</span><br>        unlock();      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>rehash</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扩容时为了不影响正在进行的读线程，最好的方式是全部节点复制一次并重新添加</span><br><span class="hljs-comment">// 这里根据扩容时节点迁移的性质，最大可能的重用一部分节点，这个性质跟1.8的HashMap中的高低位是一个道理，必须要求hash值是final的</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>    HashEntry&lt;K,V&gt;[] oldTable = table;    <span class="hljs-comment">// 扩容前的table</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-keyword">if</span> (oldCapacity &gt;= MAXIMUM_CAPACITY)   <span class="hljs-comment">// 已经扩到最大容量，直接返回</span><br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashEntry的next是final的，resize/rehash时需要重新new，这里的特殊之处就是最大程度重用HashEntry链尾部的一部分，尽量减少重新new的次数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// 新创建一个table，其容量是原来的2倍</span><br>    HashEntry&lt;K,V&gt;[] newTable = HashEntry.newArray(oldCapacity&lt;&lt;<span class="hljs-number">1</span>);   <br>    threshold = (<span class="hljs-type">int</span>)(newTable.length * loadFactor);   <span class="hljs-comment">// 新的阈值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sizeMask</span> <span class="hljs-operator">=</span> newTable.length - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 用于定位桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;<br>        <span class="hljs-comment">// We need to guarantee that any existing reads of old Map can</span><br>        <span class="hljs-comment">//  proceed. So we cannot yet null out each bin.</span><br>        HashEntry&lt;K,V&gt; e = oldTable[i];  <span class="hljs-comment">// 依次指向旧table中的每个桶的链表表头</span><br><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 旧table的该桶中链表不为空</span><br>            HashEntry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> e.hash &amp; sizeMask;   <span class="hljs-comment">// 重哈希已定位到新桶</span><br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)    <span class="hljs-comment">// 旧table的该桶中只有一个节点</span><br>                newTable[idx] = e;<br>            <span class="hljs-keyword">else</span> &#123;    <br>                <span class="hljs-comment">// Reuse trailing consecutive sequence at same slot</span><br>                HashEntry&lt;K,V&gt; lastRun = e;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastIdx</span> <span class="hljs-operator">=</span> idx;<br>                <span class="hljs-comment">// 这个循环是寻找HashEntry链最大的可重用的尾部</span><br>                <span class="hljs-comment">// 这里重用部分中，所有节点的去向相同，它们可以不用被复制</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next;<br>                     last != <span class="hljs-literal">null</span>;<br>                     last = last.next) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> last.hash &amp; sizeMask;<br>                    <span class="hljs-comment">// 寻找k值相同的子链，该子链尾节点与父链的尾节点必须是同一个</span><br>                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;<br>                        lastIdx = k;<br>                        lastRun = last;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// JDK直接将子链lastRun放到newTable[lastIdx]桶中</span><br>                <span class="hljs-comment">// 把重用部分整体放在扩容后的hash桶中</span><br>                newTable[lastIdx] = lastRun;<br><br>                <span class="hljs-comment">// 对该子链之前的结点，JDK会挨个遍历并把它们复制到新桶中</span><br>                <span class="hljs-comment">// 复制不能重用的部分，并把它们插入到rehash后的所在HashEntry链的头部</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> p.hash &amp; sizeMask;<br>                    HashEntry&lt;K,V&gt; n = newTable[k];<br>                    newTable[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(p.key, p.hash,<br>                                                     n, p.value);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    table = newTable;   <span class="hljs-comment">// 扩容完成</span><br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>get</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key.hashCode());<br>    <span class="hljs-keyword">return</span> segmentFor(hash).get(key, hash);<br>&#125;<br>V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// read-volatile，首先读 count 变量</span><br>        HashEntry&lt;K,V&gt; e = getFirst(hash);   <span class="hljs-comment">// 获取桶中链表头结点</span><br>        <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 查找链中是否存在指定Key的键值对</span><br>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;    <br>                <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (v != <span class="hljs-literal">null</span>)  <span class="hljs-comment">// 如果读到value域不为 null，直接返回</span><br>                    <span class="hljs-keyword">return</span> v;   <br>                <span class="hljs-comment">// 如果读到value域为null，说明发生了重排序，加锁后重新读取</span><br>                <span class="hljs-keyword">return</span> readValueUnderLock(e); <span class="hljs-comment">// recheck</span><br>            &#125;<br>            e = e.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 如果不存在，直接返回null</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>remove</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为1.6的HashEntry的next指针是final的，所以比普通的链表remove要复杂些，只有被删除节点的后面可以被重用，前面的都要再重新insert一次</span><br>V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key, <span class="hljs-type">int</span> hash, Object value)</span> &#123;<br>    lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count - <span class="hljs-number">1</span>;<br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hash &amp; (tab.length - <span class="hljs-number">1</span>);<br>        HashEntry&lt;K,V&gt; first = tab[index];<br>        HashEntry&lt;K,V&gt; e = first;<br>        <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))<br>            e = e.next;<br><br>        <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span> || value.equals(v)) &#123;<br>                oldValue = v;<br>                <span class="hljs-comment">// All entries following removed node can stay in list, but all preceding ones need to be cloned.</span><br>                <span class="hljs-comment">// 因为next指针是final的，所以删除不能用简单的链表删除，需要把前面的节点都重新复制再插入一次，后面的节点可以重用</span><br>                <span class="hljs-comment">// 删除后，后面的可以重用的那部分顺序不变且还是放在最后，前面的被复制的那部分顺序颠倒地放在前面</span><br>                ++modCount;<br>                HashEntry&lt;K,V&gt; newFirst = e.next;<br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)<br>                    newFirst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(p.key, p.hash, newFirst, p.value);<br>                tab[index] = newFirst;<br>                count = c; <span class="hljs-comment">// write-volatile</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>在jdk1.7中的一些改变</p><p><strong>HashEntry</strong></p><p>所以现在在一个链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// hash是final的，1.7的HashMap中不是final的，用final对扩容比较友好</span><br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V value;<br>    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next; <span class="hljs-comment">// jdk1.7中next指针不再是final的，改为volatile，使用 setNext 方法（内部用Unsafe的提供的方法）更新</span><br><br>    HashEntry(<span class="hljs-type">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><h2 id="1-HashMap允许键值对为null，而Hashtable和ConcurrentHashMap不允许"><a href="#1-HashMap允许键值对为null，而Hashtable和ConcurrentHashMap不允许" class="headerlink" title="(1)HashMap允许键值对为null，而Hashtable和ConcurrentHashMap不允许"></a>(1)HashMap允许键值对为null，而Hashtable和ConcurrentHashMap不允许</h2><p><em>&#x2F;&#x2F;这里有点疑惑</em></p><p>HashMap是线程不安全的，一般用在单线程环境下，在同一个线程下，如果想要得到key的value，调用get(key)</p><p>这里如果返回null，会产生二义性：**1.<strong>可能是没有找到对应的key，</strong>2.**可能是value为null</p><p>hashMap的解决办法是：调用containskey就知道key是否为存在了。如果返回false说明不存在这个key，因为这是单线程下的，所以一定正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    HashMap.Node e;<br>    <span class="hljs-keyword">return</span> (e = <span class="hljs-built_in">this</span>.getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>    <span class="hljs-comment">//节点不存在或者value为null</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getNode(hash(key), key) != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于Hashtable，整个哈希表只有一个锁，如果一个线程操作这个哈希表，就必须先获得这个锁，假如成功获得锁，调用get(key)得到null，也会出现二义性，但是当调用完containsKey获得结果后再想利用这个结果去进行逻辑处理时可能由于其他线程的并发执行导致错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Hashtable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="hljs-built_in">this</span>.table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">2147483647</span>) % tab.length;<br><br>    <span class="hljs-keyword">for</span>(Hashtable.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[index]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;<br>            <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span> &#123;<br>    Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="hljs-built_in">this</span>.table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">2147483647</span>) % tab.length;<br><br>    <span class="hljs-keyword">for</span>(Hashtable.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[index]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-ConcurrentHashMap-和-Hashtable-的区别"><a href="#2-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="(2)ConcurrentHashMap 和 Hashtable 的区别"></a>(2)ConcurrentHashMap 和 Hashtable 的区别</h2><ol><li><p>底层数据结构</p><p>JDK1.7的ConcurrentHashMap底层采用<strong>分段数组+链表</strong>实现，JDK1.8底层采用<strong>数组+红黑树&#x2F;链表</strong>实现，而Hashtable则是采用<strong>数组+链表</strong>实现</p></li><li><p>实现线程安全的方式</p><ul><li><p>ConcurrentHashMap</p><p>JDK1.7中ConcurrentHashMap对整个桶数组进行了分割分段，每一把锁只锁一个Segment段，所以多线程下，访问不同的Segment段可以并发执行。默认的并发度是16，JDK1.8中ConcurrentHashMap将并发控制的粒度进一步细化，细化到每个桶，并发度等于桶个数，不再将容器分段，而是直接使用数组+链表&#x2F;红黑树来实现，每次访问只需要对一个桶锁定，利用**CAS(保证桶间并发操作的线程安全)<strong>和</strong>synchronized(保证桶内并发操作的线程安全)**来保证并发更新的安全。</p></li><li><p>Hashtable</p><p>使用synchronized来保证线程安全，只有一把锁(对全表的锁)，即方法锁，synchronized修饰普通方法，默认锁对象为当前实例对象this。所以每次只能有一个线程操作哈希表，效率非常低下。</p></li></ul></li></ol><h2 id="3-ConcurrentHashMap-扩容"><a href="#3-ConcurrentHashMap-扩容" class="headerlink" title="(3)ConcurrentHashMap 扩容"></a>(3)ConcurrentHashMap 扩容</h2><p>jdk8中，采用多线程扩容。整个扩容过程，通过CAS设置sizeCtl，transferIndex等变量协调多个线程进行并发扩容。多线程无锁扩容的关键就是通过<strong>CAS设置sizeCtl与transferIndex变量</strong>，协调多个线程对table数组中的node进行迁移。</p><p><strong>何时触发扩容？</strong></p><p>当往hashMap中成功插入一个key&#x2F;value节点时，有可能触发扩容动作：</p><p>当新增完这个节点后，如果链表长度大于树化阈值8，会先判断table的长度是否超过64，如果没有，则会把数组长度扩大到原来的两倍，并触发transfer方法，重新调整节点的位置。如果大于64，就将链表转换为红黑树。</p><p><strong>与此同时，</strong>会调用addCount方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值(table容量*负载因子)时，会触发transfer方法，重新调整节点的位置。</p><p>如果当前线程发现此时map正在扩容，则协助扩容</p><p>如果准备加入扩容的线程，发现以下情况，放弃扩容，直接返回</p><p>a、发现transferIndex&#x3D;0,即所有node均已分配<br>b、发现扩容线程已经达到最大扩容线程数</p><p><strong>transferIndex 扩容索引</strong></p><p>初始值是table的长度，刚开始位于数组的最右边，每个线程最少扩容的桶个数为16，当每次来一个线程进行扩容，transferIndex就向左移动16**(以CAS的方式操作transferIndex变量，确保扩容的并发安全)**，标志还剩多少桶等待扩容，当transferIndex为0时，说明所有桶都被分配了线程扩容。这个扩容线程按照逆序进行节点的迁移工作(<strong>逆序遍历扩容</strong>)。</p><p><strong>其他线程什么时候帮忙扩容？</strong></p><p>此时其他线程访问到了ForwardingNode节点，如果这个线程执行的put或remove等写操作，那么就会先帮其扩容。如果这个线程执行的是get等读方法，则会调用ForwardingNode的find方法，去nextTable里面查找相关元素</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>线程安全集合类</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-日志</title>
    <link href="/2022/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E6%97%A5%E5%BF%97/"/>
    <url>/2022/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 <code>二进制日志</code> 、 <code>错误日志</code> 、 <code>通用查询日志</code>和 <code>慢查询日志</code> ，这也是常用的4种。</p><p><code>MySQL 8</code>又新增两种支持的日志： <code>中继日志</code> 和 <code>数据定义语句日志</code> 。</p><p>使用这些日志文件，可以查看MySQL内部发生的事情。</p><p>除<code>二进制日志</code>外，其他日志都是 <code>文本文件</code> 。 默认情况下，所有日志创建于 <code>MySQL数据目录</code> 中，即&#x2F;var&#x2F;lib&#x2F;mysql。</p><p><img src="/image/mysql/mysql70.png"></p><h1 id="1-通用查询日志"><a href="#1-通用查询日志" class="headerlink" title="1.通用查询日志"></a>1.通用查询日志</h1><p>通用查询日志用来 <code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。</p><hr><p>查看通用查询日志当前的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看通用查询日志当前的状态<br>mysql&gt; SHOW VARIABLES LIKE &#x27;%general%&#x27;;<br>+------------------+------------------------------+<br>| Variable_name  | Value            |<br>+------------------+------------------------------+<br>| general_log   | OFF             | #通用查询日志处于关闭状态<br>| general_log_file | /var/lib/mysql/atguigu01.log | #通用查询日志文件的名称是atguigu01.log，atguigu01是linux下的主机名<br>+------------------+------------------------------+<br>2 rows in set (0.03 sec)<br><br>#关闭通用查询日志<br>SET GLOBAL general_log=off; <br></code></pre></td></tr></table></figure><hr><p>默认是关闭的状态，所以需要先<strong>启动日志</strong></p><p><strong>方式1：永久性方式</strong>：<br> 修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[mysqld]<br>general_log=ON<br>general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名<br></code></pre></td></tr></table></figure><p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。</p><p><strong>方式2：临时性方式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL general_log=on;  # 开启通用查询日志<br><br>SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置<br></code></pre></td></tr></table></figure><hr><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@iz2zeip0loevltpebhi0txz mysql]# cat iz2zeip0loevltpebhi0txz.log<br>/usr/sbin/mysqld, Version: 8.0.28 (MySQL Community Server - GPL). started with:<br>Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock<br>Time                 Id Command    Argument<br>2022-04-07T08:44:50.256726Z  149 Queryselect * from tb_user9<br>2022-04-07T08:45:26.927677Z  149 Queryinsert into tb_user9 values(16,&#x27;赵六&#x27;)<br></code></pre></td></tr></table></figure><hr><p><strong>停止日志</strong></p><p><strong>方式1：永久性方式</strong>：<br> 修改 <code>my.cnf</code> 或者 <code>my.ini</code> 文件，把[mysqld]组下的 <code>general_log</code> 值设置为 <code>OFF</code> 或者把<code>general_log</code>一项注释掉。修改保存后，再 <code>重启MySQL服务</code> ，即可生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[mysqld]<br>general_log=OFF #或者将这一行注释<br></code></pre></td></tr></table></figure><blockquote><p>刷新MySQL数据目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqladmin -uroot -p flush-logs<br></code></pre></td></tr></table></figure></blockquote><h1 id="2-错误日志-error-log"><a href="#2-错误日志-error-log" class="headerlink" title="2.错误日志(error log)"></a>2.错误日志(error log)</h1><p><strong>启动日志</strong></p><p>在MySQL数据库中，<code>错误日志</code>功能是 <code>默认开启</code> 的。而且，<code>错误日志</code> 无法被禁止 。</p><p>默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 <code>mysqld.log （Linux系统）</code>或<code>hostname.err （mac系统）</code>。</p><hr><p><strong>查看日志</strong></p><p>MySQL错误日志是以<code>文本文件形式</code>存储的，可以使用文本编辑器直接查看。</p><p>查看错误日志的存储路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;log_err%&#x27;;<br></code></pre></td></tr></table></figure><h1 id="3-二进制日志-bin-log"><a href="#3-二进制日志-bin-log" class="headerlink" title="3.二进制日志(bin log)"></a>3.二进制日志(bin log)</h1><h2 id="3-1概念以及具体命令"><a href="#3-1概念以及具体命令" class="headerlink" title="3.1概念以及具体命令"></a>3.1概念以及具体命令</h2><p>它记录了数据库所有执行的<code>DDL</code> 和 <code>DML</code> 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p><p>bin log主要应用场景：</p><ul><li>用于<code>数据恢复</code></li><li>用于 <code>数据复制</code></li></ul><p>查看记录二进制日志是否开启：在<code>MySQL8中默认</code>情况下，<code>二进制文件是开启的</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%log_bin%&#x27;;<br>+---------------------------------+-----------------------------+<br>| Variable_name                   | Value                       |<br>+---------------------------------+-----------------------------+<br>| log_bin                         | ON                          |<br>| log_bin_basename                | /var/lib/mysql/binlog       |<br>| log_bin_index                   | /var/lib/mysql/binlog.index |<br>| log_bin_trust_function_creators | ON                          |<br>| log_bin_use_v1_row_events       | OFF                         |<br>| sql_log_bin                     | ON                          |<br>+---------------------------------+-----------------------------+<br>6 rows in set (0.00 sec)<br>###############################################<br>[root@iz2zeip0loevltpebhi0txz mysql]# ll<br>total 225064<br>-rw-r----- 1 mysql mysql       56 Mar 22 08:39 auto.cnf<br>-rw-r----- 1 mysql mysql      478 Mar 22 09:13 binlog.000001<br>-rw-r----- 1 mysql mysql  3484717 Apr  5 14:50 binlog.000002<br></code></pre></td></tr></table></figure><p>MySQL服务 <code>重新启动一次</code> ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了 <code>max_binlog_size</code> 的上限（<code>默认是1GB</code>），就会创建一个新的日志文件。</p><blockquote><p>systemctl restart mysqld;</p></blockquote><p>也可以修改这个名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[mysqld]<br>#启用二进制日志<br>log-bin=atguigu-bin #这就是binlog文件的名字<br>binlog_expire_logs_seconds=600 #二进制文件保存时间<br>max_binlog_size=100M #文件大小，超过这个大小就会默认再生成一个文件<br></code></pre></td></tr></table></figure><p><strong>临时性方式开启或关闭binlog</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># session级别<br># 在mysql8中只有会话级别的设置，没有了global级别的设置。<br>mysql&gt; SET session sql_log_bin=0;<br>Query OK, 0 rows affected (0.01 秒)<br></code></pre></td></tr></table></figure><hr><p><strong>查看日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binary logs;<br>+---------------+-----------+-----------+<br>| Log_name      | File_size | Encrypted |<br>+---------------+-----------+-----------+<br>| binlog.000001 |       478 | No        |<br>| binlog.000002 |   3485034 | No        |<br>| binlog.000003 |       157 | No        |<br>+---------------+-----------+-----------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql71.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; insert into tb_user9 values(17,&#x27;钱七&#x27;);<br>Query OK, 1 row affected (0.01 sec)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql71.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];<br></code></pre></td></tr></table></figure><p>[IN ‘log_name’]：指定要查询的binlog文件名，不指定就是第一个</p><p>[FROM pos]：指定从哪个pos位置开始查，不指定就是从文件的第一个pos开始</p><p>[LIMIT [offset,] row_count]：偏移量和查询的总行数</p><hr><p>用日志恢复数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [option] filename|mysql –uuser -ppass;<br></code></pre></td></tr></table></figure><p>使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p><hr><p><strong>删除部分二进制文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除创建时间比binlog.000002早的所有日志<br>purge master logs to &#x27;binlog.000002&#x27;<br></code></pre></td></tr></table></figure><h2 id="3-2-原理"><a href="#3-2-原理" class="headerlink" title="3.2 原理"></a>3.2 原理</h2><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到 binlog cache ，事务提交的时候，再把binlog cache写到binlog文件中。（类比redo log）</p><p>因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p><img src="/image/mysql/mysql73.png"></p><p>write和fsync的时机，可以由参数 <code>sync_binlog</code> 控制，默认是 <code>0</code> 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。</p><p>为了安全起见，可以设置为 <code>1</code>，表示每次提交事务都会执行fsync，就如同<code>redo log 刷盘流程一样</code>。</p><p>最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但<code>累积N个事务后才fsync</code>。</p><hr><p><strong>binlog与redolog对比</strong></p><p><img src="/image/mysql/mysql74.png"></p><p>redo log是在物理层面，涉及索引和页，修改了什么</p><p>binlog是你执行了什么sql命令，记录的是这个命令</p><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 <code>写入时机</code> 不一样。</p><h1 id="4-中继日志"><a href="#4-中继日志" class="headerlink" title="4.中继日志"></a>4.中继日志</h1><p>中继日志只在主从服务器架构的从服务器上存在，从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志，然后从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p><p>中继日志默认保存在从服务器的数据目录下，文件名格式是从服务器名-relay-bin.序号</p><p>还有一个索引文件，从服务器名-relay-bin.index来定位正在使用的中继日志</p><p>中继日志与二进制日志的格式相同。</p><h1 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5.主从复制"></a>5.主从复制</h1><p><strong>为什么会出现主从复制？</strong></p><p>一般对于数据库都是读多写少，也就是对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做主从架构，进行读写分离，这样也可以提高数据库的并发处理能力。</p><p><strong>主从复制的作用：</strong></p><p>读写分离、数据备份、高可用性</p><hr><h2 id="5-1原理"><a href="#5-1原理" class="headerlink" title="5.1原理"></a>5.1原理</h2><p><code>Slave</code> (从服务器)会从 <code>Master</code> (主服务器)读取 <code>binlog</code> 来进行数据同步。</p><ol><li><strong>二进制日志转储dump线程</strong> （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 加锁 (因为数据更新需要写入binlog，而这时候如果dump线程进行读的话就会造成并发问题，因此需要加锁)，读取完成之后，再将锁释放掉。</li><li><strong>从库 I&#x2F;O 线程</strong> 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</li><li><strong>从库 SQL 线程</strong> 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</li></ol><p><img src="/image/mysql/mysql75.png"></p><h2 id="5-2-保证主机从机数据一致"><a href="#5-2-保证主机从机数据一致" class="headerlink" title="5.2 保证主机从机数据一致"></a>5.2 保证主机从机数据一致</h2><p><strong>为什么会出现主从数据不一致问题</strong>？</p><p>进行主从同步的内容是二进制日志，它是一个文件，在进行 <code>网络传输</code> 的过程中就一定会 <code>存在主从延迟（比如 500ms）</code>，这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的 <code>数据不一致性</code> 问题。</p><ol><li>从机的机器性能比主机要差</li><li>从机的压力大</li><li>事务比较大(binlog文件大)</li></ol><hr><p><strong>如何解决一致性问题</strong></p><ol><li>异步复制</li><li>半同步复制</li><li>组复制</li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
      <tag>日志文件</tag>
      
      <tag>主从复制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-锁</title>
    <link href="/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E9%94%81/"/>
    <url>/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/mysql/mysql66.png"></p><p><strong>对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上</strong>。</p><h1 id="1-从数据的操作类型划分"><a href="#1-从数据的操作类型划分" class="headerlink" title="1.从数据的操作类型划分"></a>1.从数据的操作类型划分</h1><p>**读锁&#x2F;共享锁(Shared Lock，S  Lock)**：即S锁，</p><p>**写锁&#x2F;排他锁(Exclusive Lock，X  Lock)**：即X锁</p><hr><p><code>对于读操作：</code></p><p>对读取的记录加上S锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select ... lock in share mode;<br>#或<br>select ... for share;<br></code></pre></td></tr></table></figure><p>这样后面的事务可以对这些记录加S锁，但是不能加X锁</p><p>对读取的记录加X锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select ... for update;<br></code></pre></td></tr></table></figure><p>这样其他事务就不可以对这些记录加S锁和X锁</p><p>可以在这些加锁的SQL语句后面加上nowait或者skip locked，这样当获取不到锁的时候就不会一直等待，而是直接报错或者结束，返回空</p><hr><p><code>对于写操作：</code></p><p>必须加上X锁</p><hr><h1 id="2-从数据操作的粒度划分"><a href="#2-从数据操作的粒度划分" class="headerlink" title="2.从数据操作的粒度划分"></a>2.从数据操作的粒度划分</h1><p>针对不同的数据规模进行加锁，其并发度也不同，如果将锁加在一行记录上，获得的并发度是最大的，加在表上，并发度是最小的，而且管理锁也是很消耗资源的，因此数据库系统需要在并发响应和系统性能两方面进行平衡，这样就产生了<code>锁粒度</code>的概念。</p><p>行锁的锁粒度最细</p><h2 id="2-1-表级锁"><a href="#2-1-表级锁" class="headerlink" title="2.1 表级锁"></a>2.1 表级锁</h2><p>表级锁会锁定整张表，它是MySQL中最基本的锁策略，因此它并不依赖于存储引擎，而且表锁的开销比较小，粒度比较大。</p><h3 id="1-表级别的S锁、X锁"><a href="#1-表级别的S锁、X锁" class="headerlink" title="(1)表级别的S锁、X锁"></a>(1)表级别的S锁、X锁</h3><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 <code>S锁</code> 和 <code>X锁</code> 。只会在一些特殊情况下，比方说 崩溃恢复 过程中用到。而由于MyISAM没有行锁，所以<strong>一般在MyISAM中使用表级锁</strong>。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p><ul><li><p>表共享读锁（Table Read Lock）S锁</p><p>自己可以读，自己不能写， 也不能操作其他表，别人可读，不可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">lock tables 表名 read;<br></code></pre></td></tr></table></figure></li><li><p>表独占写锁（Table Write Lock）X锁</p><p>自己可写可读，自己不可以操作其他表，别人不可以读和写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">lock tables 表名 write;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-意向锁（intention-lock）"><a href="#2-意向锁（intention-lock）" class="headerlink" title="(2)意向锁（intention lock）"></a>(2)意向锁（intention lock）</h3><p>为什么要有意向锁？</p><p>假如事务A在表T的某一行加了排他锁，那事务B想要在表T上加表级别的排它锁时，需要将这个表中的所有记录都遍历一遍，看看是否有行锁存在，如果没有，才可以加表锁，这步操作如果表中的记录很多时，非常消耗时间，因此在InnoDB中当为表中某行记录加锁后，会自动为表加一个意向锁，这样当另一个事务来加表锁，一看这个意向锁，就不可以加锁了。</p><hr><p>InnoDB支持多粒度锁，它允许行级锁和表级锁共存，而意向锁就是其中的一种表锁。</p><p><strong>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁</strong>，在为数据行加共享&#x2F;排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁。</p><ul><li><p>意向共享锁（intention shared lock, IS）</p><p>事务有意向对表中的某些行加共享锁，InnoDB存储引擎会自动给这个表加上IS锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select column from table ... lock in share mode;<br></code></pre></td></tr></table></figure></li><li><p>意向排他锁（intention exclusive lock, IX）</p><p>事务有意向对表中的某些行加排他，InnoDB存储引擎会自动给这个表加上IX锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select column from table ... for update;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-自增锁（AUTO-INC锁）"><a href="#3-自增锁（AUTO-INC锁）" class="headerlink" title="(3)自增锁（AUTO-INC锁）"></a>(3)自增锁（AUTO-INC锁）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `teacher` (<br> `id` int NOT NULL AUTO_INCREMENT,<br> `name` varchar(255) NOT NULL,<br> PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure><p>当创建这个表时，在id字段上添加了自增属性</p><p>在MySQL8.0是交错锁定模式</p><h3 id="4-元数据锁（MDL锁）"><a href="#4-元数据锁（MDL锁）" class="headerlink" title="(4)元数据锁（MDL锁）"></a>(4)元数据锁（MDL锁）</h3><p>meta data lock，简称MDL锁，属于表锁范畴。</p><p>当对一个表做增删改查操作的时候，加 <code>MDL</code>读锁；当要对表做结构变更操作的时候，加 <code>MDL</code> 写锁。</p><p>不需要显示使用，在访问一个表的时候会被自动加上</p><h2 id="2-2-页级锁"><a href="#2-2-页级锁" class="headerlink" title="2.2 页级锁"></a>2.2 页级锁</h2><p>在页的粒度上进行锁定。</p><h2 id="2-3-InnoDB中的行锁-MyISAM中没有行锁"><a href="#2-3-InnoDB中的行锁-MyISAM中没有行锁" class="headerlink" title="2.3 InnoDB中的行锁(MyISAM中没有行锁)"></a>2.3 InnoDB中的行锁(MyISAM中没有行锁)</h2><h3 id="1-记录锁（Record-Locks）"><a href="#1-记录锁（Record-Locks）" class="headerlink" title="(1)记录锁（Record Locks）"></a>(1)记录锁（Record Locks）</h3><p>指把一条记录锁上，类型名称为：LOCK_REC_NOT_GAP，将一条记录加行锁，对其他记录没有影响</p><p>记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后(当一个事务update但不提交时，就会自动获得一个记录锁)，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><h3 id="2-间隙锁（Gap-Locks）"><a href="#2-间隙锁（Gap-Locks）" class="headerlink" title="(2)间隙锁（Gap Locks）"></a>(2)间隙锁（Gap Locks）</h3><p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。</p><p>对一条记录加gap锁，不会限制其他事务对这条记录加记录锁或者继续加gap锁，只是限制了在某个间隙不能insert操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from tb_user9;<br>+-------+----------+<br>| tb_id | tb_name  |<br>+-------+----------+<br>|     1 | 张三     |<br>|     3 | 李四     |<br>|     4 | 王五5    |<br>|     6 | 王五5    |<br>|     7 | 王五7    |<br>|     8 | 王五     |<br>|     9 | 王五     |<br>|    15 | 王五15   |<br>+-------+----------+<br>#事务A查找id为10这条记录不存在后，就会自动在(9,15)加上间隙锁<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; select * from tb_user9 where tb_id = 10 for update;<br>Empty set (0.00 sec)#无论这里是不是空，这个范围内都不允许被insert<br>#事务B想要对这个范围插入一条记录，就会被阻塞<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; insert into tb_user9 values(13,&#x27;王五13&#x27;);<br>#（阻塞），直到事务A提交了事务，放弃间隙锁<br></code></pre></td></tr></table></figure><h3 id="3-临键锁（Next-key-Locks）"><a href="#3-临键锁（Next-key-Locks）" class="headerlink" title="(3)临键锁（Next-key Locks）"></a>(3)临键锁（Next-key Locks）</h3><p>记录锁和gap锁的合体，在这个范围内不允许被insert，如果是写锁，在边界处不允许被读和写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; begin;<br>mysql&gt; select * from tb_user9 where tb_id &gt; 9 and tb_id &lt;= 15 for update;<br></code></pre></td></tr></table></figure><h3 id="4-插入意向锁（Insert-Intention-Locks）"><a href="#4-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="(4)插入意向锁（Insert Intention Locks）"></a>(4)插入意向锁（Insert Intention Locks）</h3><p>如果一个事务在插入数据的时候，这个id所在的范围内有间隙锁或临键锁，则这个插入操作不能执行，需要等待这个锁释放，这时也会给这步骤加一个锁，即插入意向锁。</p><p>插入意向锁是一种 <code>Gap锁</code> ，不是意向锁，在insert操作时产生。<code>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</code>。</p><h1 id="3-锁的内部结构"><a href="#3-锁的内部结构" class="headerlink" title="3.锁的内部结构"></a>3.锁的内部结构</h1><p><img src="/image/mysql/mysql67.png"></p><ol><li><p>锁所在的事务信息 ：<br>不论是 表锁 还是 行锁，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。<br>此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p></li><li><p>索引信息 ：<br>对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p></li><li><p>表锁／行锁信息 ：<br>表锁结构和 行锁结构 在这个位置的内容是不同的：</p></li><li><p>type_mode ：<br> 这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分</p><p><img src="/image/mysql/mysql68.png"></p></li><li><p>如果是行锁，在该结构后面还放置了一堆比特位，比特位的数量是由上边提到的n_bits属性表示的。在记录头中有heap_no这个属性，最小记录和最大记录对应的它的值是0，1。之后每插入一条数据记录中的这个属性就增1</p></li></ol><h1 id="4-查看MySQL的锁情况"><a href="#4-查看MySQL的锁情况" class="headerlink" title="4. 查看MySQL的锁情况"></a>4. 查看MySQL的锁情况</h1><p>1.行锁情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show status like &#x27;innodb_row_lock%&#x27;;<br></code></pre></td></tr></table></figure><p>2.查询正在被锁阻塞的sql语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.INNODB_TRX\G;<br></code></pre></td></tr></table></figure><p>3.查询锁等待情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM data_lock_waits\G;<br></code></pre></td></tr></table></figure><p>4.查询锁的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from performance_schema.data_locks\G;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-MVCC</title>
    <link href="/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/MVCC/"/>
    <url>/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/MVCC/</url>
    
    <content type="html"><![CDATA[<p>MVCC，即（Multiversion Concurrency Control）多版本并发控制，</p><p>MVCC 是通过数据行的<strong>多个版本</strong>管理来实现数据库的 <code>并发控制</code> 。这项技术使得在InnoDB的事务隔离级别下执行 <code>一致性读</code> 操作有了保证。</p><p>最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有<strong>写写</strong>之间相互<strong>阻塞</strong>，其他三种操作都可以并行。</p><blockquote><p>解决脏读、不可重复读、幻读这些问题有两种解决方案：</p><ol><li>MVCC，写操作进行加锁，读-写不冲突</li><li>读、写操作都采用加锁的方式</li></ol></blockquote><p>读、写操作中，读就是快照，写就是当前读。</p><h1 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1.快照读"></a>1.快照读</h1><p>快照读，又叫一致性读，读取的是快照数据。不加锁的简单的SELECT都属于快照读，快照读可能读取到的并不一定是数据的最新版本，也可能是之前的历史版本。这是要保证一致性读，就算一个事务更新了某行数据，另一个事务读取的还必须是当前事务开始时的数据版本，保证一致性读。</p><h1 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2.当前读"></a>2.当前读</h1><p>当前读读取的是记录的最新版本，而不是历史版本的数据，读取的时候还要保证其他并发事务不能修改当前记录，会对读取的就进行加锁。</p><p>因此加锁的SELECT或对数据增删改查都会进行当前读。</p><h1 id="3-MVCC的实现原理"><a href="#3-MVCC的实现原理" class="headerlink" title="3.MVCC的实现原理"></a>3.MVCC的实现原理</h1><p>MVCC的实现依赖于：<strong>隐藏字段、Undo Log、Read View</strong></p><h2 id="3-1-隐藏字段"><a href="#3-1-隐藏字段" class="headerlink" title="3.1 隐藏字段"></a>3.1 隐藏字段</h2><p>在InnoDB存储结构那篇文章中，页中记录的用户记录中，在记录的真实数据的部分有三个隐藏的列。</p><ol><li>row_id，不是必须的，表示行ID，唯一标识一条记录</li><li>transaction_id，是必须的，每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 <code>事务id</code> 赋值给<code>trx_id</code> 隐藏列。</li><li>roll_pointer，是必须的，表示回滚指针，每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 <code>undo日志</code> 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ol><p>我们主要看后两个。</p><h2 id="3-2-Undo-Log日志"><a href="#3-2-Undo-Log日志" class="headerlink" title="3.2 Undo Log日志"></a>3.2 Undo Log日志</h2><blockquote><p><strong>insert undo log</strong>： 事务在insert新记录时产生的undo log<br>只在事务回滚时需要，并且在事务提交后可以被立即丢弃<br><strong>update undo log</strong>： 事务在进行update或delete时产生的undo log，不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><p>引用：<a href="https://blog.csdn.net/qq_39150049/article/details/120638319">https://blog.csdn.net/qq_39150049/article/details/120638319</a></p></blockquote><p>对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 版本链 ，版本链的头节点就是当前记录最新的值。</p><p>每个版本中还包含生成该版本时对应的 事务id 。</p><h2 id="3-3-Read-View"><a href="#3-3-Read-View" class="headerlink" title="3.3 Read View"></a>3.3 Read View</h2><p>Read View是事务进行快照读操作的时候生产的读视图，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID（活跃指的是启动了但还没提交），<strong>当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大。(不过只有增删改才会被分配事务ID，在一个只读事务中的事务ID默认是0)</strong></p><p>Read View解决的问题就是判断哪一个版本链中的哪个版本是当前事务可见的。</p><hr><p>Read View中主要包含：</p><ol><li>creator_trx_id：创建这个Read View的事务ID</li><li>trx_ids：表示在生成Read View时当前系统中活跃的读写事务的事务ID列表</li><li>up_limit_id：活跃列表中活跃的事务中最小的事务ID</li><li>low_limit_id：值等于系统中最大的事务ID(包括已提交和未提交)+1</li></ol><hr><p>当隔离级别为<strong>可重复读</strong>的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View</p><hr><p>Read View的对比规则</p><ul><li>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的；</li><li>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若 row 的 trx_id 就是当前自己的事务是可见的）；</li><li>如果 row 的 trx_id 落在中间粉色部分(min_id &lt;&#x3D;trx_id&lt;&#x3D; max_id)，那就包括两种情况<ul><li>若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)；</li><li>若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ul></li></ul><p><img src="/image/mysql/mysql69.png"></p><blockquote><p>这篇文章里写有真实流程分析，不错</p><p><a href="https://blog.csdn.net/qq_39150049/article/details/120638319">https://blog.csdn.net/qq_39150049/article/details/120638319</a></p></blockquote><hr><p>核心点在于 ReadView 的原理， READ COMMITTD 、 REPEATABLE READ 这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p><ul><li><strong>READ COMMITTD</strong> 在每一次进行普通SELECT操作前都会生成一个ReadView</li><li><strong>REPEATABLE READ</strong> 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
      <tag>MVCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-InnoDB中数据存储结构(页)</title>
    <link href="/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-页的概念"><a href="#1-页的概念" class="headerlink" title="1.页的概念"></a>1.页的概念</h1><ul><li><p>磁盘和内存交互的基本单位是<code>页</code>，一次最少从磁盘读取一个页的内容到内存中。</p></li><li><p>数据库的存储结构也是<code>页</code>，InnoDB将数据划分为若干个页，<code>InnoDB中页的默认大小是16KB</code>，因此在数据库中，无论读一行还是多行，都需要将这些行所在的页加载到内存，即数据库I&#x2F;O操作的最小单位是页。</p></li><li><p>数据库中多个页可以不在物理结构上相连，只需要通过双向链表相互关联即可，每个数据页中的记录按照<code>主键值从小到大的顺序</code>组成一个单向链表。</p></li><li><p>多个数据页对应一个页目录，在查找某条记录时只需要在页目录(数组)中使用二分法查找定位对应的页号范围，然后在遍历这个页。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%innodb_page_size%&#x27;;<br>+------------------+-------+<br>| Variable_name    | Value |<br>+------------------+-------+<br>| innodb_page_size | 16384 |<br>+------------------+-------+<br>1 row in set (0.01 sec)<br><br></code></pre></td></tr></table></figure><h1 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2.页的内部结构"></a>2.页的内部结构</h1><p>页按照类型划分，常见的有数据页(保存B+树节点)，系统页，Undo页，事务数据页。</p><p><strong>数据页的16KB包括这七个部分：</strong></p><ol><li><p>文件头(File Header) 38B，描述页的信息</p></li><li><p>页头(Page Header) 56B，页的状态信息</p></li><li><p>最大、最小记录(Infimum+supremum) 26B，虚拟的行记录</p></li><li><p>用户记录(User Records)，存储行记录内容</p></li><li><p>空闲空间(Free Space)，页中还没有被使用的页</p></li><li><p>页目录(Page Directory)，存储用户记录的相对位置</p></li><li><p>文件尾(File Tailer) 8B，检验页是否完整</p></li></ol><h2 id="2-1-文件头和文件尾"><a href="#2-1-文件头和文件尾" class="headerlink" title="2.1 文件头和文件尾"></a>2.1 文件头和文件尾</h2><p>文件头的结构：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHECKSUM</td><td>4字节</td><td>页的检验和，和文件尾的<code>检验和</code>一起维护页的完整性。当页从磁盘同步到内存或者从内存同步到磁盘后，会检验首尾的检验和是否一致，一致就说明页完整。</td></tr><tr><td><strong>FIL_PAGE_OFFSET</strong></td><td><strong>4字节</strong></td><td><strong>页号，每个页都有唯一的页号，InnoDB通过页号可以唯一确定一个页</strong></td></tr><tr><td><strong>FIL_PAGE_PREV</strong></td><td><strong>4字节</strong></td><td><strong>上一个页的页号</strong></td></tr><tr><td><strong>FIL_PAGE_NEXT</strong></td><td><strong>4字节</strong></td><td><strong>下一个页的页号</strong></td></tr><tr><td>FIL_PAGE_LSN</td><td>8字节</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td><strong>FIL_PAGE_TYPE</strong></td><td><strong>2字节</strong></td><td><strong>页的类型，比较常用的页的类型有：1.<code>FIL_PAGE_INDEX</code>索引页&#x2F;数据页，0x45BF 2.<code>FIL_PAGE_UNDO_LOG</code>Undo日志页，0x0002 3.<code>FIL_PAGE_TYPE_SYS</code>系统页，0x0006</strong></td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr></tbody></table><p>文件尾的结构：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHECKSUM</td><td>4B</td><td>校验和</td></tr><tr><td>FIL_PAGE_LSN</td><td>4B</td><td>代表页面被最后修改时对应的日志序列位置，头部和尾部的LSN值不相等说明页不完整</td></tr></tbody></table><h2 id="2-2-最大最小记录、用户记录、空闲空间"><a href="#2-2-最大最小记录、用户记录、空闲空间" class="headerlink" title="2.2 最大最小记录、用户记录、空闲空间"></a>2.2 最大最小记录、用户记录、空闲空间</h2><h3 id="2-2-1-空闲空间"><a href="#2-2-1-空闲空间" class="headerlink" title="2.2.1 空闲空间"></a>2.2.1 空闲空间</h3><p>一开始生成的页中并没有用户记录这部分空间，每当我们插入一条记录，都会从空闲空间部分(未使用的存储空间)中申请一个记录大小的空间划分到用户记录部分，当空闲空间全部被用户记录替代掉后，再有新的记录插入时就需要去申请新的页了。</p><h3 id="2-2-2-用户记录"><a href="#2-2-2-用户记录" class="headerlink" title="2.2.2 用户记录"></a>2.2.2 用户记录</h3><p>记录按照指定的<code>行格式</code>一条一条摆放在用户记录空间部分，相互之间形成单链表。</p><p>十六进制中两个数连在一起是一个字节。</p><hr><p>行格式有<strong>COMPACT行格式</strong>、DYNAMIC行格式</p><h4 id="2-2-2-1-COMPACT行格式"><a href="#2-2-2-1-COMPACT行格式" class="headerlink" title="2.2.2.1 COMPACT行格式"></a>2.2.2.1 COMPACT行格式</h4><ul><li><p><font color='red'><strong>变长字段长度列表 (2B)</strong></font></p><p> 用varchar修饰的字段中存储多少字节的数据不是固定的，在Compact行格式中，把所有变长字段的<code>真实数据占用的字节长度</code>都存放在记录的开头部位，就是这个变长字段长度列表。</p><p>列表里面存储的变长长度和字段顺序是反过来的，比如两个varchar字段在表结构中的顺序是a varchar(10)，b varchar(15)，a&#x3D;’zhangsan’ (长度为8)，b&#x3D;’lisi’ (长度为4)，那么在变长字段长度列表中存储的长度顺序就是04，08 (最后以十六进制存)</p></li><li><p><font color='red'><strong>NULL值列表 (1B)</strong></font></p><p>当表中某几个字段值为NULL时，如果不管它，到时候可能会在查询数据的时候出现位置错乱，导致读取结果不正确，因此专门在行数据的头部设置一个NULL值列表标志哪个字段当前取值是NULL</p><ul><li><font color='blue'>二进制位的值为1，表示该列的值为NULL</font></li><li><font color='blue'>二进制位的值为0，表示该列的值不为NULL</font></li></ul><p>将最终的取值倒序存放到NULL值列表中(如果这一列刚开始就被定义成NOT NULL或者是主键(也是非空)，就不需要标记这一位了)</p></li><li><p><font color='red'><strong>记录头信息 (5B)</strong></font></p><ul><li><p><font color='blue'>预留位1、2没有使用</font></p></li><li><p><font color='blue'>delete_mask (1bit)</font></p><p>标志当前记录是否被删除，值为0代表记录没有被删除，值为1代表记录被删除</p></li><li><p><font color='blue'>min_rec_mask</font></p><p>在存储目录项记录的页中主键值最小的目录项记录的min_rec_mask的值为1，其他记录的min_rec_mask值都是0，B+树的每层非叶子节点中的最小记录都会添加该标记</p></li><li><p><font color='blue'>record_type</font></p><p>表示当前记录的类型</p><ul><li><font color='purple'>record_type &#x3D; 0</font>：普通记录</li><li><font color='purple'>record_type &#x3D; 1</font>：B+树的非叶子节点记录</li><li><font color='purple'>record_type &#x3D; 2</font>：最小记录</li><li><font color='purple'>record_type &#x3D; 3</font>：最大记录</li></ul></li><li><p><font color='blue'>heap_no</font></p><p>表示当前记录在本页中的位置。</p><ul><li><font color='purple'>heap_no &#x3D; 0</font>：表示最小记录</li><li><font color='purple'>heap_no &#x3D; 1</font>：表示最大记录</li><li><font color='purple'>后面添加用户数据记录时，heap_no的值每次加1</font></li></ul></li><li><p><font color='blue'>n_owned</font></p><p>如果当前记录时所在组的最后一条记录，那n_owned的值为所在组的记录个数，如果当前记录不是所在组的最后一条记录，那n_owned的值就是0</p></li><li><p><font color='blue'>next_record</font></p><p>表示当前记录的真实数据到下一条记录的真实数据的地址偏移量</p></li></ul></li><li><p><font color='red'><strong>记录的真实数据</strong></font></p><ul><li><p><font color='blue'>三个隐藏的列</font></p><ul><li><font color='purple'>DB_ROW_ID (6B)</font>：row_id，不是必须的，表示行ID，唯一标识一条记录</li><li><font color='purple'>DB_TRX_ID (6B)</font>：transaction_id，是必须的，表示事务ID</li><li><font color='purple'>DB_ROLL_PTR (7B)</font>：roll_pointer，是必须的，表示回滚指针</li></ul><p>如果一个表没有定义主键，会选择一个Unique键作为主键，如果连Unique键都没有，才会为表默认添加一个名为row_id的隐藏列作为主键，否则row_id不会出现。</p></li><li><p><font color='blue'>自己定义的列的数据</font></p></li></ul></li></ul><h4 id="2-2-2-1-其他行格式"><a href="#2-2-2-1-其他行格式" class="headerlink" title="2.2.2.1 其他行格式"></a>2.2.2.1 其他行格式</h4><p>Dynamic和Compressed  跟Compact行格式差不多，但是有一点不一样。</p><blockquote><p>行溢出：我们知道一个页的最大空间是16KB，即16*1024 &#x3D; 16384B，而当我们把一个变长字段varchar的最大的长度设置为65535时，一个页连一条行记录都存储不了了，这就是行溢出。</p></blockquote><p>在处理行溢出时采用的策略不同，Compact会在记录中存储部分真实数据，然后将剩余部分的内容分页存储在其他的页中，在原来的存储部分真实数据的后面的空间中存储存储指向这些页的地址。而Dynamic和Compressed则不会在行记录中存储这些数据，而是全部存储在其他页中，在行记录中只存储这些页的地址。</p><p>Redundant行格式：没有NULL值列表，并且变长字段偏移量中每个字段的长度都是是从开头开始计算的。并且记录头信息中有些区别。</p><hr><p><code>相关命令：</code></p><p>查看MySQL8的默认行格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select @@innodb_default_row_format;<br>+-----------------------------+<br>| @@innodb_default_row_format |<br>+-----------------------------+<br>| dynamic                     |<br>+-----------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>创建表时可以指定表的行格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user4(id int,name varchar(20))row_format=compact;<br>Query OK, 0 rows affected (0.02 sec)<br><br>mysql&gt; show table status like &#x27;tb_user4&#x27;\G;<br>*************************** 1. row ***************************<br>           Name: tb_user4<br>         Engine: InnoDB<br>        Version: 10<br>     Row_format: Compact<br>           Rows: 0<br> Avg_row_length: 0<br>    Data_length: 16384<br>Max_data_length: 0<br>   Index_length: 0<br>      Data_free: 0<br> Auto_increment: NULL<br>    Create_time: 2022-03-24 17:30:15<br>    Update_time: NULL<br>     Check_time: NULL<br>      Collation: utf8mb4_0900_ai_ci<br>       Checksum: NULL<br> Create_options: row_format=COMPACT<br>        Comment: <br>1 row in set (0.00 sec)<br><br></code></pre></td></tr></table></figure><p>修改行格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table tb_user2 row_format=compact;<br>Query OK, 0 rows affected (0.05 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br></code></pre></td></tr></table></figure><h3 id="2-2-3-最小最大记录"><a href="#2-2-3-最小最大记录" class="headerlink" title="2.2.3 最小最大记录"></a>2.2.3 最小最大记录</h3><p>这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为<code>Infimum + Supremum</code>的部分</p><p>这两条记录都是由5B大小的记录头信息，和8B大小的一个固定部分组成。</p><p>最小记录：记录头信息</p><p><img src="/image/mysql/mysql12.png"></p><p>最小记录的next_record指向第一条记录，即主键值最小的那条记录，并不是我们按照插入顺序拍的那个记录，最后一个用户记录的next_record指向最大记录。</p><h2 id="2-3-页目录和页头"><a href="#2-3-页目录和页头" class="headerlink" title="2.3 页目录和页头"></a>2.3 页目录和页头</h2><h3 id="2-3-1-页目录"><a href="#2-3-1-页目录" class="headerlink" title="2.3.1 页目录"></a>2.3.1 页目录</h3><p>使用页目录的原因是方便快速定位到一个页中的记录</p><p><strong>先分组：</strong>具体的做法是将所有的记录(包括最大记录和最小记录，但不包括已删除的记录)分成几个组。</p><ul><li><p>第一组只有一条记录，就是最小记录</p></li><li><p>最后一组会有1-8条记录，是最大记录所在的分组</p></li><li><p>其余的组中记录的数量在4-8条之间</p></li></ul><p>在每个组的最后一条记录的记录头信息中会存储该组一共有多少条记录，就是n_owned字段</p><p>分好组之后，将每组最后一条记录的地址偏移量存储在页目录中，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量被称为槽slot，每个槽相当于指向每个组的最后一条记录。</p><p><img src="/image/mysql/mysql13.png"></p><p>页目录其实是一个数组，存放的是每组最后一个记录的地址偏移量，因此采用二分法，找到对应的组，然后在组中遍历单向链表，找到目标记录。</p><h3 id="2-3-2-页面头部"><a href="#2-3-2-页面头部" class="headerlink" title="2.3.2 页面头部"></a>2.3.2 页面头部</h3><p><img src="/image/mysql/mysql13.png"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>行格式</tag>
      
      <tag>页格式</tag>
      
      <tag>数据库高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-数据库调优</title>
    <link href="/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E5%8C%96/"/>
    <url>/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>数据库调优的步骤：</p><p><img src="/image/mysql/mysql21.png"></p><h1 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h1><h2 id="1-1-查看系统性能参数"><a href="#1-1-查看系统性能参数" class="headerlink" title="1.1 查看系统性能参数"></a>1.1 查看系统性能参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL|SESSION] STATUS LIKE &#x27;参数&#x27;;<br></code></pre></td></tr></table></figure><p>一些常用的性能参数如下：</p><pre><code class="hljs">• Connections：连接MySQL服务器的次数。• Uptime：MySQL服务器的上线时间。• Slow_queries：慢查询的次数。• Innodb_rows_read：Select查询返回的行数• Innodb_rows_inserted：执行INSERT操作插入的行数• Innodb_rows_updated：执行UPDATE操作更新的行数• Innodb_rows_deleted：执行DELETE操作删除的行数• Com_select：查询操作的次数。• Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。• Com_update：更新操作的次数。• Com_delete：删除操作的次数。</code></pre><p>查询现在有多少条慢查询记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| Slow_queries  | 0     |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="1-2-统计SQL的查询成本"><a href="#1-2-统计SQL的查询成本" class="headerlink" title="1.2 统计SQL的查询成本"></a>1.2 统计SQL的查询成本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW STATUS LIKE &#x27;last_query_cost&#x27;;<br></code></pre></td></tr></table></figure><p>查询最近一次执行的SQL命令需要检索的页的个数。</p><h1 id="2-定位执行慢的-SQL"><a href="#2-定位执行慢的-SQL" class="headerlink" title="2.定位执行慢的 SQL"></a>2.定位执行慢的 SQL</h1><p>如果我们在分析服务器状态时发现还是比较慢和卡顿，就需要找到执行比较慢的SQL。</p><p>MySQL的慢查询日志用来记录在MySQL中响应时间超过阈值的语句，然后我们找到这些慢的SQL语句有针对性的记性优化。默认MySQL数据库没有开启慢查询日志，需要手动设置，<strong>如果不是调优需要，一般不要开启，因为会影响性能。</strong></p><h2 id="2-1-开启慢查询日志参数"><a href="#2-1-开启慢查询日志参数" class="headerlink" title="2.1 开启慢查询日志参数"></a>2.1 开启慢查询日志参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;<br>+----------------+-------+<br>| Variable_name  | Value |<br>+----------------+-------+<br>| slow_query_log | OFF   |  //默认是关闭的<br>+----------------+-------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; set global slow_query_log = on;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;<br>+---------------------+-------------------------------------------------+<br>| Variable_name       | Value                                           |<br>+---------------------+-------------------------------------------------+<br>| slow_query_log      | ON                                              |<br>| slow_query_log_file | /var/lib/mysql/iz2zeip0loevltpebhi0txz-slow.log |<br>+---------------------+-------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>查看阈值<code>(执行时间超过这个阈值的SQL语句被认为是慢SQL)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%long_query_time&#x27;;<br>+-----------------+-----------+<br>| Variable_name   | Value     |<br>+-----------------+-----------+<br>| long_query_time | 10.000000 |<br>+-----------------+-----------+<br>1 row in set (0.01 sec)<br><br>mysql&gt; set global long_query_time = 1;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;<br>+-----------------+----------+<br>| Variable_name   | Value    |<br>+-----------------+----------+<br>| long_query_time | 1.000000 |<br>+-----------------+----------+<br>1 row in set (0.01 sec)<br><br>mysql&gt; set long_query_time=1;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; show variables like &#x27;%long_query_time%&#x27;;<br>+-----------------+----------+<br>| Variable_name   | Value    |<br>+-----------------+----------+<br>| long_query_time | 1.000000 |<br>+-----------------+----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2-2-慢查询日志分析工具"><a href="#2-2-慢查询日志分析工具" class="headerlink" title="2.2 慢查询日志分析工具"></a>2.2 慢查询日志分析工具</h2><p>MySQL提供了日志分析工具<code>mysqldumpslow</code>。通过mysqldumpslow 可以查看慢查询日志</p><p><strong>mysqldumpslow 命令的具体参数如下</strong>：</p><blockquote><p>-a: 不将数字抽象成N，字符串抽象成S<br>-s: 是表示按照何种方式排序：<br>    c: 访问次数<br>    l: 锁定时间<br>    r: 返回记录<br>    t: 查询时间<br>    al:平均锁定时间<br>    ar:平均返回记录数<br>    at:平均查询时间 （默认方式）<br>    ac:平均查询次数<br>-t: 即为返回前面多少条的数据；<br>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldumpslow -a -s t -t 5 /var/lib/mysql/iz2zeip0loevltpebhi0txz-slow.log<br></code></pre></td></tr></table></figure><p>返回的就是慢SQL的语句，然后我们可以通过性能分析工具EXPLAIN来分析这个SQL语句</p><hr><p><strong>如何关闭慢查询日志？</strong></p><p>MySQL服务器停止慢查询日志功能有两种方法：</p><p>①方式1：永久性方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#配置文件<br>[mysqld]<br>slow_query_log=OFF<br></code></pre></td></tr></table></figure><p>执行完后需要重启才能生效</p><p>②方式2：临时性方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL slow_query_log=off;<br></code></pre></td></tr></table></figure><hr><p><strong>如何删除慢查询日志</strong>？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqladmin -uroot -p flush-logs slow //重建<br></code></pre></td></tr></table></figure><p>重新生成慢查询日志文件</p><h1 id="3-EXPLAIN分析慢SQL"><a href="#3-EXPLAIN分析慢SQL" class="headerlink" title="3.EXPLAIN分析慢SQL"></a>3.EXPLAIN分析慢SQL</h1><p>EXPLAIN查看SQL语句的执行计划，并不是真正执行这个SQL语句，而是看看如果要执行它，优化器会采取什么样的步骤</p><p>MySQL 5.6.3以前只能 <code>EXPLAIN SELECT</code>；MYSQL 5.6.3以后就可以 <code>EXPLAIN SELECT，UPDATE，DELETE</code></p><h2 id="3-1EXPLAIN各个字段"><a href="#3-1EXPLAIN各个字段" class="headerlink" title="3.1EXPLAIN各个字段"></a>3.1EXPLAIN各个字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT ...<br>#或者<br>DESCRIBE SELECT ...<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql23.png"></p><hr><p>相关数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE s1 (<br> id INT AUTO_INCREMENT,<br> key1 VARCHAR(100),<br> key2 INT,<br> key3 VARCHAR(100),<br> key_part1 VARCHAR(100),<br> key_part2 VARCHAR(100),<br> key_part3 VARCHAR(100),<br> common_field VARCHAR(100),<br>  PRIMARY KEY (id),<br>  INDEX idx_key1 (key1),<br>  UNIQUE INDEX idx_key2 (key2),<br>  INDEX idx_key3 (key3),<br>  INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br><br>CREATE TABLE s2 (<br> id INT AUTO_INCREMENT,<br> key1 VARCHAR(100),<br> key2 INT,<br> key3 VARCHAR(100),<br> key_part1 VARCHAR(100),<br> key_part2 VARCHAR(100),<br> key_part3 VARCHAR(100),<br> common_field VARCHAR(100),<br>  PRIMARY KEY (id),<br>  INDEX idx_key1 (key1),<br>  UNIQUE INDEX idx_key2 (key2),<br>  INDEX idx_key3 (key3),<br>  INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br><br></code></pre></td></tr></table></figure><hr><h3 id="①table"><a href="#①table" class="headerlink" title="①table"></a><strong>①table</strong></h3><p>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法,该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。有几个表就有几行记录结果</p><p>比如：<code>EXPLAIN SELECT * from s1;</code></p><p><img src="/image/mysql/mysql24.png"></p><p><code>EXPLAIN SELECT * FROM s1 INNER JOIN s2;</code>有两条记录结果，它的table列分别是s1、s2</p><p><img src="/image/mysql/mysql25.png"></p><hr><h3 id="②id"><a href="#②id" class="headerlink" title="②id"></a><strong>②id</strong></h3><p>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</p><p>如果有子查询，并且查询优化器没有将它优化为多表查询，一般就有多个id值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql26.png"></p><ul><li><p>id如果相同，可以认为是一组，从上往下顺序执行</p></li><li><p>在所有组中，id值越大，优先级越高，越先执行</p></li><li><p>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</p></li></ul><h3 id="③select-type"><a href="#③select-type" class="headerlink" title="③select_type"></a><strong>③select_type</strong></h3><p><img src="/image/mysql/mysql27.png"></p><h4 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a><font color='red'>SIMPLE</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> s1;<br></code></pre></td></tr></table></figure><p>这个语句的类型是SIMPLE，连接查询<code>EXPLAIN SELECT * FROM s1 INNER JOIN s2;</code>也是 SIMPLE 类型</p><h4 id="PRIMARY、UNION、UNION-RESULT"><a href="#PRIMARY、UNION、UNION-RESULT" class="headerlink" title="PRIMARY、UNION、UNION RESULT"></a><font color='red'>PRIMARY、UNION、UNION RESULT</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> s2;<br></code></pre></td></tr></table></figure><p>对于包含UNION或UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，最左边(或者是外层的表)的查询的select_type的值是primary，其余的小查询的select_type是UNION，使用临时表对UNION进行去重，针对该临时表的查询的select_type为UNION RESULT</p><p><img src="/image/mysql/mysql28.png"></p><blockquote><p>SQL语句1   UNION&#x2F;UNION ALL  SQL语句2</p><p>两个SQL语句执行的目标表的结构必须是一样的</p><p>UNION和UNION ALL关键字都是将两个结果集合并为一个，不过UNION ALL不去重，返回所有行记录，UNION去重，会按照字段的顺序进行排序，然后去除重复的行记录，然后再返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from student;<br>+----+-------+------+------+---------+<br>| id | stuno | name | age  | classId |<br>+----+-------+------+------+---------+<br>|  1 |     1 | 1    |    1 |       1 |<br>|  2 |     2 | 2    |    2 |       2 |<br>+----+-------+------+------+---------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from student_copy;<br>+----+-------+------+------+---------+<br>| id | stuno | name | age  | classId |<br>+----+-------+------+------+---------+<br>|  1 |     1 | 1    |    1 |       1 |<br>|  2 |     2 | 2    |    2 |       2 |<br>+----+-------+------+------+---------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from student union select * from student_copy;<br>+----+-------+------+------+---------+<br>| id | stuno | name | age  | classId |<br>+----+-------+------+------+---------+<br>|  1 |     1 | 1    |    1 |       1 |<br>|  2 |     2 | 2    |    2 |       2 |<br>+----+-------+------+------+---------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select * from student union all select * from student_copy;<br>+----+-------+------+------+---------+<br>| id | stuno | name | age  | classId |<br>+----+-------+------+------+---------+<br>|  1 |     1 | 1    |    1 |       1 |<br>|  2 |     2 | 2    |    2 |       2 |<br>|  1 |     1 | 1    |    1 |       1 |<br>|  2 |     2 | 2    |    2 |       2 |<br>+----+-------+------+------+---------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure></blockquote><h4 id="SUBQUERY、DEPENDENT-SUBQUERY"><a href="#SUBQUERY、DEPENDENT-SUBQUERY" class="headerlink" title="SUBQUERY、DEPENDENT SUBQUERY"></a><font color='red'>SUBQUERY、DEPENDENT SUBQUERY</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> key1 <span class="hljs-keyword">FROM</span> s2) <span class="hljs-keyword">OR</span> key3 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure><p>in后面的子查询<code>SELECT key1 FROM s2</code>是不相关子查询</p><p><img src="/image/mysql/mysql29.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = &#x27;a&#x27;;<br></code></pre></td></tr></table></figure><p>in后面的子查询是相关子查询</p><p><img src="/image/mysql/mysql30.png"></p><blockquote><p>不相关子查询：子查询的不需要父查询把结果传进来</p><p>相关子查询：子查询需要父表查询的某些结果才能执行</p></blockquote><ul><li><font color='red'>DEPEDENT UNION、DEPEDENT SUBQUERY</font></li></ul><p>在UNION UNION ALL中如果内查询是相关子查询，就会</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; UNION SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;);<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql31.png"></p><h4 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a><font color='red'>DERIVED</font></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;<br></code></pre></td></tr></table></figure><p>对派生表<code>SELECT key1, count(*) as c FROM s1 GROUP BY key1 </code>的查询，派生表对应的子查询type就是DERIVED</p><p><img src="/image/mysql/mysql32.png"></p><h4 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a><font color='red'>MATERIALIZED</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> key1 <span class="hljs-keyword">FROM</span> s2);<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql33.png"></p><p>查询优化器将子查询<code>SELECT key1 FROM s2</code>进行查询物化后与外层查询进行连接查询</p><h3 id="④partitions"><a href="#④partitions" class="headerlink" title="④partitions"></a>④partitions</h3><p>分区</p><h3 id="⑤type"><a href="#⑤type" class="headerlink" title="⑤type"></a><strong>⑤type</strong></h3><p>MySQL针对单表的执行查询的访问方法。完整的访问方法如下： <code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ，index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code>。</p><h4 id="system"><a href="#system" class="headerlink" title="system"></a><font color='red'>system</font></h4><p>当表中只有一条记录并且这个表的存储引擎是MyIASM或者Memory，这时的type是system</p><p><img src="/image/mysql/mysql34.png"></p><h4 id="const"><a href="#const" class="headerlink" title="const"></a><font color='red'>const</font></h4><p>主键primary key 或者<strong>唯一</strong>二级索引union index列与常数进行匹配时，对单标的访问方法就是const</p><p><img src="/image/mysql/mysql35.png"></p><p>这个表中id是主键</p><h4 id="eg-ref"><a href="#eg-ref" class="headerlink" title="eg_ref"></a><font color='red'>eg_ref</font></h4><p>在连接查询中，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问，则对该被驱动表的访问方法是eg_ref</p><p><img src="/image/mysql/mysql37.png"></p><p>从执行计划中看出，s1为驱动表，s2为被驱动表，在访问s2表的时候是通过主键的等值匹配来访问的，所以这个表的执行方法为eg_ref</p><blockquote><p>join(inner join)、left join、right join的区别</p><p><img src="/image/mysql/mysql36.png"></p></blockquote><h4 id="ref、ref-or-null"><a href="#ref、ref-or-null" class="headerlink" title="ref、ref_or_null"></a><font color='red'>ref、ref_or_null</font></h4><p>当通过<strong>普通</strong>二级索引列与常量进行等值匹配来查询某个表，那对该表的访问方法就是ref</p><p><img src="/image/mysql/mysql38.png"></p><p>如果对普通二级索引进行等值匹配时，该列可以为null，则对该表的访问方法就是ref_or_null</p><p><img src="/image/mysql/mysql39.png"></p><h4 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a><font color='red'>index_merge</font></h4><p>当对两个普通二级索引进行等值匹配，且两个索引对应的列的连接方式为or，则对该表的访问方法就是index_merge</p><p><img src="/image/mysql/mysql40.png"></p><h4 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a><font color='red'>unique_subquery</font></h4><p>在一些包含in子查询的查询语句中，如果查询优化器决定将in子查询转化为exists子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询的执行计划的type就是unique_subquery</p><p><img src="/image/mysql/mysql41.png"></p><h4 id="range"><a href="#range" class="headerlink" title="range"></a><font color='red'>range</font></h4><p>使用索引获取某些范围区间的记录，就有可能使用到range访问方法</p><p><img src="/image/mysql/mysql42.png"></p><h4 id="index"><a href="#index" class="headerlink" title="index"></a><font color='red'>index</font></h4><p>使用覆盖索引，但需要扫描全部的索引记录时，该表的访问方法就是index</p><p><img src="/image/mysql/mysql43.png"></p><blockquote><p>什么是<strong>覆盖索引？</strong></p><p>一个索引包含了满足查询结果的数据就叫做覆盖索引，这个索引是联合索引&#x2F;二级索引，即<code>索引列+主键</code>包含select到FROM之间需要查询的列。</p><p>假如现在有一个表t，它有3个列，c1，c2，c3，c4, 它有一个二级索引c2，主键索引c1，如果有一个语句是select * from t  where c2 &#x3D; 1;  会去二级索引中找，如果找到了一条行记录，就可以得到c2，c1的值，但是要返回的结果是全列，因此需要回表，找到聚簇索引中的行记录，将其返回。</p><p>如果有一个语句是select c1,c2 from t  where c2 &#x3D; 1;  就可以直接在二级索引中找，找到就直接返回，因为在这个索引包含了满足查询结果的数据列，<strong>不需要回表的操作</strong>，这就是覆盖索引</p><hr><p>好处：</p><p>1.避免InnoDB表进行索引的二次查询（回表）</p><p>二级索引在叶子节点保存的是索引列和主键的行信息，在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对聚簇索引的二次查询</p><p>2.可以把随机I&#x2F;O变成顺序I&#x2F;O，加快查询效率</p><p>在二级索引中索引列是按顺序排的，但是回表的时候是根据主键值进行搜索的，不同的主键值他们不一定在一个页或者一个区中，因此要加载的页可能也是不同的，所以这是一个随机I&#x2F;O，而覆盖索引是按顺序读取页的，是一个顺序I&#x2F;O</p></blockquote><h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a><font color='red'>ALL</font></h4><p>全表扫描</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> s1;<br></code></pre></td></tr></table></figure><p>结果值从最好到最坏依次是： <code>system &gt; const &gt; eq_ref &gt; ref</code> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <code>range &gt; index &gt; ALL</code></p><h3 id="⑥possible-keys和key"><a href="#⑥possible-keys和key" class="headerlink" title="⑥possible_keys和key"></a><strong>⑥possible_keys和key</strong></h3><p>possible_keys表示在某个查询语句中，对某个表执行单标查询时可能用到的索引有哪些，但不一定真正被查询使用，key列表示实际用到的索引有哪些，如果为NULL则没有使用索引。</p><h3 id="⑦key-len"><a href="#⑦key-len" class="headerlink" title="⑦key_len"></a><strong>⑦key_len</strong></h3><p>实际使用到的索引长度(即 字节数)</p><p>帮你检查是否充分的利用上了索引，值越大越好，主要针对联合索引。</p><ul><li>varchar(10)变长字段且允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+1(NULL)+2(变长字段)</li><li>varchar(10)变长字段且不允许NULL。长度&#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+2(变长字段)</li><li>char(10)固定字段且允许NULL。长度&#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+1(NULL)</li><li>char(10)固定字段且不允许NULL。长度&#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)</li><li>int且不允许为NULL。长度&#x3D;4</li><li>int且允许为NULL。长度&#x3D;5</li></ul><h3 id="⑧ref"><a href="#⑧ref" class="headerlink" title="⑧ref"></a><strong>⑧ref</strong></h3><p>当使用索引列等值查询时，与索引列进行等值匹配的对象信息。</p><h3 id="⑨rows"><a href="#⑨rows" class="headerlink" title="⑨rows"></a><strong>⑨rows</strong></h3><p>预估的需要读取的记录数，越小说明获取的记录越可能在同一页中，进行I&#x2F;O的次数就越少，效率就越高。</p><h3 id="⑩filtered"><a href="#⑩filtered" class="headerlink" title="⑩filtered"></a><strong>⑩filtered</strong></h3><p>某个表经过where搜索条件过滤后剩余记录条数的百分比</p><h3 id="⑪Extra"><a href="#⑪Extra" class="headerlink" title="⑪Extra"></a><strong>⑪Extra</strong></h3><p>用来说明一些额外信息。比如有：</p><h4 id="No-tables-used"><a href="#No-tables-used" class="headerlink" title="No tables used"></a><font color='red'>No tables used</font></h4><p>当查询语句中没有FROM子句时会提示这个信息</p><p><code>EXPLAIN SELECT 1;</code></p><h4 id="Impossible-WHERE"><a href="#Impossible-WHERE" class="headerlink" title="Impossible WHERE"></a><font color='red'>Impossible WHERE</font></h4><p>查询语句中的WHERE子句永远为FALSE时</p><p><code>EXPLAIN SELECT * FROM s1 WHERE 1 != 1;</code></p><h4 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a><font color='red'>Using where</font></h4><p>当全表扫描来对某个表进行查询时，并且该语句有WHERE，where子句中查询的列中有不是索引的列</p><p><code> EXPLAIN SELECT * FROM s1 WHERE common_field = &#39;a&#39;;</code></p><p><code>mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#39;a&#39; AND common_field = &#39;a&#39;;</code></p><p> EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; ‘a’   &#x2F;&#x2F;key1是主键，仅仅是这个不会有Using where</p><h4 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a><font color='red'>Using index</font></h4><p>即<strong>覆盖索引</strong>，当我们查询列表以及搜索条件中只包含属于某个索引的列，在使用覆盖索引时在Extra列会提示这个额外信息，不需要回表了</p><p><code>mysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = &#39;a&#39;;</code></p><h4 id="Using-index-condition"><a href="#Using-index-condition" class="headerlink" title="Using index condition"></a><font color='red'>Using index condition</font></h4><p><code>mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key1 LIKE &#39;%b&#39;;</code></p><p><img src="/image/mysql/mysql44.png"></p><p>即<strong>索引下推</strong></p><blockquote><p>索引条件下推（ICP，Index Condition Pushdown），是一种在存储引擎层使用索引过滤数据的优化方式。更多针对联合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//现在tuser中只有一个联合索引idx_age_name_address(age,name,address)，一个主键索引id<br>SELECT * FROM tuser<br>WHERE age = 10 <br>AND NAME LIKE &#x27;%张%&#x27;<br>AND ismale = 1;<br></code></pre></td></tr></table></figure><p>此时用了联合索引，但仅仅是age列，因为name是模糊的，索引失效，当查询时，会首先去联合索引的B+树中查找age，查到多条行记录后，会接着筛选这几条记录中符合name like ‘%张%’条件的记录，然后将得到的记录对应的主键值进行回表，寻找匹配记录。这就是ICP<br>—如果没有ICP，应该是在查询时，根据联合索引，如果查询到多条记录，会直接回表，然后在主键索引的满足这些id的记录中查找符合name like ‘%张%’和ismale &#x3D; 1的记录，相当于回表需要的I&#x2F;O次数很可能比ICP的多，因为回表的记录数多。</p><p>ICP的 <code>加速效果</code> 取决于在存储引擎内通过 <code>ICP筛选</code> 掉的数据的比例。</p><p>默认情况下ICP是打开的，也可以通过SQL命令打开或关闭</p></blockquote><h4 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h4><p><code>mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;</code></p><p>当排序操作ORDER BY无法使用到索引，只能在内存中或者磁盘中进行排序，Mysql把这种在内存中或者磁盘中进行排序的方式称为文件排序(filesort)，非常耗费性能，最好想办法将使用文件排序的执行方式改为使用索引进行排序，Extra&#x3D;Using filesort</p><p><code>mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;</code></p><p>由于在key1上有索引idx_key1，所以这个语句可以使用idx_key1索引直接取出key1的10条数据，然后再进行回表。此时显示的Extra&#x3D;NULL</p><h2 id="3-2-EXPLAIN的四种输出格式"><a href="#3-2-EXPLAIN的四种输出格式" class="headerlink" title="3.2 EXPLAIN的四种输出格式"></a>3.2 EXPLAIN的四种输出格式</h2><ol><li><p>传统格式</p><p>explain select * from s1 order by key1 limit 10;</p><p>输出格式就是上面一直看到的那种表格</p></li><li><p>json格式</p><p>explain format&#x3D;json select * from s1 order by key1 limit 10;</p><p>输出格式是json，比传统格式的信息更全面，包括查询成本</p></li><li><p>Tree格式</p><p>explain format&#x3D;tree select * from s1 order by key1 limit 10;</p><p>展示层次结构</p></li><li><p>可视化输出</p><p>使用MySQL Workbench可视化查看MySQL的执行计划</p></li></ol><h1 id="4-索引优化和查询优化"><a href="#4-索引优化和查询优化" class="headerlink" title="4.索引优化和查询优化"></a>4.索引优化和查询优化</h1><h2 id="4-1-索引失效的例子"><a href="#4-1-索引失效的例子" class="headerlink" title="4.1 索引失效的例子"></a>4.1 索引失效的例子</h2><ol><li><p>不符合最佳左前缀法则</p><p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p>计算、函数、类型转换(自动或手动)导致索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 函数<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;<br># 计算<br>CREATE INDEX idx_sno ON student(stuno);<br>EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;<br># 假设name字段上设置有索引,但是由于类型转换，未使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;#隐式的类型转换<br></code></pre></td></tr></table></figure></li><li><p>范围条件右边的列索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE student DROP INDEX idx_name;<br>ALTER TABLE student DROP INDEX idx_age;<br>ALTER TABLE student DROP INDEX idx_age_classid;<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student<br>WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;<br># student.classId&gt;20的右侧的student.name = &#x27;abc&#x27;的索引就会失效<br>create index idx_age_name_classid on student(age,name,classid);<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abc&#x27; AND student.classId&gt;20 ;<br>#直接交换sql语句的位置是没有用的，需要改变联合索引的位置<br></code></pre></td></tr></table></figure></li><li><p>不等于(!&#x3D; 或者&lt;&gt;)索引失效</p><p>当sql语句中有!&#x3D;或者&lt;&gt;会出现索引失效的问题，尝试改写为<code>等于</code>，或采用<code>覆盖索引</code></p></li><li><p>is null可以使用索引，is not null无法使用索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL;<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql47.png"></p></li><li><p>like以通配符%开头索引失效</p></li></ol><p><img src="/image/mysql/mysql46.png"></p><p>【强制】页面搜索严禁<code>左模糊</code>或者<code>全模糊</code>，如果需要请走搜索引擎来解决。</p><ol start="7"><li><p>OR 前后存在非索引的列，索引失效</p><p>让<code>OR的前后条件</code>都具备索引，如果缺少一个就会出现索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># age是二级索引，classid是普通列，未使用到age索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-2-外连接和内连接的查询优化"><a href="#4-2-外连接和内连接的查询优化" class="headerlink" title="4.2 外连接和内连接的查询优化"></a>4.2 外连接和内连接的查询优化</h2><p>驱动表是主表，被驱动表是从表</p><h3 id="4-2-1-外连接"><a href="#4-2-1-外连接" class="headerlink" title="4.2.1 外连接"></a>4.2.1 外连接</h3><p>刚开始所有字段都没有加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM name LEFT JOIN book ON type.card = book.card;<br></code></pre></td></tr></table></figure><p>left join 的执行过程是先在type表中取一个行，然后匹配所有的book表中的数据，看哪一行数据符合name.card &#x3D; book.card; 假如type表中有20行数据，book表中有30行数据，则一共要查询20*30&#x3D;600次。name是驱动表，book是被驱动表。</p><p>结果是：两行表格的type都为ALL，全表扫描，没有使用任何索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE book ADD INDEX Y ( card);  #【被驱动表】，可以避免全表扫描<br>EXPLAIN SELECT SQL_NO_CACHE * FROM name LEFT JOIN book ON type.card = book.card;<br></code></pre></td></tr></table></figure><p>结果是：book表对应的那一行的type属性的值是ref，使用上了二级索引，这样当驱动表选定一行数据时，可以直接从被驱动表的B+树上直接定位到目标值(logn级别)，但是驱动表无法避免全表扫描(加索引和不加索引都是)</p><p>对于外连接，name也不一定都是驱动表，因为查询优化器会将语句优化为内连接，所以谁作为驱动表不一定。</p><h3 id="4-2-2-内连接"><a href="#4-2-2-内连接" class="headerlink" title="4.2.2 内连接"></a>4.2.2 内连接</h3><p> inner join（<code>MySQL的查询优化器可以决定谁作为驱动表和被驱动表</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN  SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card; <br></code></pre></td></tr></table></figure><p>如果name表上的card有索引，而book表上的card没有，则name是被驱动表</p><p>如果book表上的card有索引，而name表上的card没有，则book是被驱动表</p><p>如果都有索引，则MySQL会评判选择哪个表作为驱动表效率更高，就选择哪个表</p><p>如果都没有索引，则小表驱动大表。（小的结果集驱动大的结果集，经过where条件筛选出来的结果集哪一个小，哪一个表就是小表。即两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”。）</p><p>查询优化器优化后的explain的结果中，上面的是驱动表，下面是被驱动表</p><h3 id="4-2-3-JOIN原理"><a href="#4-2-3-JOIN原理" class="headerlink" title="4.2.3 JOIN原理"></a>4.2.3 JOIN原理</h3><ol><li>索引嵌套循环连接(Index  Nested-Loop Join)</li></ol><p>假如：驱动表是t1，被驱动表是t2，被驱动表t2的字段a上有索引，join过程用上了这个索引，则inner join的执行过程是：</p><ol><li>从表t1中读入一行数据 R；</li><li>从数据行R中，取出a字段到表t2里去查找；</li><li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li><li>重复执行步骤1到3，直到表t1的末尾循环结束。</li></ol><p><img src="/image/mysql/mysql48.png"></p><blockquote><p>图片来源：<a href="https://achang.blog.csdn.net/article/details/122655136">https://achang.blog.csdn.net/article/details/122655136</a></p></blockquote><ol start="2"><li>块嵌套循环连接(Blocked Nested-Loop join)</li></ol><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引用了join buffer缓冲区，将驱动表join相关的部分数据列缓存到join buffer中，被驱动表中的记录一次性和缓冲区中的比较，降低了被驱动表的访问频率</p><p><img src="/image/mysql/mysql49.png"></p><p>这是没有索引的情况</p><p>效率：索引嵌套循环连接 &gt; 块嵌套循环连接</p><h2 id="4-3-子查询优化"><a href="#4-3-子查询优化" class="headerlink" title="4.3 子查询优化"></a>4.3 子查询优化</h2><p>子查询效率比较低，因为查询优化器需要创建一个临时表，帮助筛选，结束后会再撤销临时表，比较消耗性能，最好将子查询改为join连接多表查询，这样不用建立临时表。</p><p>尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p><h2 id="4-4-排序优化"><a href="#4-4-排序优化" class="headerlink" title="4.4 排序优化"></a>4.4 排序优化</h2><p>SQL中，在WHERE子句中最好使用索引，避免全表扫描，在ORDER BY 子句中最好使用索引，避免Filesort排序。</p><p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p><blockquote><p><strong>MySQL中支持两种排序，FileSort和Index</strong></p><p>Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。</p><p>FileSort排序则一般在内存或磁盘中进行排序，占用CPU较多，如果待排序结果较大，会产生临时文件I&#x2F;O到磁盘进行排序的情况，效率较低。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME;<br>#为了去掉filesort我们可以把索引建成<br>CREATE INDEX idx_age_name ON student(age,NAME);<br></code></pre></td></tr></table></figure><p>如果既有where 又有order by，可能是先过滤where中的条件，然后再进行order by，如果过滤完记录就不太多了，可能不会使用这个order by的索引，也可能是先进行order by，再where，这完全是根据查询优化器的决定。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
      <tag>EXPLAIN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-事务</title>
    <link href="/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>在 MySQL 中，只有<code>InnoDB 是支持事务的</code>。</p><p><img src="/image/mysql/mysql50.png"></p><h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1.什么是事务"></a>1.什么是事务</h1><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。这里的一组操作就是在开启事务后进行了一些增删改操作，即事务对应着一个或多个数据库操作。</p><p><strong>事务处理的原则：</strong>保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p><h1 id="2-事务的状态"><a href="#2-事务的状态" class="headerlink" title="2.事务的状态"></a>2.事务的状态</h1><p>MySQL根据这些增删改操作所执行的不同阶段把 <code>事务</code> 大致划分成几个状态：</p><ul><li><p><strong>活动的</strong>（active）</p><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <code>活动的</code> 状态。</p></li><li><p><strong>部分提交的</strong>（partially committed）</p><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <code>没有刷新到磁盘时</code>，我们就说该事务处在 <code>部分提交的</code> 状态。</p></li><li><p><strong>失败的</strong>（failed）</p><p>当事务处在 <code>活动的</code> 或者 <code>部分提交的</code> 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 <code>失败的</code> 状态。</p></li><li><p><strong>中止的</strong>（aborted）</p><p>如果事务执行了一部分而变为 失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。</p></li><li><p><strong>提交的</strong>（committed）</p><p>当一个处在 <code>部分提交的</code> 状态的事务将修改过的数据都 <code>同步到磁盘</code> 上之后，我们就可以说该事务处在了 <code>提交的</code> 状态。</p></li></ul><p><img src="/image/mysql/mysql51.png"></p><h1 id="3-事务的ACID特性"><a href="#3-事务的ACID特性" class="headerlink" title="3.事务的ACID特性"></a>3.事务的ACID特性</h1><h2 id="①原子性（atomicity）"><a href="#①原子性（atomicity）" class="headerlink" title="①原子性（atomicity）"></a>①原子性（atomicity）</h2><p><code>原子性</code>是指事务是 <strong>一个不可分割的工作单位</strong>，要么全部提交，要么全部失败回滚。</p><h2 id="②一致性（consistency）"><a href="#②一致性（consistency）" class="headerlink" title="②一致性（consistency）"></a>②一致性（consistency）</h2><p>根据定义，一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。这种状态是 <code>语义上</code> 的而不是语法上的，跟具体的业务有关，符合现实世界的约束。</p><p>比如有一个表，其中一个属性为金额，在语义上金额应该大于等于0，账户A有100元，账户B有0元，账户A要转账200元，这个操作就是不合法的。</p><h2 id="③隔离型（isolation）"><a href="#③隔离型（isolation）" class="headerlink" title="③隔离型（isolation）"></a>③隔离型（isolation）</h2><p>事务的隔离性是指一个事务的执行 <code>不能被其他事务干扰</code> ，即一个事务内部的操作及使用的数据对 并发 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><h2 id="④持久性（durability）"><a href="#④持久性（durability）" class="headerlink" title="④持久性（durability）"></a>④持久性（durability）</h2><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 <code>永久性的</code> ，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 redo日志 和 undo日志 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到 redo 日志中，然后再对数据库中对应的行进行修改。</p><p>这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的redo日志，重新执行，从而使事务具有持久性。</p><h1 id="4-使用事务"><a href="#4-使用事务" class="headerlink" title="4.使用事务"></a>4.使用事务</h1><h2 id="4-1-显式开启事务"><a href="#4-1-显式开启事务" class="headerlink" title="4.1 显式开启事务"></a>4.1 显式开启事务</h2><p><strong>步骤1</strong>： 显式开启一个事务。</p><p><code>START TRANSACTION</code> 或者 <code>BEGIN</code> ，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>#或者<br>mysql&gt; START TRANSACTION;<br></code></pre></td></tr></table></figure><p><code>START TRANSACTION</code>后边能跟随几个修饰符 ：READ ONLY(当前开启的是只读事务)、READ WRITE(当前开启的事务可以进行增删改操作)、WITH CONSISTENT SNAPSHOT(一致性读)，如果后面啥也不写，默认是READ WRITE</p><p><strong>步骤2</strong>：一系列事务中的操作（主要是数据操纵语言DML，不含数据定义语言DDL）</p><blockquote><p>DML(Data Manipulation Language)：数据操纵语言，对数据库中的数据进行一些简单操作，如insert、delete、update、select等。DML操作是可以手动控制事务的开启、提交和回滚的。<br>DDL(Data Definition Language)：数据定义语言，对数据库中的某些对象(例如database、table)进行管理，如create、alter和drop。DDL操作是隐性提交的(默认语句执行完就提交事务了)，不能rollback。</p></blockquote><p><strong>步骤3</strong>：提交事务 或 中止事务（即回滚事务）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.提交事务。当提交事务后，对数据库的修改是永久性的。<br>mysql&gt; COMMIT;<br><br># 2.回滚事务。即撤销正在进行的所有没有提交的修改，回到begin处最初的状态<br>mysql&gt; ROLLBACK;<br><br># 3.将事务回滚到某个保存点。因为rollback是回到最初的状态，但是我们只想要回到后面的某个位置，就需要那个位置执行完之后设置保存点【savepoint s1】，然后就回滚到这个位置，取消保存点【release savepoint s1】<br>mysql&gt; ROLLBACK TO [SAVEPOINT]<br></code></pre></td></tr></table></figure><h2 id="4-2-隐式开启事务"><a href="#4-2-隐式开启事务" class="headerlink" title="4.2 隐式开启事务"></a>4.2 隐式开启事务</h2><p>MySQL中有一个系统变量 <code>autocommit</code>：默认是开启的状态，作用是使每一个DML语句都是一个独立的事务，执行完就自动提交了。<code>这个系统变量只对DML语句有效。</code></p><p>如何关闭DML语句的隐式自动提交：1.当显式的的使用<code>START TRANSACTION</code>或者 <code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉隐式的自动提交的功能，显式的优先级比隐式的高。2.将这个系统变量设置为off</p><p>关闭之后，执行过DML语句不会自动提交，需要手动COMMIT</p><hr><p>但是DDL语句不受这个变量的影响，DDL语句始终都是执行完这一句默认提交事务。</p><hr><p>如果在事务开始前设置了<code>SET @@completion_type=1;</code>在它后面，如果一个事务完成，它会再帮我们开启一个事务，这个事务结束，会再帮我们开启一个相同隔离级别的事务，就是一个链式事务。</p><p>这个变量默认值是0，就是commit提交事务之后，如果还想开启事务，需要重新begin</p><h1 id="5-事务隔离级别"><a href="#5-事务隔离级别" class="headerlink" title="5.事务隔离级别"></a>5.事务隔离级别</h1><h2 id="5-1-为什么会有事务隔离？"><a href="#5-1-为什么会有事务隔离？" class="headerlink" title="5.1 为什么会有事务隔离？"></a>5.1 为什么会有事务隔离？</h2><p>MySQL是一个 客户端／服务器 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个<strong>会话</strong>（ Session ）。</p><p>每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，对于服务器来说可能同时处理多个事务。</p><p>这样就会产生并发访问和修改数据的问题。具体来说，有这四个问题：</p><p>假设有两个会话，他们分别有一个事务，SessionA和SessionB</p><ol><li><p>脏写</p><p>事务A修改了另一个未提交的事务B修改过的数据，并且还提交了，之后如果事务B发生了回滚，数据就变成事务B修改之前的状态了，但是事务A已经提交了，按道理说数据不应该变，这就是脏写。</p><p><img src="/image/mysql/mysql52.png"></p></li><li><p>脏读</p><p>事务A读取了事务B更新但还没有被提交的字段，之后如果事务B回滚，事务A读取的内容就是临时无效的。</p><p><img src="/image/mysql/mysql53.png"></p></li><li><p>不可重复读</p><p>事务A读取了一个字段，然后事务B更新了这个字段，之后事务A再次读取同一个字段，值不同了，这就是发生了不可重复读</p><p><img src="/image/mysql/mysql54.png"></p></li><li><p>幻读</p><p>事务A从表中读取了一个字段，然后事务B在该表中插入了一些新的行，之后如果事务A再次读取同一个表，就会多出几行，那就意味着发生了幻读，好像出现了幻觉一样，觉得是凭空出现的数据。</p><p><img src="/image/mysql/mysql55.png"></p></li></ol><h2 id="5-2-SQL中的四种隔离级别"><a href="#5-2-SQL中的四种隔离级别" class="headerlink" title="5.2 SQL中的四种隔离级别"></a>5.2 SQL中的四种隔离级别</h2><p><img src="/image/mysql/mysql55.png"></p><h2 id="5-3-MySQL支持的隔离级别"><a href="#5-3-MySQL支持的隔离级别" class="headerlink" title="5.3 MySQL支持的隔离级别"></a>5.3 MySQL支持的隔离级别</h2><p>MySQL默认支持的是REPEATABLE  READ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;<br>+-----------------------+-----------------+<br>| Variable_name         | Value           |<br>+-----------------------+-----------------+<br>| transaction_isolation | REPEATABLE-READ |<br>+-----------------------+-----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><hr><p>修改MySQL的事务隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;<br>#其中，隔离级别格式：<br>&gt; READ-UNCOMMITTED<br>&gt; READ-COMMITTED<br>&gt; REPEATABLE-READ<br>&gt; SERIALIZABLE<br></code></pre></td></tr></table></figure><ul><li><p>GLOBAL</p><p>对当前已经存在的<code>会话</code>无效，只对执行完该语句之后产生的会话起作用</p></li><li><p>SESSION</p><p>对当前会话的所有后续的事务有效，如果在事务之间执行，则对后续事务有效，如果在已经开启的事务中间执行，这个事务的隔离级别还是原来的，不会被影响。而且只会影响当前会话</p></li></ul><p>但是如果重启MySQL服务器，会恢复到默认的设置</p><hr><h3 id="①脏读的现象-—-read-uncommitted"><a href="#①脏读的现象-—-read-uncommitted" class="headerlink" title="**①脏读的现象 ** —&gt;  read-uncommitted"></a>**①脏读的现象 ** —&gt;  read-uncommitted</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#事务A，事务B的隔离级别都修改为READ-UNCOMMITTED<br>mysql&gt; set session transaction_isolation = &#x27;READ-UNCOMMITTED&#x27;;<br>#初始表状态<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     100 |<br>| 李四   |       0 |<br>+--------+---------+<br>#事务A<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; update account set balance = balance + 100 where name = &#x27;张三&#x27;;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0 #注意，还未提交<br><br>#事务B<br>mysql&gt; select * from account;#查询到的是临时有效的数据<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     200 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br><br>#事务A<br>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)<br><br>#事务B<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     100 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br>#事务B前后读取的数据不一致，脏读<br></code></pre></td></tr></table></figure><hr><h3 id="②如何避免脏读？-—-read-committed"><a href="#②如何避免脏读？-—-read-committed" class="headerlink" title="②如何避免脏读？ —&gt;  read-committed"></a><strong>②如何避免脏读？</strong> —&gt;  read-committed</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set session transaction_isolation=&#x27;read-committed&#x27;;<br>Query OK, 0 rows affected (0.00 sec)<br>#只要未提交的修改，其他事务都不会读取出这个数据<br><br>#事务A<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; update account set balance = balance - 10 where name = &#x27;张三&#x27;;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |      90 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br><br>#事务B<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     100 |<br>| 李四   |       0 |<br>+--------+---------+<br><br>#事务A<br>mysql&gt; commit;<br>Query OK, 0 rows affected (0.01 sec)<br>#事务B<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |      90 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><hr><h3 id="③如何避免脏读和不可重复读？-—-repeatable-read"><a href="#③如何避免脏读和不可重复读？-—-repeatable-read" class="headerlink" title="③如何避免脏读和不可重复读？ —&gt;  repeatable-read"></a>③如何避免脏读和不可重复读？ —&gt;  repeatable-read</h3><p>在一次事务中读取的某个列的值始终是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set session transaction_isolation=&#x27;repeatable-read&#x27;;<br>Query OK, 0 rows affected (0.00 sec)<br>#事务A<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br>#事务B<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     110 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br>#事务A<br>mysql&gt; update account set balance = balance + 10 where name = &#x27;张三&#x27;;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>#事务B<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     100 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br>#事务A<br>mysql&gt; commit;<br>Query OK, 0 rows affected (0.00 sec)<br>#事务B<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     100 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; commit;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; select * from account;<br>+--------+---------+<br>| name   | balance |<br>+--------+---------+<br>| 张三   |     110 |<br>| 李四   |       0 |<br>+--------+---------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1 id="6-MySQL事务日志"><a href="#6-MySQL事务日志" class="headerlink" title="6.MySQL事务日志"></a>6.MySQL事务日志</h1><p>事务有4种特性：<code>原子性</code>、<code>一致性</code>、<code>隔离性</code>和<code>持久性</code>。那么事务的四种特性到底是基于什么机制实现呢？</p><p>事务的隔离性由 <code>锁机制</code> 实现。</p><p><strong>REDO LOG</strong> 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<code>持久性</code>。</p><p><strong>UNDO LOG</strong>称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的<code>原子性、一致性</code>。</p><p><img src="/image/mysql/mysql64.png"></p><h2 id="6-1-redo日志"><a href="#6-1-redo日志" class="headerlink" title="6.1 redo日志"></a>6.1 redo日志</h2><p>当开启事务后，进行一些列增删改操作，正常commit之后，这些数据是先保存在内存中，在一定的时间内将其刷盘到磁盘上，如果在这个时间或者还未刷盘的时间内，系统宕机了，这些数据就失效了，因此为了避免这种错误，设置了redo日志，它是保存在磁盘上的，每次进行一系列增删改操作，都先保存到redo日志中**(事务执行的过程中一直不断的往redo日志中顺序记录)**，然后在以一定频率刷盘到磁盘中，如果这个时候系统宕机了，redo日志进行数据的恢复。</p><p><strong>InnoDB的更新操作采用的是Write-Ahead Log</strong>(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。先写日志，再写入磁盘。</p><h3 id="6-1-1-重做日志的缓冲-redo-log-buffer"><a href="#6-1-1-重做日志的缓冲-redo-log-buffer" class="headerlink" title="6.1.1 重做日志的缓冲 (redo log buffer)"></a>6.1.1 重做日志的缓冲 (redo log buffer)</h3><p>保存在内存中，易失</p><p>innodb_log_buffer_size：redo log buffer 大小，<code>默认 16M</code>，最大值是4096M，最小值为1M。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%innodb_log_buffer_size%&#x27;;<br>+------------------------+----------+<br>| Variable_name          | Value    |<br>+------------------------+----------+<br>| innodb_log_buffer_size | 16777216 |<br>+------------------------+----------+<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>一个redo log block占用512字节</p><p><img src="/image/mysql/mysql57.png"></p><hr><p><img src="/image/mysql/mysql58.png"></p><p><strong>redo log的刷盘策略</strong>：这里的刷盘是指将redo log buffer（在内存中）中的内容以 <code>一定的频率</code> 刷入到真正的redo log file（在磁盘中） 。</p><blockquote><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <code>文件系统缓存（page cache）</code>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定</p></blockquote><p>InnoDB给出 innodb_flush_log_at_trx_commit参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ol><li><p>设置为0 ：<br>表示每次事务提交时不进行写入文件系统缓存和刷盘操作。（通过系统默认master thread每隔1s进行一次重做日志的同步）</p><p><img src="/image/mysql/mysql61.png"></p></li><li><p>设置为1 ：<br>表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</p><p>在事务中进行更新数据时，实时将这些操作写入redo log buffer中，当事务提交后，立刻将redo log buffer中的内容写入文件系统缓存，然后os立刻将文件系统缓存刷盘到redo file中</p><p><img src="/image/mysql/mysql59.png"></p></li><li><p>设置为2 ：<br>表示每次事务提交时都只把 redo log buffer 内容写入 page cache（操作系统的缓存），不进行同步。由os自己决定什么时候同步到磁盘文件。</p><p><img src="/image/mysql/mysql60.png"></p></li></ol><h3 id="6-1-2-重做日志文件-redo-log-file"><a href="#6-1-2-重做日志文件-redo-log-file" class="headerlink" title="6.1.2 重做日志文件 (redo log file)"></a>6.1.2 重做日志文件 (redo log file)</h3><p><strong>innodb_log_group_home_dir</strong> ：指定 redo log 文件组所在的路径，默认值为.&#x2F;，表示在数据库的数据目录下。MySQL的默认数据目录（ var&#x2F;lib&#x2F;mysql ）下默认有两个名为 ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。<br><strong>innodb_log_files_in_group（log_files文件个数）</strong>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…</p><p><img src="/image/mysql/mysql62.png"></p><p>采用循环使用的方式向redo日志文件组里写数据</p><p>write pos是当前记录的位置，一边写一边往后移动</p><p>checkout是当前要擦除的位置，一边删除一边往后移，删除就是指将数据加载到磁盘中后，就可以情删除日志文件中的记录了。</p><p><img src="/image/mysql/mysql63.png"></p><h2 id="6-2-undo日志"><a href="#6-2-undo日志" class="headerlink" title="6.2 undo日志"></a>6.2 undo日志</h2><p>在事务中 <code>更新数据</code> 的 前置操作 其实是要先写入一个 <code>undo log</code> 。</p><p>undo log并不是真正的恢复到原来事务开启前的状态，而是反向操作，即如果事务中进行的是insert，在undo log 中记录的就是delete，如果是update，undo日志中记录的就是反向的update，即逻辑上回到原来的效果</p><p>InnoDB对undo log的管理采用段的方式，也就是 <code>回滚段（rollback segment）</code> 。每个回滚段记录了1024 个 <code>undo log segment</code>，而在每个<code>undo log segment</code>段中进行 <code>undo页</code> 的申请。</p><p>每个事务只会使用一个回滚段，当数据被修改时，院士的数据会被赋值到回滚段中，但是由于undo log 页可以重用，所以一个回滚段在同一时刻可以服务多个事务。</p><hr><p><strong>回滚段中的数据分类</strong></p><ol><li>事务未提交的回滚数据：该数据是保存的被修改数据对应的原始数据，它关联的事务没有提交，用于实现事务一致性特性</li><li>事务已经提交但未过期的回滚数据</li><li>事务已经提交并且过期的回滚数据</li></ol><hr><p><img src="/image/mysql/mysql65.png"></p><hr><p>先找是否有加载对应的BufferPool有就使用没有就加载读取 —-&gt; 写入UndoLog —&gt;操作执行数据 —&gt; 写入RedoLogBuffer内存 —-&gt; 写入RedoLog到磁盘文件</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
      <tag>事务</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-范式</title>
    <link href="/2022/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E8%8C%83%E5%BC%8F/"/>
    <url>/2022/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>在关系型数据库中，关于数据库表设计的基本原则、规范就称为范式(NF)。</p><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：</p><ul><li><p><code>第一范式（1NF）</code></p><p>字段不可再拆分，具有<strong>原子</strong>特性(最小粒度)</p></li><li><p><code>第二范式（2NF）</code></p><p>表中字段不存在除额外的依赖关系</p><p>比如：<code>成绩表</code> （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课<br> 程号也不能决定成绩，所以“（学号，课程号）→成绩”就是 <code>完全依赖关系</code> 。</p></li><li><p><code>第三范式（3NF）</code></p><p>非主键字段，不能存在间接依赖</p></li><li><p><code>巴斯-科德范式（BCNF）</code></p></li><li><p><code>第四范式(4NF）</code></p></li><li><p><code>第五范式（5NF，又称完美范式）</code></p></li></ul><p>详见参考：</p><p><a href="https://achang.blog.csdn.net/article/details/122687773">https://achang.blog.csdn.net/article/details/122687773</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-索引</title>
    <link href="/2022/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p><code>索引</code>是<code>存储引擎</code>用于从海量数据中快速找到数据记录的一种数据结构，MySQL在进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描。</p><p>索引是在存储引擎中实现的，因此每种存储引擎的索引实现不一定完全相同。</p><p><strong>优点：</strong>索引可以减少磁盘I&#x2F;O的次数(把页面从磁盘加载到内存中耗时长)，加快查询速率。</p><p><strong>缺点：</strong>创建索引和维护索引需要耗费时间，并且索引需要占用磁盘空间，因为它存储在磁盘上。</p><h1 id="1-InnoDB中的索引"><a href="#1-InnoDB中的索引" class="headerlink" title="1. InnoDB中的索引"></a>1. InnoDB中的索引</h1><h2 id="1-1-设计索引"><a href="#1-1-设计索引" class="headerlink" title="1.1 设计索引"></a>1.1 设计索引</h2><p><img src="/image/mysql/mysql6.png"></p><p><img src="/image/mysql/mysql7.png"></p><p>采用B+树的格式，只有最底层的叶子结点存储的是一条条数据，其余的页存储的都是每页数据的目录信息。一个页默认16KB</p><h2 id="1-2-索引分类"><a href="#1-2-索引分类" class="headerlink" title="1.2 索引分类"></a>1.2 索引分类</h2><p>索引按照<strong>物理实现</strong>方式分：</p><h3 id="1-2-1-聚簇索引"><a href="#1-2-1-聚簇索引" class="headerlink" title="1.2.1 聚簇索引"></a>1.2.1 聚簇索引</h3><p>InnoDB中使用B+树这种数据结构设计的索引它是一个整体，这个整体就是聚簇索引。因此聚簇索引不单是一个索引类型，而是一种数据存储方式，用户所有记录都存储在叶子节点（这里的存储是从操作系统底层来说的，而不是用户看到的存放在表中），所以我们可以说数据即索引，索引即数据。在InnoDB中索引存放在<code>表名.ibd</code>中。</p><p><strong>具有这两个特点的B+树称为聚簇索引：</strong></p><ul><li>页内的记录是按照主键的大小顺序排序成一个单向链表，各个存放用户记录的页也是根据页中用户记录的主键大小顺序排序成一个双向链表，存放目录向的页分为不同的层次，在同一层次的页也是根据页中目录项记录的主键大小排成一个双向链表。</li><li>B+树的叶子节点存储的是完整的（每列信息都存储了）用户记录。</li></ul><p>InnoDB存储引擎会自动为我们创建聚簇索引。每个MySQL表只能有一个聚簇索引</p><p>设计索引那里的图片就是聚簇索引</p><p>目录项记录中是<code>主键+页号</code></p><p><strong>优点：</strong></p><ul><li>访问速度更快</li><li>对基于主键的排序查找和范围查找速度很快</li><li>减少io操作</li></ul><p><strong>缺点</strong>：</p><ul><li>插入速度严重依赖于插入顺序，对于InnoDB，我们一般都会定义一个自增的ID列为主键。如果没有定义主键，InnodDB会选择一个非空的唯一索引代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li><li>更新主键的代价很高，因为要依次往后更新。对于InnoDB，我们一般定义主键不可更新</li><li>二级索引访问需要两次索引查找</li></ul><ol start="2"><li>非聚簇索引（二级索引 &#x2F; 辅助索引）</li></ol><blockquote><p>“聚簇”表示数据行和相邻的键值聚簇的存储在一起</p></blockquote><h3 id="1-2-2-非聚簇索引-二级索引"><a href="#1-2-2-非聚簇索引-二级索引" class="headerlink" title="1.2.2 非聚簇索引(二级索引)"></a>1.2.2 非聚簇索引(二级索引)</h3><p><img src="/image/mysql/mysql9.png"></p><p>聚簇索引是以主键作为搜索条件，非聚簇索引是指定其他列做为搜索条件</p><p>目录项记录中是<code>指定列+主键号+页号</code></p><p>数据项记录中是<code>指定列+主键号</code></p><p>比如表中有c1  c2  c3列，c1是主键，但是我们想要以c2列作为搜索条件，就只能创建一个非聚簇索引，但是此时的命令是select * 即需要显示出所有字段，就需要一个回表的操作，找到c2后回聚簇索引中找完整的表记录。</p><h3 id="1-2-3-联合索引"><a href="#1-2-3-联合索引" class="headerlink" title="1.2.3 联合索引"></a>1.2.3 联合索引</h3><p><img src="/image/mysql/mysql8.png"></p><p>也是非聚簇索引，就是可以由多个列联合作为搜索条件。</p><p>目录项记录中是<code>联合的列+页号</code></p><h2 id="1-3-B-树页面特点"><a href="#1-3-B-树页面特点" class="headerlink" title="1.3 B+树页面特点"></a>1.3 B+树页面特点</h2><p><img src="/image/mysql/mysql11.png"></p><ol><li>B+树根节点自被创建起，就永远不会移动</li><li>内节点（非叶子节点）中目录项记录需要唯一，因此二级索引都引用主键索引，即data域中存放主键</li><li>一个页面最少存储2条记录</li></ol><h2 id="1-4-B-树形成过程"><a href="#1-4-B-树形成过程" class="headerlink" title="1.4 B+树形成过程"></a>1.4 B+树形成过程</h2><p>每当为某个表创建一个B+树索引时，都会为这个索引创建一个根节点页面，最开始表中没有数据的时候，每个B+树对应的根节点中既没有用户记录，也没有目录项记录。</p><p>随后向表中插入用户记录时，先把用户记录存储到这个根节点中。</p><p>当根节点的可用空间用完时（一般一个页面只能存取有限的空间），如果想要继续插入记录，此时会将根节点中的所有记录赋值一份到一个新分配的页，然后对这个新页进行页分裂的操作，得到另一个新页，此时新插入的记录根据键值（聚簇索引中是主键值，非聚簇索引中是索引列的值）的大小由低到高分配到新页中，而根节点就变为存储目录项记录的页。</p><h2 id="1-5-B-树查找行记录最多只需1-3次磁盘I-O"><a href="#1-5-B-树查找行记录最多只需1-3次磁盘I-O" class="headerlink" title="1.5 B+树查找行记录最多只需1~3次磁盘I&#x2F;O"></a>1.5 B+树查找行记录最多只需1~3次磁盘I&#x2F;O</h2><p><strong>原因</strong>：</p><p>InnoDB存储引擎中页的大小默认为16KB，一般表的主键类型为int占4个字节，指针类型一般也占4-8个字节，假设忽略其他列的类型大小，则一个也可以存放16KB&#x2F;(8B+8B)&#x3D;1000条用户记录，所以如果是一个三层的B+树可以存放1000×1000×1000条用户记录。但实际情况是每个页面不是全部都是用户记录，可能填不满或者是有其他内容，所以B+树高度一般就是2到4层，但是因为InnoDB存储引擎默认将根节点常驻内存，所以不需要进行页面置换，所以查找某一行记录需要进行磁盘I&#x2F;O的次数最多为1到3次。</p><h2 id="1-6-B-树比B树的好处"><a href="#1-6-B-树比B树的好处" class="headerlink" title="1.6 B+树比B树的好处"></a>1.6 B+树比B树的好处</h2><p>B+树优于B树的根本原因就是B+树只在叶子节点存储数据项记录，非叶子节点仅用于索引，而B树在非叶子节点既保存索引，也存储数据项记录，叶子节点只保存数据记录。</p><ol><li><p>B+树的磁盘读写代价更低</p><p>B树的非叶子节点中也存储了部分用户数据记录，需要占用一定的页面空间，因此非叶子节点就存储不了太多目录项记录，因此到叶子节点那一层的指针就少，树就高了。而B+树将数据项记录都存放在叶子节点，这样相对来说，上面页面中可以容纳的目录项个数就多，树就低了，因此需要的磁盘I&#x2F;O就少了。</p></li><li><p>B+树的查询效率更加稳定</p><p>B+树只需要查到最后一层的某些页面，然后逐个遍历(记录与记录之间是单向链表的形式，页面和页面之间是双向链表的形式)，而B树中非叶子节点中也可能存在数据项，最差的情况可能需要将整个B树的节点都遍历一遍。</p></li></ol><h2 id="1-7-Hash索引和B-树索引的区别"><a href="#1-7-Hash索引和B-树索引的区别" class="headerlink" title="1.7 Hash索引和B+树索引的区别"></a>1.7 Hash索引和B+树索引的区别</h2><p>Memory存储引擎默认采用Hash索引，InnoDB存储引擎默认采用B+树索引。</p><ol><li>Hash索引不能进行范围查找，<code>只能精确查找</code>，B+树可以。因为Hash索引指向的数据是无序的，而B+树的每个叶子节点中都是一个个有序的链表。</li><li>Hash索引不支持ORDER BY 排序，因为Hash索引指向的数据是无序的</li><li>Hash索引不支持联合索引的最左侧原则(联合索引的部分索引无法使用)，因为Hash索引在<code>计算Hash值的时候是将索引键合并后再一起计算hash值</code>，而不会针对每个索引都计算Hash值。</li></ol><h1 id="2-MyISAM中的索引"><a href="#2-MyISAM中的索引" class="headerlink" title="2.MyISAM中的索引"></a>2.MyISAM中的索引</h1><p>都是非聚簇索引，因为将索引和数据分开存储。索引的叶子节点存储的是<code>主键值+数据记录地址</code></p><p><img src="/image/mysql/mysql10.png"></p><p>底层也是使用的B+树</p><h1 id="3-索引的声明和使用"><a href="#3-索引的声明和使用" class="headerlink" title="3.索引的声明和使用"></a>3.索引的声明和使用</h1><p><strong>索引的分类</strong>：</p><ul><li><p><font color='red'><strong>按照功能逻辑上分有：</strong></font></p><ul><li><p><font color='blue'>普通索引</font></p><p>不附加任何约束条件，只创建索引，就是为了提高查询效率</p></li><li><p><font color='blue'>唯一索引</font></p><p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一索引时限制该索引的值必须是唯一的，但允许有空值，一个表里可以有多个唯一索引。</p></li><li><p><font color='blue'>主键索引</font></p><p>特殊的唯一索引，在唯一索引的基础上增加了不为空的约束，即NOT NULL+UNIQUE，一个表中最多有一个主键索引</p></li><li><p><font color='blue'>全文索引</font></p><p>使用参数FULLTEXT设置索引为全文索引，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度</p></li></ul></li><li><p><font color='red'><strong>按照物理实现方式分：</strong></font></p><ul><li><font color='blue'>聚簇索引(其实就是主键索引)</font></li><li><font color='blue'>非聚簇索引</font></li></ul></li><li><p><font color='red'><strong>按照作用字段个数分：</strong></font></p><ul><li><p><font color='blue'>单列索引</font></p><p>在表的单个字段上创建索引，单列索引只根据该字段进行索引，一个表可以有多个单列索引。单列所以可以是普通索引&#x2F;唯一所以&#x2F;全文索引</p></li><li><p><font color='blue'>联合索引</font></p><p>即多列索引，在表的多个字段组合上创建一个索引，该索引指向创建时对应的多个字段，可以使用这几个字段一起查询，查询中至少使用这些字段的第一个字段，索引才会生效。使用组合索引遵循最左前缀集合。</p><p>先根据第一个字段进行查询，如果第一个字段相同，再根据第二个字段，如果第二个也相同，再根据第三个字段</p></li></ul></li></ul><h1 id="4-索引的创建"><a href="#4-索引的创建" class="headerlink" title="4.索引的创建"></a>4.索引的创建</h1><h2 id="4-1-隐式创建索引"><a href="#4-1-隐式创建索引" class="headerlink" title="4.1 隐式创建索引"></a>4.1 隐式创建索引</h2><p>在声明有主键约束，唯一性约束，外键约束的字段上会自动添加相关索引</p><ol><li><p>将表中一字段设置为主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user5(<br>    -&gt; tb_id int primary key,<br>    -&gt; tb_name varchar(20)<br>    -&gt; );<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql15.png"></p></li><li><p>外键、唯一性约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user6(<br>    -&gt; tb_id int primary key,<br>    -&gt; tb_name varchar(20) unique,<br>    -&gt; tb5_id int,<br>    -&gt; constraint tb6_tb5_id foreign key(tb5_id) references tb_user5(tb_id)<br>    -&gt; );<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql17.png"></p></li></ol><hr><h2 id="4-2-显式创建索引"><a href="#4-2-显式创建索引" class="headerlink" title="4.2 显式创建索引"></a>4.2 显式创建索引</h2><ol><li><p>创建普通索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user7(<br>    -&gt; tb_id int,<br>    -&gt; tb_name varchar(20),<br>    -&gt; index idx_tb_id(tb_id)<br>    -&gt; );<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql16.png"></p><ol start="2"><li>创建唯一索引</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user8(<br>    -&gt; tb_id int,<br>    -&gt; tb_name varchar(20),<br>    -&gt; unique index uk_idx_tb_id(tb_id)<br>    -&gt; );<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql18.png"></p><p>相对应字段也会有唯一性约束主键索引</p></li><li><p>主键索引</p><p>就是创建主键的时候会自动生成索引</p></li><li><p>联合索引</p><p>多个字段一起作为索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user9( tb_id int, tb_name varchar(20),index mul_idx_tb_id(tb_id,tb_name) );<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql19.png"></p></li></ol><h2 id="4-6-表已经创建成功后添加索引"><a href="#4-6-表已经创建成功后添加索引" class="headerlink" title="4.6 表已经创建成功后添加索引"></a>4.6 表已经创建成功后添加索引</h2><ol><li>alter table … add …</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table tb_user7 add index idx_id(tb_id); //普通索引<br>mysql&gt; alter table tb_user7 add unique index uk_idx_id(tb_id); //唯一索引<br>mysql&gt; alter table tb_user7 add index mul_idx_id(tb_id,tb_name);//联合索引<br></code></pre></td></tr></table></figure><ol start="2"><li>create index ….  on ….</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create index idx_id on tb_user7(tb_id);<br>mysql&gt; create unique index idx_id on tb_user7(tb_id);<br>mysql&gt; create index mul_idx_id on tb_user7(tb_id,tb_name);<br></code></pre></td></tr></table></figure><h1 id="5-删除索引"><a href="#5-删除索引" class="headerlink" title="5.删除索引"></a>5.删除索引</h1><ol><li>方式一：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名 drop index 索引名;<br></code></pre></td></tr></table></figure><p>添加auto_increment约束字段的唯一索引不能被删除</p><ol start="2"><li>方式二：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop index 索引名 on 表名;<br></code></pre></td></tr></table></figure><h1 id="6-MySQL8-0新特性【降序索引】"><a href="#6-MySQL8-0新特性【降序索引】" class="headerlink" title="6.MySQL8.0新特性【降序索引】"></a>6.MySQL8.0新特性【降序索引】</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user8(<br>    -&gt; a int,<br>    -&gt; b int,<br>    -&gt; index idx_a_b(a asc,b desc)<br>    -&gt; );<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql20.png"></p><p><code>Collation</code>那一列中A表示升序，D表示降序</p><h1 id="7-MySQL8-0新特性【隐藏索引】"><a href="#7-MySQL8-0新特性【隐藏索引】" class="headerlink" title="7.MySQL8.0新特性【隐藏索引】"></a>7.MySQL8.0新特性【隐藏索引】</h1><p>如果将一个索引删除需要消耗系统过多的资源的时候，就不适合将这个索引删除，因此有隐藏索引，先将待删除的<code>索引设置为隐藏索引后，这个索引就不起作用了</code>，看看系统是否受到很大的影响，没有太大影响就可以将它删除。</p><ol><li>创建表时，添加隐藏索引</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user7(<br>    -&gt; tb_id int,<br>    -&gt; tb_name varchar(20),<br>    -&gt; index idx_tb_id(tb_id) invisiable //不可见<br>    -&gt; );<br></code></pre></td></tr></table></figure><ol start="2"><li>表已经创建，添加隐藏索引</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table tb_user7 add index idx_id(tb_id) invisiable; <br></code></pre></td></tr></table></figure><ol start="3"><li>修改索引的可见性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//将索引修改为不可见<br>mysql&gt; alter table tb_user7 alter index idx_id(tb_id) invisiable; <br></code></pre></td></tr></table></figure><blockquote><p>当索引被隐藏时，它的内容仍然和正常索引一样实时更新，只是不能用</p></blockquote><h1 id="8-适合创建索引的情况"><a href="#8-适合创建索引的情况" class="headerlink" title="8.适合创建索引的情况"></a>8.适合创建索引的情况</h1><ol><li><p>字段的数值有唯一性的限制</p></li><li><p>频繁作为where查询条件的字段</p></li><li><p>经常group by和order by的列 (本来就需要排序或者分组)</p><p>如果group by和order by 都有，创建一个联合索引，先写group by </p></li><li><p>update、delete的where条件列的查询的字段</p></li><li><p>DISTINCT字段需要创建索引</p><p>DISTINCT的作用是对字段进行去重，如果创建了索引，相同的列都是在一起的，去重就更快</p></li><li><p>多表JOIN连接时创建索引</p></li><li><p>使用列的类型更小的字段创建索引</p><p>一个页能容纳更多的记录</p></li><li><p>使用字符串前缀创建索引</p><p>如果一个字符串要设置索引，由于字符串很长，就可以截取字段前面一部分内容创建索引，这就叫前缀索引，没有必要对全字创建索引</p><p>create table shop(address varchar(120)  not null);</p><p>alter table shop add index(address(12));</p></li><li><p>区分度高的列适合作为索引</p></li><li><p>使用最频繁的列适合放到联合索引的左侧</p></li><li><p>在多个字段都要创建索引时，联合索引优于单列索引</p></li></ol><h1 id="9-不适合创建索引的情况"><a href="#9-不适合创建索引的情况" class="headerlink" title="9. 不适合创建索引的情况"></a>9. 不适合创建索引的情况</h1><ol><li><p>数据量小的表最好不要使用索引</p></li><li><p>在where中使用不到的字段不要设置索引</p></li><li><p>有大量重复数据的列不要建立索引</p><p>需要多次访问很多页</p></li><li><p>不要对经常更新的表创建过多索引</p></li><li><p>不建议用无序的值作为索引</p></li><li><p>最好删除不再使用或者很少使用的索引</p></li><li><p>不要定义冗余或者重复的索引</p></li></ol><p>索引是一把双刃剑，可以提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一个小技巧~</title>
    <link href="/2022/03/24/Problems/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/03/24/Problems/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="md文件"><a href="#md文件" class="headerlink" title="md文件"></a>md文件</h1><ol><li>字体颜色</li></ol><p><font color='blue'>这是蓝色的字体</font></p><p><font color='red'>这是红色的字体</font></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">&lt;font color=&#x27;blue&#x27;&gt;这是蓝色的字体&lt;/font&gt;<br>&lt;font color=&#x27;red&#x27;&gt;这是红色的字体&lt;/font&gt;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析excel表到数据库</title>
    <link href="/2022/03/24/Problems/excel/"/>
    <url>/2022/03/24/Problems/excel/</url>
    
    <content type="html"><![CDATA[<p>最近项目有一个需求，需要批量上传excel表中的数据到数据库中，excel表的标题和数据库中相应表的字段不同，需要获取到excel中的数据后对应着数据库中的字段添加。excel表中还可能包含图片，所以也需要将图片解析。</p><p><strong>首先</strong>需要导入解析excel需要的jar包，如果使用maven，则导入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml-schemas<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>然后</strong>先读取整个excel表，得到一个Workbook对象wb</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Workbook</span> <span class="hljs-variable">wb</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> excel.getOriginalFilename();<br>InputStream <span class="hljs-type">is</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> excel.getInputStream();<br><span class="hljs-keyword">if</span> (filename.endsWith(<span class="hljs-string">&quot;.xls&quot;</span>)) &#123;<br>    wb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>(is);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filename.endsWith(<span class="hljs-string">&quot;.xlsx&quot;</span>)) &#123;<br>    wb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(is);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/excel/excel1.png"></p><p>这里有两种格式的excel表，一个是以.xls结尾，另一个是以.xlsx结尾</p><blockquote><p>1、xls是复合文档类型的结构，xlsx是基于XML的压缩方式；2、xls是2003及以前版本的文件格式，xlsx是2007及以后版本的文件格式</p><p>HSSFWorkbook、XSSFWorkbook都实现了WorkBook接口</p></blockquote><p><img src="/image/excel/excel2.png"></p><p>如果wb对象不空，就可以获取里面的sheet（工作表）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sheetSize</span> <span class="hljs-operator">=</span> wb.getNumberOfSheets();<span class="hljs-comment">//获取总工作表数</span><br><span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> wb.getSheetAt(i)<span class="hljs-comment">//获取工作表 范围是 0~(sheetSize-1)</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sheetName</span> <span class="hljs-operator">=</span> sheet.getSheetName();<br></code></pre></td></tr></table></figure><p>获取第1行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">rowSize</span> <span class="hljs-operator">=</span> sheet.getPhysicalNumberOfRows();<span class="hljs-comment">//获取有记录的行数</span><br><span class="hljs-type">Row</span> <span class="hljs-variable">firstRow</span> <span class="hljs-operator">=</span> sheet.getRow(i);<span class="hljs-comment">//获取每列 范围是 0~(rowSize-1)</span><br></code></pre></td></tr></table></figure><p><img src="/image/excel/excel3.png"></p><p>获取列的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">columnSize</span> <span class="hljs-operator">=</span> firstRow.getPhysicalNumberOfCells();<span class="hljs-comment">//获取有记录的列数</span><br></code></pre></td></tr></table></figure><p>到现在为止，已经可以精确定位到哪一行的那一列上了，就可以唯一确定一个单元格，即一个cell</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> firstRow.getCell(i);<span class="hljs-comment">//获取第i行的每个cell</span><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cell.getStringCellValue()<span class="hljs-comment">//获取cell的值，还有其他形式的</span><br><span class="hljs-type">int</span> cellType= cell.getCellType();<br></code></pre></td></tr></table></figure><p><img src="/image/excel/excel4.png"></p><p><strong>上面部分只能获取非图片数据，那么图片数据应该如何获取呢？</strong></p><p>获取工作表每行的图片数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, PictureData&gt; pictureMap;<br><span class="hljs-keyword">if</span>(excel.getOriginalFilename().endsWith(<span class="hljs-string">&quot;.xls&quot;</span>))&#123;<br>     pictureMap = getPictures1((HSSFSheet) sheet);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>     pictureMap = getPictures2((XSSFSheet) sheet);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/excel/excel5.png"></p><p><img src="/image/excel/excel6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//getPictures1</span><br> List&lt;HSSFShape&gt; list = sheet.getDrawingPatriarch().getChildren();<br><span class="hljs-keyword">for</span> (HSSFShape shape : list) &#123;<br>    <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> HSSFPicture) &#123;<br>         <span class="hljs-type">HSSFPicture</span> <span class="hljs-variable">picture</span> <span class="hljs-operator">=</span> (HSSFPicture) shape;<br>          <span class="hljs-type">PictureData</span> <span class="hljs-variable">pdata</span> <span class="hljs-operator">=</span> picture.getPictureData();<span class="hljs-comment">//获取图片数据</span><br>        <span class="hljs-comment">//获取图片在sheet中的位置信息</span><br>         <span class="hljs-type">HSSFClientAnchor</span> <span class="hljs-variable">cAnchor</span> <span class="hljs-operator">=</span> (HSSFClientAnchor) picture.getAnchor();<br>          <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(cAnchor.getRow1()); <span class="hljs-comment">// 行号</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//getPictures2</span><br>List&lt;POIXMLDocumentPart&gt; list = sheet.getRelations();<br><span class="hljs-keyword">for</span> (POIXMLDocumentPart part : list) &#123;<br>    <span class="hljs-keyword">if</span> (part <span class="hljs-keyword">instanceof</span> XSSFDrawing) &#123;<br>        <span class="hljs-type">XSSFDrawing</span> <span class="hljs-variable">drawing</span> <span class="hljs-operator">=</span> (XSSFDrawing) part;<br>        List&lt;XSSFShape&gt; shapes = drawing.getShapes();<br>        <span class="hljs-keyword">for</span> (XSSFShape shape : shapes) &#123;<br>            <span class="hljs-type">XSSFPicture</span> <span class="hljs-variable">picture</span> <span class="hljs-operator">=</span> (XSSFPicture) shape;<br>            <span class="hljs-type">PictureData</span> <span class="hljs-variable">pdata</span> <span class="hljs-operator">=</span> picture.getPictureData();<span class="hljs-comment">//获取此形状的图片数据</span><br>            <span class="hljs-comment">//获取图片在sheet中的位置信息</span><br>            <span class="hljs-type">XSSFClientAnchor</span> <span class="hljs-variable">anchor</span> <span class="hljs-operator">=</span> picture.getPreferredSize();<span class="hljs-comment">//计算这张图片的首选尺寸。</span><br>            <span class="hljs-type">CTMarker</span> <span class="hljs-variable">marker</span> <span class="hljs-operator">=</span> anchor.getFrom();<span class="hljs-comment">//返回起始锚点</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(marker.getRow());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考POI API文档以及网上相关资料</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题</tag>
      
      <tag>化异构为同构</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-安装与卸载</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="1-查看状态"><a href="#1-查看状态" class="headerlink" title="1.查看状态"></a>1.查看状态</h1><p><code>rpm -qa | grep -i mysql</code></p><p>查看当前服务器是否安装了mysql(有哪些与mysql相关的已安装程序)</p><p><img src="/image/mysql/mysql1.png"></p><p><code>systemctl status mysqld.service</code></p><p>查看mysql的运行状态</p><p><img src="/image/mysql/mysql2.png"></p><h1 id="2-卸载"><a href="#2-卸载" class="headerlink" title="2.卸载"></a>2.卸载</h1><ol><li>关闭mysql服务</li></ol><p><code>systemctl stop mysqld.service</code></p><ol><li><code>yum remove 文件名</code></li></ol><p>删除这几个文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>-community-libs-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">36</span>-<span class="hljs-number">1</span>.el7.x86_64<br><span class="hljs-attribute">mysql57</span>-community-release-el7-<span class="hljs-number">9</span>.noarch<br><span class="hljs-attribute">mysql</span>-community-client-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">36</span>-<span class="hljs-number">1</span>.el7.x86_64<br><span class="hljs-attribute">mysql</span>-community-common-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">36</span>-<span class="hljs-number">1</span>.el7.x86_64<br><span class="hljs-attribute">mysql</span>-community-server-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">36</span>-<span class="hljs-number">1</span>.el7.x86_64<br></code></pre></td></tr></table></figure><ol start="2"><li>删除mysql相关文件</li></ol><p><code>find / -name mysql</code></p><ol start="3"><li>查找名字是mysql的目录&#x2F;文件</li></ol><p><code>rm -rf 文件名/目录名</code></p><ol start="4"><li>删除my.cnf</li></ol><p><code>rm -rf /etc/my.cnf</code></p><h1 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h1><ol><li>给&#x2F;tmp目录足够的权限</li></ol><p><code>chmod -R 777 /tmp</code></p><ol start="2"><li>检查依赖</li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@iz2zeip0loevltpebhi0txz</span> ~]<span class="hljs-meta"># rpm -qa|grep libaio</span><br>libaio<span class="hljs-number">-0.3</span><span class="hljs-number">.109</span><span class="hljs-number">-13.</span>el7.x86_64<br>[root<span class="hljs-symbol">@iz2zeip0loevltpebhi0txz</span> ~]<span class="hljs-meta"># rpm -qa|grep net-tools</span><br>net-tools<span class="hljs-number">-2.0</span><span class="hljs-number">-0.17</span><span class="hljs-number">.20131004</span>git.el7.x86_64<br></code></pre></td></tr></table></figure><ol start="3"><li><p>将安装程序拷贝到&#x2F;opt目录下</p></li><li><p>安装</p></li></ol><p><code>rpm -ivh 文件名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">mysql-community-common-<span class="hljs-number">8.0</span><span class="hljs-number">.28</span>-<span class="hljs-number">1.</span>el7.x86_64<br>mysql-community-client-plugins-<span class="hljs-number">8.0</span><span class="hljs-number">.28</span>-<span class="hljs-number">1.</span>el7.x86_64<br>mysql-community-libs-<span class="hljs-number">8.0</span><span class="hljs-number">.28</span>-<span class="hljs-number">1.</span>el7.x86_64<br>mysql-community-client-<span class="hljs-number">8.0</span><span class="hljs-number">.28</span>-<span class="hljs-number">1.</span>el7.x86_64<br>mysql-community-icu-data-files-<span class="hljs-number">8.0</span><span class="hljs-number">.28</span>-<span class="hljs-number">1.</span>el7.x86_64<br>mysql-community-server-<span class="hljs-number">8.0</span><span class="hljs-number">.28</span>-<span class="hljs-number">1.</span>el7.x86_64<br></code></pre></td></tr></table></figure><ol start="5"><li>查看版本</li></ol><p><code>mysql --version</code></p><h1 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4. 初始化"></a>4. 初始化</h1><ol><li>服务初始化</li></ol><p><code> mysqld --initialize --user=mysql</code></p><ol start="2"><li>查看密码</li></ol><p><code>cat /var/log/mysqld.log</code></p><ol start="3"><li>启动mysql</li></ol><p><code>systemctl start mysqld</code></p><ol start="4"><li>是否自启动</li></ol><p><code>systemctl list-unit-files|grep mysqld.service</code></p><p>enable就是开机自启动</p><ol start="5"><li>初始登录，使用初始密码</li></ol><p><code>mysql -u root -p</code></p><ol start="6"><li>修改初始化密码</li></ol><p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;新密码&#39;;</code>（其他地方不用改）</p><h1 id="5-远程连接"><a href="#5-远程连接" class="headerlink" title="5.远程连接"></a>5.远程连接</h1><ol><li>防火墙开放<code>3306</code>端口</li><li>mysql数据库授权任何IP地址的主机都可以远程连接mysql数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>mysql&gt; use mysql;<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>mysql&gt; select host,user from user;;<br>+-----------+------------------+<br>| host      | user             |<br>+-----------+------------------+<br>| localhost | mysql.infoschema |<br>| localhost | mysql.session    |<br>| localhost | mysql.sys        |<br>| localhost | root             | //只有localhost本机才可以连接数据库<br>+-----------+------------------+<br>4 rows in set (0.00 sec)<br>mysql&gt; update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;//任何主机都可以远程连接<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br><br>mysql&gt; select host,user from user;;<br>+-----------+------------------+<br>| host      | user             |<br>+-----------+------------------+<br>| %         | root             |<br>| localhost | mysql.infoschema |<br>| localhost | mysql.session    |<br>| localhost | mysql.sys        |<br>+-----------+------------------+<br>4 rows in set (0.00 sec)<br>mysql&gt; flush privileges;//更新<br>Query OK, 0 rows affected (0.01 sec)<br>mysql&gt; alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;196131&#x27;;<br>Query OK, 0 rows affected (0.01 sec)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-逻辑架构</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>MySQL是C&#x2F;S架构，即Client&#x2F;Server架构，服务器端程序使用的是mysqld</p><p><img src="/image/mysql/mysql5.png"></p><h1 id="1-Connectors-客户端"><a href="#1-Connectors-客户端" class="headerlink" title="1.Connectors(客户端)"></a>1.Connectors(客户端)</h1><p>MySQL服务器之外的客户端程序，用于连接MySQL服务器。不同语言与SQL的交互.</p><p>常见的客户端程序有Native C API，JDBC，ODBC等，本质上还是在TCP连接上通过MySQL协议与MySQL进行交互。</p><h1 id="2-MySQL内部架构-DBMS"><a href="#2-MySQL内部架构-DBMS" class="headerlink" title="2.MySQL内部架构(DBMS)"></a>2.MySQL内部架构(DBMS)</h1><h2 id="2-1-连接层"><a href="#2-1-连接层" class="headerlink" title="2.1 连接层"></a>2.1 连接层</h2><p><code>Connection Pool(连接池)</code></p><p>客户端访问MySQL服务器前，需要先建立TCP连接，三次握手建立成功之后，Connection Pool会查询用户名和密码是否一致以及权限表中是否有响应权限</p><h2 id="2-2-服务层"><a href="#2-2-服务层" class="headerlink" title="2.2 服务层"></a>2.2 服务层</h2><p><code>SQL Interface</code>：SQL接口，接收SQL指令，返回查询结果</p><p><code>Parser</code>：解析器，语法解析和语义解析，生成语法树（分析你要做什么）</p><p><code>Optimizer</code>：优化器，对SQL进行优化</p><p><code>Caches &amp; Buffers</code>：查询缓存，以key-value的方式缓存查询结果，MySQL8.0已经弃用</p><h2 id="2-3-引擎层"><a href="#2-3-引擎层" class="headerlink" title="2.3 引擎层"></a>2.3 引擎层</h2><p>插件式的存储引擎，与底层文件系统进行交互。</p><p>MySQL服务器上的存储引擎负责对表中数据进行读取和写入工作。不同的存储引擎中数据存放的格式是不同的，索引是在存储引擎中实现的。</p><p>MyIASM &#x2F; InnoDB &#x2F; Memory   等等….</p><p>MySQL8.0以后的默认存储引擎是InnoDB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show create table tb_user1 \G;<br>*************************** 1. row ***************************<br>Table: tb_user1<br>Create Table: CREATE TABLE `tb_user1` (<br>  `id` int DEFAULT NULL,<br>  `name` varchar(20) DEFAULT NULL,<br>  `age` int DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>也可以显式地指明表的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user3(<br>     &gt; id int<br>     &gt; ) engine=MyISAM;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; show create table tb_user3 \G;<br>*************************** 1. row ***************************<br>Table: tb_user3<br>Create Table: CREATE TABLE `tb_user3` (<br>  `id` int DEFAULT NULL<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="2-3-1-InnoDB"><a href="#2-3-1-InnoDB" class="headerlink" title="2.3.1 InnoDB"></a>2.3.1 InnoDB</h3><p>5.5版本之后默认采用的引擎</p><ul><li>具备<strong>外键支持</strong>功能的事务存储引擎。</li><li>InnoDB是MySQL的默认事务型引擎，它被用来<strong>处理大量的短期事务</strong>，确保事务的完整性提交和回滚</li><li>除了insert和select之外，还需要update、delete操作时选它</li><li>InnoDB是为处理巨大数据量的性能设计</li></ul><p>缺点：1.写的处理效率差，2.对内存要求高</p><h3 id="2-3-2-MyISAM"><a href="#2-3-2-MyISAM" class="headerlink" title="2.3.2 MyISAM"></a>2.3.2 MyISAM</h3><p>不支持事务，行级锁，外键。</p><p>优点：访问速度快，主要是读为主的应用</p><p><strong>对比</strong></p><p><img src="/image/mysql/mysql4.png"></p><h1 id="3-存储层-磁盘"><a href="#3-存储层-磁盘" class="headerlink" title="3.存储层(磁盘)"></a>3.存储层(磁盘)</h1><p>File system：将需要的内容加载到内存中</p><p>日志文件</p><h1 id="4-SQL执行流程"><a href="#4-SQL执行流程" class="headerlink" title="4.SQL执行流程"></a>4.SQL执行流程</h1><p><img src="/image/mysql/mysql3.png"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-目录结构</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-mysql8的主要目录结构"><a href="#1-mysql8的主要目录结构" class="headerlink" title="1.mysql8的主要目录结构"></a>1.mysql8的主要目录结构</h1><ol><li>mysql数据库文件的存放路径：<code>/var/lib/mysql</code></li></ol><p>创建的数据库就是存放在这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_user1(<br>    -&gt; id int(11),<br>    -&gt; name varchar(20),<br>    -&gt; age int(11)<br>    -&gt; );<br><br></code></pre></td></tr></table></figure><p>在test数据库中创建一个tb_user1表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">total 188884<br>-rw-r----- 1 mysql mysql       56 Mar 22 08:39 auto.cnf<br>-rw-r----- 1 mysql mysql      478 Mar 22 09:13 binlog.000001<br>-rw-r----- 1 mysql mysql     1817 Mar 22 16:15 binlog.000002<br>-rw-r----- 1 mysql mysql       32 Mar 22 09:13 binlog.index<br>-rw------- 1 mysql mysql     1680 Mar 22 08:39 ca-key.pem<br>-rw-r--r-- 1 mysql mysql     1112 Mar 22 08:39 ca.pem<br>-rw-r--r-- 1 mysql mysql     1112 Mar 22 08:39 client-cert.pem<br>-rw------- 1 mysql mysql     1676 Mar 22 08:39 client-key.pem<br>-rw-r----- 1 mysql mysql   196608 Mar 22 16:17 #ib_16384_0.dblwr<br>-rw-r----- 1 mysql mysql  8585216 Mar 22 08:39 #ib_16384_1.dblwr<br>-rw-r----- 1 mysql mysql     5944 Mar 22 08:39 ib_buffer_pool<br>-rw-r----- 1 mysql mysql 12582912 Mar 22 16:15 ibdata1<br>-rw-r----- 1 mysql mysql 50331648 Mar 22 16:17 ib_logfile0<br>-rw-r----- 1 mysql mysql 50331648 Mar 22 08:39 ib_logfile1<br>-rw-r----- 1 mysql mysql 12582912 Mar 22 09:13 ibtmp1<br>drwxr-x--- 2 mysql mysql     4096 Mar 22 09:13 #innodb_temp<br>drwxr-x--- 2 mysql mysql     4096 Mar 22 08:39 mysql<br>-rw-r----- 1 mysql mysql 25165824 Mar 22 16:15 mysql.ibd<br>srwxrwxrwx 1 mysql mysql        0 Mar 22 09:13 mysql.sock<br>-rw------- 1 mysql mysql        4 Mar 22 09:13 mysql.sock.lock<br>drwxr-x--- 2 mysql mysql     4096 Mar 22 08:39 performance_schema<br>-rw------- 1 mysql mysql     1676 Mar 22 08:39 private_key.pem<br>-rw-r--r-- 1 mysql mysql      452 Mar 22 08:39 public_key.pem<br>-rw-r--r-- 1 mysql mysql     1112 Mar 22 08:39 server-cert.pem<br>-rw------- 1 mysql mysql     1680 Mar 22 08:39 server-key.pem<br>drwxr-x--- 2 mysql mysql     4096 Mar 22 08:39 sys<br>drwxr-x--- 2 mysql mysql     4096 Mar 22 16:15 test //这是我刚刚创建的test数据库<br>-rw-r----- 1 mysql mysql 16777216 Mar 22 16:15 undo_001<br>-rw-r----- 1 mysql mysql 16777216 Mar 22 16:17 undo_002<br></code></pre></td></tr></table></figure><ol start="2"><li>相关命令目录</li></ol><p><code>/usr/bin</code>和<code>/usr/sbin</code></p><ol start="3"><li>配置文件目录</li></ol><p><code>/usr/share/mysql-8.0</code> 和<code>/etc/mysql</code>下的my.cnf</p><h1 id="2-表在文件系统中的表示"><a href="#2-表在文件系统中的表示" class="headerlink" title="2.表在文件系统中的表示"></a>2.表在文件系统中的表示</h1><p>现在数据库test中有一表<code>tb_user1</code></p><p><code>cd test</code></p><h2 id="2-1-InnoDB存储引擎模式"><a href="#2-1-InnoDB存储引擎模式" class="headerlink" title="2.1 InnoDB存储引擎模式"></a>2.1 InnoDB存储引擎模式</h2><p>如果表采用InnoDB的模式</p><p>在mysql5.7中test文件夹中有：</p><ul><li><code>tb_user1.frm</code>：表述表结构文件，字段长度</li><li>如果采用系统表空间模式，数据信息和索引信息都存储在<code>ibdata1</code>中(在<code>/var/lib/mysql</code>中)</li><li>如果采用独立表空间存储模式，test文件夹中还会产生<code>tb_user1.ibd</code>文件，来存储数据信息和索引信息</li><li>唯一一个<code>db.opt</code>保存数据库相关配置信息，如字符集，比较规则</li></ul><p>在mysql8.0中test文件夹中：</p><ul><li><code>tb_user1.ibd</code>文件，mysl5.7中的<code>tb_user1.frm</code>已经合并到.ibd文件中了</li><li>如果采用系统表空间模式，数据信息和索引信息都存储在<code>ibdata1</code>中(在<code>/var/lib/mysql</code>中)</li><li>如果采用独立表空间存储模式，test文件夹中还会产生<code>tb_user1.ibd</code>文件，来存储数据信息和索引信息</li></ul><p>不过8.0都是采用的独立表空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@iz2zeip0loevltpebhi0txz mysql]# cd test<br>[root@iz2zeip0loevltpebhi0txz test]# ll<br>total 112<br>-rw-r----- 1 mysql mysql 114688 Mar 22 16:15 tb_user1.ibd<br></code></pre></td></tr></table></figure><h2 id="2-2-MyISAM存储引擎模式"><a href="#2-2-MyISAM存储引擎模式" class="headerlink" title="2.2 MyISAM存储引擎模式"></a>2.2 MyISAM存储引擎模式</h2><p>对于一个表，test中会产生3个文件：</p><ul><li><p>mysql5.7中：<code>tb_user1.frm</code> 描述表结构文件，字段长度</p><p>mysql8.0中：<code>tb_user1.xxx.sdi</code> 描述表结构文件，字段长度</p></li><li><p><code>tb_user1.MYD(data)</code>：数据文件信息，存储数据信息</p></li><li><p><code>tb_user1.MYI(index)</code>：存放索引信息文件</p></li></ul><p>tb_user3使用的是MyISAM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@iz2zeip0loevltpebhi0txz test]# ll<br>total 232<br>-rw-r----- 1 mysql mysql 114688 Mar 22 16:15 tb_user1.ibd<br>-rw-r----- 1 mysql mysql 114688 Mar 22 20:48 tb_user2.ibd<br>-rw-r----- 1 mysql mysql   1632 Mar 23 09:30 tb_user3_364.sdi<br>-rw-r----- 1 mysql mysql      0 Mar 23 09:30 tb_user3.MYD<br>-rw-r----- 1 mysql mysql   1024 Mar 23 09:30 tb_user3.MYI<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-权限管理</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/mysql/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>| test               |<br>+--------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>数据库中有4个默认的表information_schema， mysql ，performance_schema，sys</p><p>其中<code>mysql</code>就是用来管理数据库用户的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use mysql<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>mysql&gt; select host,user from user;<br>+-----------+------------------+<br>| host      | user             |<br>+-----------+------------------+<br>| %         | root             |<br>| localhost | mysql.infoschema |<br>| localhost | mysql.session    |<br>| localhost | mysql.sys        |<br>+-----------+------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><ul><li><strong>host</strong>：表示可以在哪个IP地址下使用user进行数据库连接，<code>%   root</code>表示任何ip地址都可以使用root进行远程连接数据库，<code>localhost  mysql.sys</code>表示只有本机可以使用mysql.sys用户进行连接。host可以是ip，ip段，域名以及%</li><li><strong>user：</strong>允许登录数据库的用户名</li></ul><h1 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1.用户管理"></a>1.用户管理</h1><h2 id="1-1-创建用户"><a href="#1-1-创建用户" class="headerlink" title="1.1 创建用户"></a>1.1 创建用户</h2><p><code>create user &#39;zhangsan&#39; identified by &#39;123456&#39;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create user &#x27;zhangsan&#x27; identified by &#x27;123456&#x27;;<br>Query OK, 0 rows affected (0.01 sec)<br>mysql&gt; select host,user from user;<br>+-----------+------------------+<br>| host      | user             |<br>+-----------+------------------+<br>| %         | root             |<br>| %         | zhangsan         |<br>| localhost | mysql.infoschema |<br>| localhost | mysql.session    |<br>| localhost | mysql.sys        |<br>+-----------+------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>已经创建了一个zhangsan用户，任何主机都可以使用这个用户名进行登录</p><hr><p>如果想使创建的用户只能在本机连接数据库，需要在用户名后面加上<code>@&#39;localhost&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs my">mysql&gt; create user &#x27;lisi&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; select host,user from user;<br>+-----------+------------------+<br>| host      | user             |<br>+-----------+------------------+<br>| %         | root             |<br>| %         | zhangsan         |<br>| localhost | lisi             |<br>| localhost | mysql.infoschema |<br>| localhost | mysql.session    |<br>| localhost | mysql.sys        |<br>+-----------+------------------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>如果要修改的话就直接修改user表字段就行了，不过在修改完记得更新权限<code>flush privileges;</code></p><h2 id="1-2-删除用户"><a href="#1-2-删除用户" class="headerlink" title="1.2 删除用户"></a>1.2 删除用户</h2><p><code>drop user &#39;zhangsan&#39;</code> &#x2F;&#x2F;默认删除的host为%的<code>普通</code>用户</p><p><code>drop user &#39;lisi&#39;@&#39;localhost&#39;;</code> </p><h2 id="1-3-修改当前用户的密码"><a href="#1-3-修改当前用户的密码" class="headerlink" title="1.3 修改当前用户的密码"></a>1.3 修改当前用户的密码</h2><p>root可以修改自己的密码，普通用户可以登录后修改自己的密码</p><ol><li><p><code>alter user user() identified by &#39;new_password&#39;;</code></p></li><li><p><code>set password=&#39;new_password&#39;;</code></p></li></ol><h2 id="1-4-修改其他用户的密码"><a href="#1-4-修改其他用户的密码" class="headerlink" title="1.4 修改其他用户的密码"></a>1.4 修改其他用户的密码</h2><p>root用户还可以修改其他用户的密码</p><ol><li><p><code>alter user &#39;zhangsan&#39;@&#39;%&#39; identified by &#39;new_password&#39;;</code></p></li><li><p><code>set password for &#39;zhangsan&#39;@&#39;%&#39;=&#39;new_password&#39;;</code></p></li></ol><h1 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h1><h2 id="2-1-查看和授予权限"><a href="#2-1-查看和授予权限" class="headerlink" title="2.1 查看和授予权限"></a>2.1 查看和授予权限</h2><p><code>show grant;</code> 查看当前用户权限</p><p><code>show grant for zhangsan; </code>root用户查看其他用户权限</p><p><code>grant all privileges on *.* to &#39;lisi&#39;@&#39;%&#39;;</code></p><p>权限有：all privileges、select、update、delete、insert</p><p>on表示指定权限针对哪些数据库和表，数据库.表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//root用户下<br>mysql&gt; show grants for zhangsan;<br>+--------------------------------------+<br>| Grants for zhangsan@%                |<br>+--------------------------------------+<br>| GRANT USAGE ON *.* TO `zhangsan`@`%` | //登录权限，所有新创建的用户都具有这个权限<br>+--------------------------------------+<br>//把test数据库中的所有表的select，update权限都给zhangsan用户<br>mysql&gt; grant select,update on test.* to &#x27;zhangsan&#x27;@&#x27;%&#x27;;<br>Query OK, 0 rows affected (0.01 sec)<br>mysql&gt; show grants for zhangsan;<br>+----------------------------------------------------+<br>| Grants for zhangsan@%                              |<br>+----------------------------------------------------+<br>| GRANT USAGE ON *.* TO `zhangsan`@`%`               |<br>| GRANT SELECT, UPDATE ON `test`.* TO `zhangsan`@`%` |<br>+----------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>在zhangsan用户下查看权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| test               |<span class="hljs-comment">//最初是没有这个数据库的，因为上面把test数据库的权限给他了</span><br>+--------------------+<br><span class="hljs-number">2</span> rows in <span class="hljs-title function_">set</span> <span class="hljs-params">(<span class="hljs-number">0.01</span> sec)</span><br>mysql&gt; desc tb_user1;<br>+-------+-------------+------+-----+---------+-------+<br>| Field | Type        | Null | Key | Default | Extra |<br>+-------+-------------+------+-----+---------+-------+<br>| id    | <span class="hljs-type">int</span>         | YES  |     | NULL    |       |<br>| name  | varchar(<span class="hljs-number">20</span>) | YES  |     | NULL    |       |<br>| age   | <span class="hljs-type">int</span>         | YES  |     | NULL    |       |<br>+-------+-------------+------+-----+---------+-------+<br><span class="hljs-number">3</span> rows in <span class="hljs-title function_">set</span> <span class="hljs-params">(<span class="hljs-number">0.00</span> sec)</span><br><span class="hljs-comment">//zhangsan并没有insert权限</span><br>mysql&gt; insert into tb_user1 <span class="hljs-title function_">values</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;lucy&#x27;</span>,<span class="hljs-number">15</span>)</span>;<br>ERROR <span class="hljs-number">1142</span> (<span class="hljs-number">42000</span>): INSERT command denied to user <span class="hljs-string">&#x27;zhangsan&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">for</span> table <span class="hljs-string">&#x27;tb_user1&#x27;</span><br></code></pre></td></tr></table></figure><p>root用户将所有权限授予给lisi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; grant all privileges on *.* to &#x27;lisi&#x27;@&#x27;%&#x27;;<br>Query OK, 0 rows affected (0.01 sec)<br></code></pre></td></tr></table></figure><p>进入lisi查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>| test               |<br>+--------------------+<br></code></pre></td></tr></table></figure><p><code>默认权限不具有传递性，比如root用户给zhangsan select和update权限，但是zhangsan并不能将权限再授权给其他用户</code></p><p>可以使用<code>with grant option</code>，表示将自己拥有的权限授权给他人。</p><p>多次给用户授权不同的权限，会权限叠加而不是覆盖。</p><h2 id="2-2-收回权限"><a href="#2-2-收回权限" class="headerlink" title="2.2 收回权限"></a>2.2 收回权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//收回zhangsan所有库所有表的权限<br>mysql&gt; revoke all privileges on *.* from &#x27;zhangsan&#x27;@&#x27;%&#x27;;<br>Query OK, 0 rows affected (0.01 sec)<br></code></pre></td></tr></table></figure><p>用户退出重新登录数据库后才会生效。</p><p>假如你给zhangsan的权限是test数据库的所有表都有select，那么你不能单独收回test的tb_user1(其中的一个表)的select权限，要收回只能将test数据库的所有表的select权限都收回。</p><h2 id="2-3-权限表"><a href="#2-3-权限表" class="headerlink" title="2.3 权限表"></a>2.3 权限表</h2><p>权限表存放在名为mysql数据库中，mysql服务器通过这些权限表来控制用户对数据库的访问，在mysql启动时，服务器将这些表中权限信息内容读入到内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use mysql<br>Database changed<br>mysql&gt; show tables;<br>+------------------------------------------------------+<br>| Tables_in_mysql                                      |<br>+------------------------------------------------------+<br>| columns_priv   //列层级的权限                          |<br>| component                                            |<br>| db       //数据库层级的权限                             |<br>| default_roles                                        |<br>| engine_cost                                          |<br>| func                                                 |<br>| general_log                                          |<br>| global_grants   //动态全局授权                         |<br>| gtid_executed                                        |<br>| help_category                                        |<br>| help_keyword                                         |<br>| help_relation                                        |<br>| help_topic                                           |<br>| innodb_index_stats                                   |<br>| innodb_table_stats                                   |<br>| password_history                                     |<br>| plugin                                               |<br>| procs_priv                                           |<br>| proxies_priv                                         |<br>| replication_asynchronous_connection_failover         |<br>| replication_asynchronous_connection_failover_managed |<br>| replication_group_configuration_version              |<br>| replication_group_member_actions                     |<br>| role_edges                                           |<br>| server_cost                                          |<br>| servers                                              |<br>| slave_master_info                                    |<br>| slave_relay_log_info                                 |<br>| slave_worker_info                                    |<br>| slow_log                                             |<br>| tables_priv      //表层级的权限                        |<br>| time_zone                                            |<br>| time_zone_leap_second                                |<br>| time_zone_name                                       |<br>| time_zone_transition                                 |<br>| time_zone_transition_type                            |<br>| user     //用户账号及权限信息                           |<br>+------------------------------------------------------+<br></code></pre></td></tr></table></figure><h1 id="3-访问控制"><a href="#3-访问控制" class="headerlink" title="3.访问控制"></a>3.访问控制</h1><h2 id="3-1-连接核实阶段"><a href="#3-1-连接核实阶段" class="headerlink" title="3.1 连接核实阶段"></a>3.1 连接核实阶段</h2><p>检查输入的账号和密码是否与user表中的host、user、authentication_string(加密过的密码)一致。</p><h2 id="3-2-请求核实阶段"><a href="#3-2-请求核实阶段" class="headerlink" title="3.2 请求核实阶段"></a>3.2 请求核实阶段</h2><p><img src="/image/mysql/table.png"></p><h1 id="4-角色"><a href="#4-角色" class="headerlink" title="4.角色"></a>4.角色</h1><p>角色是权限的集合，角色可以被授予或者收回权限，它代表了一类”人”的特征。</p><h2 id="4-1-创建以及删除角色"><a href="#4-1-创建以及删除角色" class="headerlink" title="4.1 创建以及删除角色"></a>4.1 创建以及删除角色</h2><p>创建角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create role &#x27;manager&#x27;;  //等同于create role &#x27;manager&#x27;@&#x27;%&#x27;;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p>删除角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; drop role &#x27;manager&#x27;;  <br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4-2-授予及收回角色权限"><a href="#4-2-授予及收回角色权限" class="headerlink" title="4.2 授予及收回角色权限"></a>4.2 授予及收回角色权限</h2><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//root用户下<br>mysql&gt; grant select,update on test.tb_user1 to &#x27;manager&#x27;;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; show grants for &#x27;manager&#x27;@&#x27;%&#x27;;<br>+------------------------------------------------------------+<br>| Grants for manager@%                                       |<br>+------------------------------------------------------------+<br>| GRANT USAGE ON *.* TO `manager`@`%`                        |<br>| GRANT SELECT, UPDATE ON `test`.`tb_user1` TO `manager`@`%` |<br>+------------------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>取消权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; revoke select,update on test.tb_user1 from &#x27;manager&#x27;;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4-3-给用户赋予角色"><a href="#4-3-给用户赋予角色" class="headerlink" title="4.3 给用户赋予角色"></a>4.3 给用户赋予角色</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; grant &#x27;manager&#x27;@&#x27;%&#x27; to &#x27;zhangsan&#x27;@&#x27;%&#x27;;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; show grants for &#x27;zhangsan&#x27;@&#x27;%&#x27;;<br>+--------------------------------------------+<br>| Grants for zhangsan@%                      |<br>+--------------------------------------------+<br>| GRANT USAGE ON *.* TO `zhangsan`@`%`       |<br>| GRANT UPDATE ON `test`.* TO `zhangsan`@`%` |<br>| GRANT `manager`@`%` TO `zhangsan`@`%`      |<br>+--------------------------------------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>由于mysql中创建角色都是默认没有被激活，所以给用户赋予角色也没有角色的权限，需要激活角色。<code>激活后，用户需要重新登录才能看到赋予的角色以及使用角色的权限。</code></p><p>登录zhangsan用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询当前角色是否被激活<br>mysql&gt; select current_role();<br>+----------------+<br>| current_role() |<br>+----------------+<br>| NONE           |//未被激活，因此用户未具备相应的角色<br>+----------------+<br>1 row in set (0.00 sec)<br>//激活角色<br>mysql&gt; set default role &#x27;manager&#x27;@&#x27;%&#x27; to &#x27;zhangsan&#x27;@&#x27;%&#x27;;<br>Query OK, 0 rows affected (0.00 sec)<br>//退出重新登录<br>mysql&gt; select current_role();<br>+----------------+<br>| current_role() |<br>+----------------+<br>| `manager`@`%`  |<br>+----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>还有一种方法可以对所有角色<strong>永久激活</strong>，新创建的角色都默认激活</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//ROOT用户下<br>mysql&gt; show variables like &#x27;activate_all_roles_on_login&#x27;;<br>+-----------------------------+-------+<br>| Variable_name               | Value |<br>+-----------------------------+-------+<br>| activate_all_roles_on_login | OFF   |<br>+-----------------------------+-------+<br>1 row in set (0.01 sec)<br>mysql&gt; set global activate_all_roles_on_login=on;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>数据库高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><blockquote><p>26   难度：easy</p></blockquote><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 ：</strong></p><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//i指向新数组的最后一个元素下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[j])&#123;<br>                j++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j != i + <span class="hljs-number">1</span>)&#123;<br>                nums[i + <span class="hljs-number">1</span>] = nums[j];<br>            &#125;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针！原地覆盖！</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h1 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a>删除有序数组中的重复项 II</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/</a></p><blockquote><p>80  难度：mid</p></blockquote><p>与上一题一样，只不过这次要求每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p><p><strong>示例：</strong><br>输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]<br>输出：7, nums &#x3D; [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">//待覆盖的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">//一直移动的指针，相同就一直移动</span><br>        <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">2</span>] != nums[j])&#123;<br>                <span class="hljs-comment">//这里的意思是直接保留前两个数，比较第三个数和第一个数是否相等，如果相等说明前3个元素都相等（数组有序），就移动j,抛弃这个元素，如果不相等，就将它覆盖到i所在的位置</span><br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>            j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//覆盖过之后就i++了，所以i指向的是新数组的后一个元素，即i的大小是数组长度</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h1 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a>删除排序链表中的重复元素II</h1><blockquote><p>82 难度 mid</p></blockquote><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例1：</strong></p><p>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 去重后为 1-&gt;2-&gt;5</p><p>输入：head &#x3D; [1,2,3,3,4,4,5]<br>输出：[1,2,5]</p><p><code>迭代，一次遍历</code></p><p>因为头结点也可能被删除，所以需要使用虚拟头结点来跟踪最终的头结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        dummyNode.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummyNode;<br>        <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == cur.next.next.val)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur.next.val;<br>                <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.val == x)&#123;<br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p><a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p><blockquote><p>27  难度 easy</p></blockquote><p>给定一个无序数组，需要原地移除所有数值等于<code>val</code>的元素，并返回移除后数组的新长度。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1：</strong><br>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] != val)&#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法和上面的方法基本上一样，都是<strong>将需要的元素放在数组的前面位置</strong>，即将不等于val的元素覆盖到前面，如果等于val，就跳过这个元素，搜索后面不等于val的元素，覆盖到上面。</p><p>i 指向需要被覆盖的元素的位置，j 来遍历数组元素</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>官方还有一个优化版，利用首尾指针，目的是当出现只有数组首元素等于val的时候，上述方法所有元素都要往前移动，复杂度高，所以可以利用首尾指针，直接将尾指针的元素覆盖到首指针就结束了。</p><p><strong>？</strong>但是我有一个疑问，<code>待解决</code>。<code>如果数组元素全都是val 那不是还得全部赋值到 i 的位置？这和首元素是val 全部覆盖耗费的时间一样呀？不懂哪里优化了</code></p><hr><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><blockquote><p>15 难度：mid</p></blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong><br>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p><p><strong>示例 2：</strong><br>输入：nums &#x3D; [1]<br>输出：[]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">//if(n == 0) return list;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n - <span class="hljs-number">2</span>; k++)&#123;<br>            <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums[k];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>                <span class="hljs-keyword">if</span>(i != k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] + nums[j] + target &gt; <span class="hljs-number">0</span>)&#123;<br>                    j--;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i == j)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] + target == <span class="hljs-number">0</span>)&#123;<br>                    List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    arr.add(nums[k]);<br>                    arr.add(nums[i]);<br>                    arr.add(nums[j]);<br>                    list.add(arr);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据最接近的三数之和，又写了一个代码，我比较喜欢这个，但是这个比上面那个花费时间多2ms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n - <span class="hljs-number">2</span>; k++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[k] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[k] + nums[i] + nums[j];<br>                <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j])&#123;<br>                        j--;<br>                    &#125;<br>                    j--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i + <span class="hljs-number">1</span>] == nums[i])&#123;<br>                        i++;<br>                    &#125;<br>                    i++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    arr.add(nums[k]);<br>                    arr.add(nums[i]);<br>                    arr.add(nums[j]);<br>                    list.add(arr);<br>                    <span class="hljs-comment">//因为找到一组，所以需要同时移动i，j</span><br>                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i + <span class="hljs-number">1</span>] == nums[i])&#123;<span class="hljs-comment">//去重</span><br>                        i++;<br>                    &#125;<br>                    i++;<br>                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j])&#123;<br>                        j--;<br>                    &#125;<br>                    j--;<br>                    <span class="hljs-comment">//上面这段其实等价于</span><br>                    <span class="hljs-comment">//while(i &lt; j &amp;&amp; nums[j] == nums[--j])</span><br>                    <span class="hljs-comment">//--j是先进行j = j-1 ，然后再进行运算</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要先确保数组有序，原因是如果无序，则会遍历出重复的一组和为0的数。然后第一层for循环是遍历数组中所有<strong>不重复</strong>的元素，以它为新数组的首元素，来构造不同的和为零的数组。如果遇到重复的元素，就直接跳过，因为上一步已经遍历过了。然后是数组的第二个元素，指针从上层的后面开始，往右移动，第三个元素从末尾开始，往左移动。<strong>当有a+b+c&#x3D;0后，随着b的增加，要想a+b’+c‘&#x3D;0，那么一定有 c’ &lt; c。</strong>所以c是从数组末尾向左移动。移动移动后…当b与c相等时，在以首元素开头的循环中不会再有和为零的元素了，需要进入新的首元素循环啦</p><p><code>举个栗子</code>🌰</p><p><img src="/image/leetcode/array/0015/151.png"></p><p><img src="/image/leetcode/array/0015/152.png"></p><p>新数组的首元素即是-4，第二个元素从k+1开始，而第三个元素是从n-1开始，只有他们的和<strong>大于</strong>0时，说明 c 的值太大了，需要缩小，往左移动 j ，才有可能使和为0。而如果他们的和一开始就<strong>小于</strong>0，那肯定不会有更大的了，需要将 i 向右移动，然后再看是否有和大于等于0的一组数。</p><p><img src="/image/leetcode/array/0015/153.png"></p><p><img src="/image/leetcode/array/0015/154.png"></p><p><img src="/image/leetcode/array/0015/155.png"></p><p><img src="/image/leetcode/array/0015/156.png"></p><p><img src="/image/leetcode/array/0015/157.png"></p><p><img src="/image/leetcode/array/0015/158.png"></p><p><img src="/image/leetcode/array/0015/159.png"></p><p><img src="/image/leetcode/array/0015/1510.png"></p><hr><h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum-closest/">https://leetcode-cn.com/problems/3sum-closest/</a></p><blockquote><p>16  难度 mid</p></blockquote><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。假定每组输入只存在恰好一个解。</p><p><strong>示例 1：</strong></p><p>输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</p><p><strong>提示：</strong></p><p><code>3 &lt;= nums.length &lt;= 1000</code></p><p><code>-1000 &lt;= nums[i] &lt;= 1000</code></p><p><code>-104 &lt;= target &lt;= 104</code></p><p>暴力解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">threeSumClosest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">best</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>        <span class="hljs-comment">//当target等于负数的话，Integer.MAX_VALUE 减负数会越界，变成Integer.MIN_VALUE</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n - <span class="hljs-number">2</span>; k++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j] + nums[k];<br>                    <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                        <span class="hljs-keyword">return</span> sum;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(Math.abs(sum - target) &lt; Math.abs(best - target))&#123;<br>                        best = sum;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> best;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个方法**时间复杂度是O(n的三次方)**，太高了，可以用双指针来优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">threeSumClosest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">best</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>        <span class="hljs-comment">//当target等于负数的话，Integer.MAX_VALUE 减负数会越界，变成Integer.MIN_VALUE</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n - <span class="hljs-number">2</span>; k++)&#123;<br>            <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">knum</span> <span class="hljs-operator">=</span> nums[k];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j] + knum;<br>                <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                    <span class="hljs-keyword">return</span> sum;<br>                &#125;<br>                <span class="hljs-comment">//看谁最接近target</span><br>                <span class="hljs-keyword">if</span>(Math.abs(sum - target) &lt; Math.abs(best - target))&#123;<br>                    best = sum;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                    <span class="hljs-comment">//需要将j往左移动</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j0</span> <span class="hljs-operator">=</span> j - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span>(i &lt; j0 &amp;&amp; nums[j0] == nums[j])&#123;<br>                        j0--;<br>                    &#125;<br>                    j = j0;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//需要将i往右移动</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i0</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span>(i0 &lt; j &amp;&amp; nums[i0] == nums[i])&#123;<br>                        i0++;<br>                    &#125;<br>                    i = i0;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> best;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一看到最接近，肯定是用差的绝对值来比较，三数的和与target的差的绝对值越小（最小为0），越接近target。我们先固定一个数a，假设下标是i，对剩下两个数用双指针由两端开始进行枚举，范围是【i+1，n-1】，由于数组已经进行了升序排序，a+b+c&gt;&#x3D;target 则需要减小c，即向左移动c，反之，a+b+c &lt; target 则需要增加b，即向右移动b。</p><blockquote><p>每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 target 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。 —–LeetCode</p></blockquote><p>有两个可以<code>优化</code>的地方。</p><ol><li>sum&#x3D;&#x3D;target，直接返回即可</li><li>对于同一个移动的指针，如果移动的下一个数与移动前的数值相同，那么需要跳过，因为移动前的循环中其他变量都没变，相当于这个也没变，不用重复做了。</li></ol><ul><li>时间复杂度：O(n²)，for循环是O(n)，while循环也是O(n)</li><li>空间复杂度：O(log N)。排序</li></ul><hr><h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><p><a href="https://leetcode-cn.com/problems/4sum/">https://leetcode-cn.com/problems/4sum/</a></p><blockquote><p>18  难度 mid</p></blockquote><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li>0 &lt;&#x3D; a, b, c, d &lt; n</li><li>a、b、c 和 d 互不相同</li><li>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</li><li>你可以按 任意顺序 返回答案 。</li></ul><p><strong>示例 1：</strong></p><p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> list;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n - <span class="hljs-number">3</span>; k++)&#123;<br>            <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>             <span class="hljs-comment">// 如果这四数之和大于target, 往后算也必大于target</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)nums[k] + nums[k + <span class="hljs-number">1</span>] + nums[k + <span class="hljs-number">2</span>] + nums[k + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 下面这四数之和小于target, 则nums[i]小了</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)nums[k] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n -<span class="hljs-number">1</span>] &lt; target)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>; m &lt; n - <span class="hljs-number">2</span>; m++)&#123;<br>                <span class="hljs-keyword">if</span>(m != k + <span class="hljs-number">1</span> &amp;&amp; nums[m] == nums[m - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                 <span class="hljs-comment">// 如果这四数之和大于target, 往后算也必大于target</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)nums[k] + nums[m] + nums[m + <span class="hljs-number">1</span>] + nums[m + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 下面这四数之和小于target, 则nums[i]小了</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)nums[k] + nums[m] + nums[n - <span class="hljs-number">2</span>] + nums[n -<span class="hljs-number">1</span>] &lt; target)  <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j] + nums[k] + nums[m];<br>                    <span class="hljs-keyword">if</span>(sum - target &gt; <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum - target &lt; <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        list.add(Arrays.asList(nums[k],nums[m],nums[i],nums[j]));<br>                        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和三数之和一样的思路，只是多加了一层for循环，所以时间复杂度是O(n的三次方)</p><p>但是这个优化是我没想到的</p><p>&#x2F;&#x2F; 如果这四数之和大于target, 往后算也必大于target</p><p><code>if ((long)nums[k] + nums[k + 1] + nums[k + 2] + nums[k + 3] &gt; target) break;</code></p><p>&#x2F;&#x2F; 下面这四数之和小于target, 则nums[i]小了</p><p><code>if ((long)nums[k] + nums[n - 3] + nums[n - 2] + nums[n -1] &lt; target)  continue;</code></p><hr><h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><blockquote><p>88  难度 easy</p></blockquote><p>给你两个按 <code>非递减顺序</code> （就是在数组nums1中，前m个元素是递增的，在数组nums2中，元素是递增的）排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 <code>非递减顺序</code> 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p><strong>示例 1：</strong></p><p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p><p><strong>逆向双指针</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//i &gt;=0 是防止nums1=&#123;0&#125;的情况</span><br>            <span class="hljs-comment">//nums1=&#123;0&#125;的话就直接将nums2全部赋值到nums1上</span><br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums1[i] &gt; nums2[j])&#123;<br>                nums1[i + j + <span class="hljs-number">1</span>] = nums1[i];<br>                i--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nums1[i + j + <span class="hljs-number">1</span>] = nums2[j];<br>                j--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>nums2数组优先，如果nums2数组为空时，直接就不用合并了，结束循环，但是nums1为空（指的是m&#x3D;0）不一定</p><ul><li>时间复杂度：O(m + n)。指针移动单调递减，最多移动 m+n次。</li><li>空间复杂度：O(1)。</li></ul><hr><h1 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/">https://leetcode-cn.com/problems/implement-strstr/</a></p><blockquote><p>28  难度 easy</p></blockquote><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p><strong>示例 1：</strong></p><p>输入：haystack &#x3D; “hello”, needle &#x3D; “ll”<br>输出：2</p><p>要看needle是否存在于haystack中，就看haystack中有几个与needle长度相同的字符串，然后依次进行比较，只要一有不同的字符，就立刻开始下一次的比较，这样比较节约时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> haystack.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> needle.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m - n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(haystack.charAt(i + j) != needle.charAt(j))&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(1)</li></ul><p>还有一个KMP解法，后续学到了再看</p><hr><h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p><blockquote><p>83  难度 easy</p></blockquote><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例1：</strong></p><p>1-&gt;1-&gt;2-&gt;3-&gt;3      去重后变为  1-&gt;2-&gt;3</p><p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3]</p><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(next == <span class="hljs-literal">null</span>)&#123;<br>                cur.next = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.val != next.val)&#123;<br>                cur.next = next;<br>               cur = cur.next;<br>            &#125;<br>            next = next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)<em>O</em>(<em>n</em>)，其中 n<em>n</em> 是链表的长度。</li><li>空间复杂度：O(1)<em>O</em>(1)。</li></ul><p>没有用双指针的解法（官方用的这个解法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.val == cur.next.val)&#123;<br>                cur.next = cur.next.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>DateStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/leetcode/paixu/bigo.png"></p><p><strong>以下排序算法均按升序处理。</strong></p><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h1><p><strong>算法原理：</strong>依次比较两个数的大小，如果左边的数大于右边的数，就交换两者的位置，当第一轮交换结束后，最后一个数肯定是整个数组中最大的那个数，因此下一轮比较的时候这个数就不需要比较了。</p><p><strong>优化：</strong>按照上面的写有一个弊端，当数组初始状态就是部分或者完全升序，还是需要全部比较，这耗费很多时间，因此可以标记哪个位置以后是完全有序，就比较这个位置之前的位置就可以了。</p><p>冒泡排序是一个<strong>稳定的算法</strong>，是因为如果遇到相同的数，排序后不会改变相同的数它们彼此的相对位置。</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(n)</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-comment">//end表示将要排序的数的最后一个数的位置，end后面的不用排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; end &gt; <span class="hljs-number">0</span>; end--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i - <span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                    nums[i] = nums[i - <span class="hljs-number">1</span>];<br>                    nums[i - <span class="hljs-number">1</span>] = temp;<br>                    <span class="hljs-comment">//如果一直进不了这里面，说明i后面都是升序了，所以index后面都是升序</span><br>                    index = i;<br>                &#125;<br>            &#125;<br>            end = index;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>&#125;;<br>        BubbleSort.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            System.out.print(nums[i]+<span class="hljs-string">&quot;_&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h1><p><strong>算法原理：</strong>先将所有数进行比较，找出最大的那个数，然后让这个数与最后一个元素交换位置，这时最大的数就在最后面了，接着缩小范围再进行选择比较。</p><p>选择排序也是一个稳定的算法。</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; end &gt; <span class="hljs-number">0</span>; end--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//假设最大值是索引为0的数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>                <span class="hljs-comment">//这里的等号就是为了维护算法的稳定性</span><br>                <span class="hljs-keyword">if</span>(nums[max] &lt;= nums[i])&#123;<br>                    max = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[max];<br>            nums[max] = nums[end];<br>            nums[end] = temp;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>&#125;;<br>        SelectionSort.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            System.out.print(nums[i]+<span class="hljs-string">&quot;_&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3.堆排序"></a>3.堆排序</h1><p>堆排序可以认为是对选择排序的一种优化。</p><p>时间复杂度：O(nlogn)</p><p>空间复杂度：O(1)</p><p><img src="/image/leetcode/paixu/1.jpg" alt="堆排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> &#123;<br>    <span class="hljs-comment">//默认是大顶堆</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> heapSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        heapSize = nums.length;<br>        <span class="hljs-comment">//从第一个非叶子节点开始，到索引为0的节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (heapSize &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            siftDown(i);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(heapSize &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>            nums[<span class="hljs-number">0</span>] = nums[heapSize - <span class="hljs-number">1</span>];<br>            nums[heapSize - <span class="hljs-number">1</span>] = top;<span class="hljs-comment">//现在最大的数在末尾</span><br>            heapSize--;<br>            siftDown(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> nums[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> heapSize &gt;&gt; <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(index &lt; half)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftIndex</span> <span class="hljs-operator">=</span> (index &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftChild</span> <span class="hljs-operator">=</span> nums[leftIndex];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> leftIndex + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(rightIndex &lt; heapSize &amp;&amp; nums[rightIndex] &gt; leftChild)&#123;<br>                leftIndex = rightIndex;<br>                leftChild = nums[rightIndex];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(element &gt;= leftChild)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//因为index的左孩子和右孩子已经是一个最大堆了，所以leftChild就是堆的最大值，直接让最大值作为index的堆顶</span><br>            nums[index] = leftChild;<br>            <span class="hljs-comment">//由于不知道左孩子的子树的堆中有没有比nums[index]更大的，所以每次找到一个下沉的位置，如果它不是叶子结点，再进入循环看是否还有比它大的</span><br>            index = leftIndex;<br>        &#125;<br>        nums[index] = element;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">HeapSort</span> <span class="hljs-variable">heap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapSort</span>();<br>        heap.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            System.out.print(nums[i]+<span class="hljs-string">&quot;_&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4.插入排序"></a>4.插入排序</h1><p><strong>算法思想：</strong>数组的前一部分是有序的，后一部分是无序的，将后面的无序的元素依次插入到前面有序的部分，并保证插入后前一部分仍然是有序的。</p><p>假设这个数组是[<code>44,51,61,82,94,96</code>,52,54,71,17,32,60,5]</p><p>第一种做法：将52与有序数组依次进行比较，52&lt;96，交换，52&lt;94，交换，…..这样的话假如数组的有序部分都大于52，需要将52交换很多次，最后换到第一个位置，这样效率很低。</p><p>第二种做法：我们将【交换】改为【挪动】，首先倒着来，依次比较52和她们的大小关系，然后找出那个小于52的索引前面的索引，就是52要插入的位置，然后将这个位置到52位置的所有元素向右挪动一个位置，然后直接将52赋值到这个索引处。如果有序数组是倒序，也需要比较很多次才能找到这个索引。</p><p><strong>第三种做法：</strong>利用二分查找的原理，二分地找出第一个大于52的数的索引，然后将它们挪动，再将52赋值到这个索引处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> search(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt; index; j--) &#123;<br>                nums[j] = nums[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            nums[index] = element;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找v在有序数组中待插入的位置，找到第一个比v大的元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-comment">//[begin,end)</span><br>        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (begin + end) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[index] &lt; nums[mid])&#123;<br>                end = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                begin = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> begin;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">InsertSort</span> <span class="hljs-variable">insertSort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertSort</span>();<br>        insertSort.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            System.out.print(nums[i]+<span class="hljs-string">&quot;_&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h1><p><strong>算法思想</strong>：将一个大数组分为两个小数组，在递归地将这两个小数组分为4个小数组，一直递归，终止条件是每个数组都只有一个元素，每个数组一定是一个有序数组，因为只有一个元素肯定是有序的啦，然后两两合并，合并完的仍然是有序数组才可以，最终合并成一个有序数组。</p><p>时间复杂度：O(nlogn)</p><p>空间复杂度：O(n)</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] leftArray;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        leftArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length &gt;&gt; <span class="hljs-number">1</span>];<br>        sort(<span class="hljs-number">0</span>,nums.length);<br>    &#125;<br><br>    <span class="hljs-comment">//[begin,end)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(end - begin &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (begin + end) &gt;&gt; <span class="hljs-number">1</span>;<br>        sort(begin,mid);<br>        sort(mid,end);<br>        merge(begin,mid,end);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> begin;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mid;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mid - begin; i++) &#123;<br>            leftArray[i] = nums[begin + i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果左边先结束，就不用再挪动元素了</span><br>        <span class="hljs-comment">//如果右边先结束，需要将左边的全部挪动到右边</span><br>        <span class="hljs-keyword">while</span> (left &lt; mid - begin)&#123;<span class="hljs-comment">//左边不越界</span><br>            <span class="hljs-keyword">if</span>(right &gt;= end || leftArray[left] &lt;= nums[right])&#123;<br>                nums[point++] = leftArray[left++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nums[point++] = nums[right++];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">MergeSort</span> <span class="hljs-variable">mergeSort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MergeSort</span>();<br>        mergeSort.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            System.out.print(nums[i]+<span class="hljs-string">&quot;_&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h1><p><strong>算法思想</strong>：先选择一个轴点元素，比轴点元素大的元素放在轴点元素的右边，比轴点元素小的元素放在它的左边，然后再将轴点元素两遍的序列递归进行这个步骤，逐渐将每个元素都变成轴点元素。所以<code>递归终止条件就是每个元素都变成了轴点元素</code>。这样所有元素都是有序了。</p><p>时间复杂度：最好 O(nlogn)，最坏O(n²)</p><p>空间复杂度：O(n)</p><p>当轴点元素将数组均分或者差不多均分的时候时间复杂度最低，最差的情况是轴点元素一边没有元素，一边是所有元素。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        sort(<span class="hljs-number">0</span>,nums.length);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(end - begin &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pointIndex</span> <span class="hljs-operator">=</span> point(begin,end);<br>        sort(begin,pointIndex);<br>        sort(pointIndex,end);<br>    &#125;<br><br>    <span class="hljs-comment">//确定轴点元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">point</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-comment">//随机选择轴点元素，并将它放到begin位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> begin + (<span class="hljs-type">int</span>) (Math.random() * (end - begin));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[begin];<br>        nums[begin] = nums[index];<br>        nums[index] = first;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> nums[begin];<br>        end--;<br><br>        <span class="hljs-keyword">while</span> (begin &lt; end)&#123;<br>            <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>                <span class="hljs-keyword">if</span>(nums[end] &gt; element)&#123;<br>                    end--;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//覆盖轴点元素，这个循环结束，开始从左往右遍历</span><br>                    nums[begin++] = nums[end];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>                <span class="hljs-keyword">if</span>(nums[begin] &lt; element)&#123;<br>                    begin++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//覆盖轴点元素，这个循环结束，开始从右往左遍历</span><br>                    nums[end--] = nums[begin];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        nums[begin] = element;<br>        <span class="hljs-keyword">return</span> begin;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">FastSort</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastSort</span>();<br>        s.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            System.out.print(nums[i]+<span class="hljs-string">&quot;_&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个很巧妙的设计，因为当每次覆盖操作之后，都需要进行反方向的遍历，轮流进行，当遍历的元素不满足与轴点元素的大小关系时，就还是这个方向进行遍历。这里使用了两个while循环，只要一覆盖，就break，换方向，否则不换。</p><p>一些转换公式</p><p><img src="/image/leetcode/paixu/gongshi.png"></p>]]></content>
    
    
    <categories>
      
      <category>DateStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>数据结构</tag>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/%E5%89%91%E6%8C%87offer/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/LeetCoode/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><hr><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p><strong>思路：</strong></p><ol><li>暴力双层for循环，时间复杂度是O(n²)</li><li>原地交换值。题目中说<strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong>，所以数组的值和索引是<code>零对一</code>，<code>一对一</code>，<code>多对一</code>三种情况，我们要的就是多对一对应的值（即有重复的元素了）。如何让数组元素与所以一一对应（nums[i] &#x3D; i）呢？排序？空间复杂度O(logn)，原地交换的话空间复杂度是O(1)，时间复杂度是O(n)，因此采用原地交换的方式。<ul><li>nums[i] &#x3D; i，跳过，往后遍历</li><li>nums[i] &#x3D; a，nums[a] &#x3D; b，如果a !&#x3D; b，就交换两数的值，结果为nums[a] &#x3D; a，这样索引就与值对应了</li><li>如果nums[i] &#x3D;&#x3D; nums[nums[i]]，说明<code>i</code>位置处和<code>nums[i]</code>数组元素的值相等，找到。</li></ul></li></ol><p>一一对应之后，如果还有和该处索引相等的数组元素值，说明有重复的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; len)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == i)&#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[nums[i]] != nums[i])&#123;<br>                swap(nums,i,nums[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><p><strong>限制：</strong></p><p>0 &lt;&#x3D; n &lt;&#x3D; 1000<br>0 &lt;&#x3D; m &lt;&#x3D; 1000</p><p><strong>思路：</strong></p><p>由题意知道，每行每列都是有序的，因此我想到可以从第一行的最后一列开始遍历看是否有这个元素。</p><p><strong>初始代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<span class="hljs-comment">//行</span><br>         <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<span class="hljs-comment">//列</span><br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][i] &gt; target)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[k][i] == target)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度是O(m*n)</p><p><strong>优化</strong>：还是从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 <code>true</code>。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<span class="hljs-comment">//行</span><br>         <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<span class="hljs-comment">//列</span><br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(row &lt; n &amp;&amp; col &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> matrix[row][col];<br>            <span class="hljs-keyword">if</span>(cur == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &gt; target)&#123;<br>                col--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                row++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。<br><strong>空间复杂度：</strong>O(1)。</p><hr><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p><p><strong>思路</strong>：要将空格替换成“%20”，需要将字符串一个字符一个字符的看，所以与字符有关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">//List&lt;Character&gt; array = new ArrayList&lt;&gt;();</span><br>        <span class="hljs-type">char</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[len * <span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                array[size++] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                array[size++] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                array[size++] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                array[size++] = c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array,<span class="hljs-number">0</span>,size);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>String str &#x3D; new String(array,0,size);</p><p>String(char[] value, int offset, int count)      分配一个新的  String，它包含取自字符数组参数一个子数组的字符。</p></blockquote><p>K神写的一个方法，直接将字符存到StringBuffer对象中，代码更加简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span>(Character c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                str.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                str.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>public char[] toCharArray(): 把字符串转换为字符数组。</p></blockquote><hr><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p><p><strong>示例 2：</strong></p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p><strong>思路：按层模拟</strong>，每次都是以<code>从左往右</code>、<code>从上往下</code>、<code>从右往左</code>、<code>从下往上</code>的顺序来遍历的，只需要判断边界是否越界。设未遍历矩阵的顶为t（top），底为b（bottom）、左为l（left）、右为r（right）</p><p>从左往右，l -&gt; r，矩阵上方减少一层，t++</p><p>从上到下，t -&gt; b，矩阵右方减少一列，r–</p><p>从右向左，r -&gt; l，矩阵下方减少一层，b–</p><p>从下到上，b -&gt; t，矩阵左方减少一层，l++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">columns</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rows*columns];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> columns - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span>  rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++)&#123;<br>                res[size++] = matrix[t][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t; i &lt;= b; i++)&#123;<br>                res[size++] = matrix[i][r];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l &gt; --r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r; i &gt;= l; i--)&#123;<br>                res[size++] = matrix[b][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(t &gt; --b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b; i &gt;= t; i--)&#123;<br>                res[size++] = matrix[i][l];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(m*n)，矩阵m行n列，需要把矩阵遍历完</p><p>空间复杂度：O(1)，不考虑返回时创建的res</p><hr><h2 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例 1:</strong></p><p>输入：s &#x3D; “abaccdeff”<br>输出：’b’</p><p><strong>示例 2:</strong></p><p>输入：s &#x3D; “”<br>输出：’ ‘</p><p><strong>思路：</strong></p><p>1.一般计数就想起来哈希表，因此利用哈希表存放字符以及它出现的次数。</p><p>2.由于一个字符出现多于一次就不符合要求了，因此 Map 结构的 Value 使用 Boolean 类型是一个更好的选择，而且布尔类型比较节约空间。</p><p>3.只要得到第一次出现一次的字符，因此可以采用LinkedHashMap(有序)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character,Boolean&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(!map.containsKey(c))&#123;<br>                map.put(c,<span class="hljs-literal">true</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                map.put(c,<span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(c))&#123;<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用<code>数组</code>，巧妙利用数组下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : chars)&#123;<br>            cc[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : chars)&#123;<br>            <span class="hljs-keyword">if</span>(cc[c-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度 O(N) ：</strong> N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1)；<br><strong>空间复杂度 O(1) ：</strong> 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，存储需占用 O(26) &#x3D; O(1)O(26)&#x3D;O(1) 的额外空间。</p><hr><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>思路</strong>：一个栈用于add，一个栈用于delete，队列是先进先出，所以首先出去的是队首，可以利用一个栈弹出元素，然后添加到另一个栈中，在这个栈中栈顶就是队首元素了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    <br>    Deque&lt;Integer&gt; stack1;<br>    Deque&lt;Integer&gt; stack2;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//jdk官方推荐的java栈实现，用Stack实现的话执行用时很长</span><br>        stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        stack1.push(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(!stack2.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> stack2.pop();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;<br>                stack2.push(stack1.pop());<br>            &#125;<br>            <span class="hljs-keyword">return</span> stack2.isEmpty() ? -<span class="hljs-number">1</span> : stack2.pop();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><hr><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><p>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p><p><strong>思路：</strong>由于如果想获取最小值，需要将栈中元素依次遍历，并且还需要将它们都弹出，不仅时间复杂度是O(n)，还影响了栈的状态，因为只是想看一下栈的最小元素是哪个。所以利用辅助栈，即定义两个栈，一个栈用于正常栈操作，另一个栈用于存放它遇到的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><br>    Stack&lt;Integer&gt; stack1;<br>    Stack&lt;Integer&gt; stack2;<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stack1.push(x);<br>        <span class="hljs-keyword">if</span>(stack2.isEmpty() || x &lt;= stack2.peek())&#123;<br>            stack2.push(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(!stack1.isEmpty() &amp;&amp; (stack1.pop()).equals(stack2.peek()))&#123;<br>            stack2.pop();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack1.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack2.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><hr><h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假<code>设压入栈的所有数字均不相等</code>。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]<br><strong>输出：</strong>true<br><strong>解释：</strong>我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]<br><strong>输出：</strong>false<br><strong>解释：</strong>1 不能在 2 之前弹出。</p><p><strong>思路</strong>：采用模拟入栈的方式，借用一个辅助栈 stack ，<strong>模拟</strong> 压入 &#x2F; 弹出操作的排列。根据是否模拟成功，即可得到结果。即将数组元素入栈，每次都看栈顶元素是否与popped数组元素相等，如果相等说明这个元素现在需要出栈，就将其出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br>        <span class="hljs-comment">/*if(pushed.length != popped.length)&#123;</span><br><span class="hljs-comment">            return false;</span><br><span class="hljs-comment">        &#125;*/</span><br>        <span class="hljs-comment">//不知道为什么，这一句比Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();快多了</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : pushed)&#123;<br>            stack.push(num);<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[j])&#123;<br>                stack.pop();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最好使用 LinkedList 实现链表、队列等数据结构</p></blockquote><hr><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><p>输入：arr &#x3D; [3,2,1], k &#x3D; 2<br>输出：[1,2] 或者 [2,1]</p><p><strong>示例 2：</strong></p><p>输入：arr &#x3D; [0,1,2,1], k &#x3D; 1<br>输出：[0]</p><p><strong>思路:</strong></p><blockquote><p><strong>大根堆</strong>: 想象成二叉树的形状，在每个由三个节点组成的二叉树中，根节点比左右节点都大。</p><p>最后一个非叶子节点的下标是k*2-1（k是节点总数，也就是数组长度）。数组元素顺序是按照二叉树的层序遍历排列的。</p></blockquote><p>可以利用大根堆，每次遍历都将小于堆顶的数放进去，最后这个堆中就是数组中最小的数了。不能用小根堆，如果用小根堆（堆顶是最小值），当遍历的这个数比堆顶大的时候，不确定这个数是不是较小的，只能说是比最小值大的数。</p><p>java中的优先队列默认是小根堆，使用lamda表达式可以变成大根堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(arr.length &lt; k || k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((v1,v2) -&gt; v2 - v1);<span class="hljs-comment">//大根堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : arr)&#123;<br>            pq.add(num);<br>            <span class="hljs-keyword">if</span>(pq.size() &gt; k)&#123;<br>                pq.poll();<span class="hljs-comment">//移除队首元素</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : pq)&#123;<span class="hljs-comment">//堆的存储方式是数组，一般看成完全二叉树</span><br>            res[i] = num;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>未完待续…..end….</p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><hr><h2 id="和为s的两个数"><a href="#和为s的两个数" class="headerlink" title="和为s的两个数"></a>和为s的两个数</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[2,7] 或者 [7,2]</p><p><strong>思路</strong>：设置双向指针(<code>对撞双指针</code>)，一个从左往右，同时另一个从右往左，逼近target</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; len &amp;&amp; j &gt; i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j];<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i],nums[j]&#125;;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><p>输入：target &#x3D; 9<br>输出：[[2,3,4],[4,5]]</p><p><strong>示例 2：</strong></p><p>输入：target &#x3D; 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p><strong>思路:</strong> <code> 滑动窗口</code>。一般遇到求连续序列的和的时候，可以往这方面想，因为滑动窗口就是要保持一个固定的target窗口大小，在数组的元素中滑动。窗口的值大于target窗口，就缩小窗口大小，小了就增大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">if</span>(s == target)&#123;<br>                <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[j - i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++)&#123;<br>                    arr[k - i] = k;<br>                &#125;<br>                list.add(arr);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s &gt;= target)&#123;<br>                s -= i;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j++;<br>                s += j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>return list.toArray(new int[list.size()] [ ]);</p><p>也可以写成return list.toArray(new int[0] [ ]);  原因：</p><blockquote><p><strong>1、数组空间等于0时，将会动态的创建和集合size相同空间大小的数组，性能是最好的。</strong><br>2、数组空间大于0但是小于size时，会重新创建大小等于集合size的数组，此时会增加GC的负担。<br>3、数组空间等于集合的size时，在普通情况下是没问题的，但是在高并发情况下，数组创建完成后，集合的size变大，此时影响跟第二条相同。<br>4、数组空间大于集合的size时，一方面会造成空间浪费，另一方面会在使用数组时产生空指针的异常。因为多出来的空间会<strong>存入null</strong></p><p><strong>———–参考</strong>：<a href="https://juejin.cn/post/6844904145753735176">https://juejin.cn/post/6844904145753735176</a></p></blockquote><hr><h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>注意：</strong>题目中提供的字符串s可能只有空格。</p><p><strong>示例 1：</strong></p><p>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p><strong>示例 2：</strong></p><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p><strong>示例 3：</strong></p><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p><strong>思路：</strong>先将首尾的空格字符去掉，然后在这个范围里再遍历（倒着遍历就可以得到顺序相反的字符串了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-keyword">if</span>(chars.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> chars.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(chars[left] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            left++;<br>            <span class="hljs-keyword">if</span>(left &gt;= chars.length)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(chars[right] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            right--;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">while</span>(i &gt;= left)&#123;<br>            <span class="hljs-keyword">while</span>(i &gt;= left &amp;&amp; chars[i] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; k &lt;= right; k++)&#123;<br>                sb.append(chars[k]);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i &gt;= left &amp;&amp; chars[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i != left - <span class="hljs-number">1</span>)&#123;<br>                sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            <br>            right = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>字符串转换成字符数组</code>后，再进行操作的执行时间比直接用s.charAt()快</p><p>也可以用双端队列，顺序遍历，将每个单词头插到队列中</p><p>或者api选手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim(); <span class="hljs-comment">// 删除首尾空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>, i = j;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 搜索首个空格</span><br>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 添加单词</span><br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 跳过单词间空格</span><br>            j = i; <span class="hljs-comment">// j 指向下个单词的尾字符</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串并返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p><strong>示例 1：</strong></p><p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”</p><p><strong>示例 2：</strong></p><p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &lt; s.length(); i++)&#123;<br>            sb.append(chars[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sb.append(chars[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><p>输入：head &#x3D; [1,3,2]<br>输出：[2,3,1]</p><p><strong>思路</strong>：</p><p><strong>方法一：</strong>利用栈的<code>后进先出</code>特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        <span class="hljs-comment">//栈最好用这个实现，java不推荐用Stack实现</span><br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-literal">null</span>)&#123;<br>            stack.push(node.val);<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-type">int</span>[] n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[stack.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            n[i] = stack.pop();<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong>递归回溯。因为回溯相当与倒序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        huisu(head);<br>        <span class="hljs-type">int</span>[] n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++)&#123;<br>            n[i] = array.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">huisu</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        huisu(head.next);<br>        array.add(head.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在O-1-时间内删除链表节点"><a href="#在O-1-时间内删除链表节点" class="headerlink" title="在O(1)时间内删除链表节点"></a>在O(1)时间内删除链表节点</h2><p>给定单向链表的头指针和一个节点指针，定义一个函数在O（1）时间内删除该节点。</p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>示例 1:</strong></p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li></ul><p><strong>思路</strong>：不能挨个遍历，不然时间复杂度是O(N)。</p><p>两种情况：</p><p>**1.**删除的节点不是尾结点，直接采取要删除节点后面的结点的值覆盖要删除节点的值，然后实际删除的是后继结点的后继结点，时间复杂度为O(N)</p><p>**2.**要删除的结点是尾结点，它没有后继结点，因此需要挨个遍历了，时间复杂度是O(N)</p><p>平均时间复杂度：进行N次，需要操作结点N-1+N&#x3D;2N-1次，所以平均时间复杂复杂度为O(2N-1&#x2F;N)&#x3D;O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, ListNode tobeDelete)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || tobeDelete == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (tobeDelete.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 要删除的节点不是尾节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> tobeDelete.next;<br>        tobeDelete.val = next.val;<br>        tobeDelete.next = next.next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == tobeDelete)<br>             <span class="hljs-comment">// 只有一个节点</span><br>            head = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">while</span> (cur.next != tobeDelete)<br>                cur = cur.next;<br>            cur.next = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a>删除排序链表中的重复元素II</h2><p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回已排序的链表</p><p><strong>示例1：</strong></p><p>输入：head &#x3D; [1,2,3,3,4,4,5]<br>输出：[1,2,5]</p><p><strong>示例2：</strong></p><p>输入：head &#x3D; [1,1,1,2,3]<br>输出：[2,3]</p><p><strong>思路：</strong>因为头结点也可能被删除，所以设置一个虚拟头结点，可以动态地指向链表的最终的头结点。需要用变量保存重复的值，然后依次遍历，删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummyNode;<br>        <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next!= <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == cur.next.next.val)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur.next.val;<br>                <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.val == x)&#123;<br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要说明的一点是 ListNode cur &#x3D; dummyNode; 因此现在cur就是dummyNode，cur找第一个没重复的元素就是在改变dummy的next指针，后面跳走了，dummy就没变了，只是dummy-&gt;next-&gt;next在变</p><p><strong>递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>        <span class="hljs-keyword">if</span>(cur.val == next.val)&#123;<br>            <span class="hljs-comment">//头结点需要删除</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> next.val;<br>            <span class="hljs-keyword">while</span>(next != <span class="hljs-literal">null</span> &amp;&amp; next.val == x)&#123;<br>                next = next.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> deleteDuplicates(next);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//不删除头结点</span><br>            cur.next = deleteDuplicates(next);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</p><p>返回链表 4-&gt;5.</p><p><strong>思路：</strong></p><p><strong>方法一：</strong>利用栈的后进先出特性，倒序弹出倒数第K个节点</p><p><strong>方法二：</strong>由于方法一需要创建一个栈，导致空间复杂度不为O(1)。所以考虑使用双指针，让一个指针先走k步，即剩下n-k个结点没有走，n是链表的总节点数，然后让两个指针同时移动，当快指针为null时，说明已经走了n-k步，此时慢指针就是倒数第k个节点所在的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            node2 = node2.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(node2 != <span class="hljs-literal">null</span>)&#123;<br>            node1 = node1.next;<br>            node2 = node2.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h2><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。</p><p><strong>思路：</strong></p><p>方法一：双指针法。</p><p>设置两个指针，fast一次走两步，slow一次走一步，设环有b个节点，链表一共a+b个节点。因为每次fast指针都比slow指针多走一步，所以如果有环的话，两指针一定会相遇。即fast一定会追上slow。设两个指针分别移动了f  s步，则f&#x3D;2s（每次fast走2步，slow走一步），两者相遇，fast比slow多走n圈，即f&#x3D;s+nb。因此f&#x3D;2nb，s&#x3D;nb。</p><p><strong>如果让指针从链表头部一直向前走并统计步数 k ，那么所有 走到链表入口节点时的步数 是：k &#x3D; a + nb（先走 a 步到入口节点，之后每绕 11 圈环（ b 步）都会再次到入口节点）。</strong></p><p>所以让s再走a步，就可以到达环入口结点，如何指示这个a的值？利用节点从head开始移动到环入口正好是a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        fast = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><p><strong>方法二:</strong> 哈希表</p><p>有环没环其实就是看是否遍历到重复的节点，因此可以利用Set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!set.contains(cur))&#123;<br>                set.add(cur);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> cur;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)。没环，链表的所有节点都要放到哈希表中</li></ul><hr><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p><p><strong>示例1：</strong></p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p><p><strong>思路：</strong></p><p>1.迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)</p><p>2.递归</p><p>把后面的看做整体，假设已经被翻转，因此现在只需要将头节点翻转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//递归终止条件</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归相当于调用栈，因此空间复杂度为O(n)</p><hr><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p><strong>限制：</strong></p><p>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</p><p><strong>思路：</strong>设置一个虚拟头结点，将两个链表的节点经过比较大小后重新链入一个新的链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummyNode;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>)&#123;<br>            cur.next = l1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur.next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。你需要重新创建节点，复制一个全新的链表，和原链表完全一样！！</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><p>输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><p><strong>思路：</strong></p><p><strong>方法一：</strong>利用哈希表，旧链表的每个节点为key,新链表的每个节点为value。通过两次遍历，第一次创建节点并将节点存放到哈希表中，第二次遍历设置新节点的next和random。</p><p>为什么要遍历两次呢？因为第一次需要先将有哪些节点创建出来。</p><p><img src="https://pic.leetcode-cn.com/1604747285-ELUgCd-Picture1.png" alt="Picture1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node next;</span><br><span class="hljs-comment">    Node random;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">        this.next = null;</span><br><span class="hljs-comment">        this.random = null;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Map&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            map.put(cur,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val));<br>            cur = cur.next;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            map.get(cur).next = map.get(cur.next);<br>            map.get(cur).random = map.get(cur.random);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map.get(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>思路：</strong></p><p>1.哈希表。哈希表先存一个链表的所有节点，在顺序遍历另一个链表，如果节点在哈希表中有，那就是交点。缺点是时间复杂度和空间复杂度都是O(N)。</p><p>2.双指针。</p><ul><li><p>链表有公共节点（相交）</p><p>设公共节点有c个，对于A链表，第一个公共节点前有a个节点，对于B链表，第一个公共节点前共有b个节点，设两指针headA从A链表头开始遍历 和headB从B链表头开始遍历 </p><p>如果a&#x3D;b，那么两节点同时到达交点</p><p>如果a!&#x3D;b，那么肯定有一个指针先遍历到链表尾部，此时使该指针遍历另一个链表。最终两指针一定会相交。因为headA指针走了a+c+b个节点，headB指针走了b+c+a个节点</p></li><li><p>链表没有公共节点（不相交）</p><p>如果a&#x3D;b，同时到达链表尾部</p><p>如果a!&#x3D;b，A指针走a+c+b  B指针走b+c+a，同时到达null尾结点</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-keyword">while</span>(A != B)&#123;<br>            A = A == <span class="hljs-literal">null</span> ? headB : A.next;<br>            B = B == <span class="hljs-literal">null</span> ? headA : B.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(N)，空间复杂度：O(1)</p><hr><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><hr><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p>​       4                     </p><p>​     &#x2F;    <br>   2       7<br>  &#x2F; \      &#x2F; \<br>1   3   6   9<br>镜像输出：</p><p>​       4</p><p>​     &#x2F;    <br>   7       2<br>  &#x2F; \      &#x2F; \<br>9   6   3   1</p><p><strong>思路：</strong></p><p><strong>方法一：</strong>借助栈将每层的子树根节点的左右孩子都交换。就是在层序遍历中多加一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.addLast(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.removeLast();<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                stack.addLast(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                stack.addLast(node.right);<br>            &#125;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.left;<br>            node.left = node.right;<br>            node.right = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(N)</p><p>空间复杂度O(N)。最差情况下，栈 stack 最多同时存储（N + 1）&#x2F;2个节点，占用 O(N) 额外空间。</p><p><img src="https://pic.leetcode-cn.com/1614450330-bTAcyj-Picture0.png" alt="Picture0.png"></p><blockquote><p>——引用力扣K神题解</p></blockquote><p><strong>2.递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> mirrorTree(root.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mirrorTree(root.right);<br>        root.left = right;<br>        root.right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>不要试着去理解递归内部的逻辑意义，相信它可以做到。直接用</code></p><p>空间复杂度O(N) 。使用的空间由递归栈的<strong>深度</strong>决定，它<strong>等于当前节点在二叉树中的高度</strong>。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</p><hr><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><p>​  3</p><p>​&#x2F;  \</p><p>   4   5<br>   &#x2F;     <br> 1        2<br>给定的树 B：</p><p>   4<br>  &#x2F;<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>思路：</strong></p><p>如果两个树中其中一个为空，就不能有子结构。因为我们默认空树不能有子结构。</p><p>现在我们就是要找在A树中有和B树根节点相同的节点，然后在A树中以这个节点为根节点的子树是否与B树结构和值相同，如果不相同，就找另一个与B根节点值相同的节点，继续判断。</p><blockquote><p>1.先在A树中找到与B树根节点值相同的节点P<br>2、以P节点作为根节点，与B树做比较<br>        B树有的子节点，A树必须有<br>        B树没有的子节点，A树可以有</p><p>——引用B站UP主子烁爱学习</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A.val == B.val &amp;&amp; isContains(A,B)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> isSubStructure(A.left,B) || isSubStructure(A.right,B);<br>    &#125;<br>    <span class="hljs-comment">//这个函数的作用就是判断以node1为根节点的树与以node2为根节点的树是否完全相同</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContains</span><span class="hljs-params">(TreeNode node1,TreeNode node2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span> &amp;&amp; node2 != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(node2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> node1.val == node2.val &amp;&amp; isContains(node1.left,node2.left) &amp;&amp; isContains(node1.right,node2.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的</p><p><strong>思路：</strong>采用递归，整体的看左节点和右节点是否具有相同的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> recur(root.left,root.right);<span class="hljs-comment">//看左子树和右子树是否是镜像对称的</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode left,TreeNode right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span> || left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//看左子树的以左结点为根的子树与右子树以右节点为根的子树是否是对称的</span><br>        <span class="hljs-comment">//看左子树的以右结点为根的子树与右子树以左节点为根的子树是否是对称的</span><br>        <span class="hljs-keyword">return</span> recur(left.left,right.right) &amp;&amp; recur(left.right,right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(N) 。需要判断N&#x2F;2个节点对是否对称</p><p>空间复杂度：O(N)。使用的空间由递归栈的<strong>深度</strong>决定，它<strong>等于当前节点在二叉树中的高度</strong>。在平均情况下，二叉树的高度与节点个数为对数关系，空间复杂度为 O(logN)。当二叉树退化成链表时，高度是(N+1)&#x2F;2，空间复杂度是O(N)</p><hr><h2 id="从上到下打印二叉树II"><a href="#从上到下打印二叉树II" class="headerlink" title="从上到下打印二叉树II"></a>从上到下打印二叉树II</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行</p><p><strong>思路：</strong></p><p>利用队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;<br>         LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.addLast(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>                arr.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    queue.addLast(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    queue.addLast(node.right);<br>                &#125;<br>            &#125;<br>            list.add(arr);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="从上到下打印二叉树III"><a href="#从上到下打印二叉树III" class="headerlink" title="从上到下打印二叉树III"></a>从上到下打印二叉树III</h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><strong>思路：</strong></p><p>双端队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;<br>        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.addLast(root);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//true 从左往右打印，false 从右往左打印</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                TreeNode node;<br>                <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-comment">//本层是从左往右打印</span><br>                    node = queue.removeFirst();<br>                    arr.add(node.val);<br>                    <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                        queue.addLast(node.left);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                        queue.addLast(node.right);<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//本层是从右往左打印</span><br>                    node = queue.removeLast();<br>                    arr.add(node.val);<br>                    <span class="hljs-comment">//因为下一层从左往右打印，因此需要先放右孩子节点，再放左孩子节点，然后从队列头取节点的顺序才正确；</span><br>                    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                        queue.addFirst(node.right);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                        queue.addFirst(node.left);<br>                    &#125;<br>                &#125;<br>                <br>            &#125;<br>            flag = flag ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>            list.add(arr);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)  N为二叉树的节点个数，循环</p><p>空间复杂度 O(N)  当二叉树为满二叉树时，队列中最多存放（N+1）&#x2F;2个节点，即最下面一层的节点数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) tmp.addLast(node.val); <span class="hljs-comment">// 偶数层 </span><br>                <span class="hljs-keyword">else</span> tmp.addFirst(node.val); <span class="hljs-comment">// 奇数层 </span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<span class="hljs-comment">//List的主要实现包括LinkedList及ArrayList。因此可以直接添加</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>K神这个题解直接利用res来判断层数是奇数还是偶数，如果是奇数，顺序插入到链表中，如果是偶数，倒序插入到链表中，这样就不需要利用双端队列了。</p><p><code>使用res.size() % 2 == 0来判断是奇数层（从左往右打印），还是偶数层（从右往左打印）</code></p><hr><h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p><strong>思路：</strong></p><p><strong>方法一：递归+分治</strong></p><p>根据定义，<code>二叉搜索树</code>的左子树中的所有节点值都小于根节点的值，右子树中的所有节点都大于根节点的值。根据后序遍历的顺序，输入数组的最后一个元素就是根节点。</p><p>在输入数组中找到左子树和右子树的部分，然后判断左子树的元素序列和右子树的元素序列是否符合一个二叉搜索树的后序遍历的顺序，一直递归+分治，<strong>递归终止条件是左右边界重合或者左边界超过右边界（不正确的边界），即没有左子树或者右子树了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> verifyPostorder(postorder,<span class="hljs-number">0</span>,postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-keyword">while</span>(postorder[pointer] &lt; postorder[end])&#123;<br>            pointer++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> pointer;<br>        <span class="hljs-comment">//pointer此时位于右子树的第一个节点索引处</span><br>        <span class="hljs-keyword">while</span>(postorder[pointer] &gt; postorder[end])&#123;<br>            pointer++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pointer == end &amp;&amp; verifyPostorder(postorder,start,mid - <span class="hljs-number">1</span>) &amp;&amp; verifyPostorder(postorder,mid,end - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>pointer &#x3D;&#x3D; end</strong>条件说明这个树符合后序遍历，是一个正确的树</p><p>**时间复杂度 O(N^2)**： 每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。<br><strong>空间复杂度 O(N)：</strong> 最差情况下（即当树退化为链表），递归深度将达到 N 。</p><blockquote><p>复杂度分析引用力扣K神题解</p></blockquote><p><strong>方法二：单调栈</strong></p><p>将数组倒序过来，如果postorder[i] &lt; postorder[i+1]，说明postorder[i+1]是postorder[i]的右子节点，postorder[i]是postorder[i+1]的父节点。因为后序遍历中每个子树中的根节点都是最后遍历的，所以postorder[i+1]一定是postorder[i]的右子树的根节点。</p><p>如果postorder[i] &gt; postorder[i+1]，说明postorder[i+1]是前面其中一个节点的左子树的根节点，postorder[i] - postorder[i+1]的绝对值最小，postorder[i]就是postorder[i+1]的父节点。</p><p>由于他们具有单调递增和单调递减的性质，所以可以采用单调栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> postorder.length - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-comment">//遍历的节点postorder[i]一定位于当前parent节点的左子树中</span><br>            <span class="hljs-comment">//所以一定要postorder[i] &gt; parent</span><br>            <span class="hljs-keyword">if</span>(postorder[i] &gt; parent) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peekLast() &gt; postorder[i])&#123;<br>                parent = stack.removeLast();<br>            &#125;<br>            stack.addLast(postorder[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度o(n) 空间复杂度o(n)</p><hr><h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><strong>思路：</strong></p><p>先序遍历+回溯</p><p>因为list是引用传递，全过程只有一个，所以当最后对list进行的回溯操作会影响res中已经添加的list对象，所以res在添加的时候需要重新拷贝一份list。</p><p>而target不需要回溯，因为它是值传递，每次递归都会重新赋值一个新的target。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        preOrder(root,target,list);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node,<span class="hljs-type">int</span> target,List&lt;Integer&gt; list)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        list.add(node.val);<br>        target -= node.val;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>&amp;&amp;node.right == <span class="hljs-literal">null</span> &amp;&amp; node.left == <span class="hljs-literal">null</span>)&#123;<br>              res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        &#125;<br>        preOrder(node.left,target,list);<br>        preOrder(node.right,target,list);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">// 向上回溯前，需要将当前节点从路径 path 中删除，</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>就是本来两个节点之间只有一个指针，现在需要加一个反向的指针，就构成了双向指针。</p><p><strong>思路：</strong></p><p>循环链表需要头节点和尾节点也有双向指针。</p><p>因为题目中要求转换成排序的循环双向链表，所以是在中序遍历的过程中，多添加一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node left;</span><br><span class="hljs-comment">    public Node right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-keyword">private</span> Node pre;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        inOrder(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(Node cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        inOrder(cur.left);<br>        cur.left = pre;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">null</span>)&#123;<br>            head = cur;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pre.right = cur;<br>        &#125;<br>        pre = cur;<br>        inOrder(cur.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p><p><strong>思路：</strong></p><p>中序遍历的倒序，在倒序中序遍历的过程中寻找第k大的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        inOrder(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        inOrder(node.right);<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        k--;<span class="hljs-comment">//遍历一个节点就将k减1，当减到0，说明它就是第k大的节点</span><br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) res = node.val;<br>        inOrder(node.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>时间复杂度：O(N)  //这个不太明白</code></p><p>空间复杂度：O(N)：使用的空间由递归栈的<strong>深度</strong>决定，它<strong>等于当前节点在二叉树中的高度</strong>。当二叉树退化成链表时，深度是N 。</p><hr><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>思路：</strong></p><p><strong>方法一：</strong>BFS</p><p>最大深度就是左子树和右子树他们的最大深度加上根节点的高度1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(N)：n为树的节点个数，需要遍历所有节点才能算出树的深度</p><p>空间复杂度：O(N)：递归栈的深度取决于树的深度，树的深度最大为N（退化成链表）</p><p><strong>方法二：</strong></p><p>层序遍历+队列</p><p>每遍历一层，depth+1，所以我们要控制每次循环就遍历一层。可以使用tmp临时存储每层中的节点，每次都将每层全部赋值给队列，然后一次循环，全部遍历，再开启新的一层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        LinkedList&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.addLast(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            LinkedList&lt;TreeNode&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(TreeNode node : deque)&#123;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    tmp.addLast(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    tmp.addLast(node.right);<br>                &#125;<br>            &#125;<br>            deque = tmp;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(N)：n为树的节点个数，需要遍历所有节点才能算出树的深度</p><p>空间复杂度：O(N)：最差情况下（当树为满二叉树时），队列 <code>queue</code> 同时存储 (N+1)&#x2F;2 个节点</p><hr><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p> <strong>思路：</strong></p><p><strong>方法一：</strong>深度优先遍历。先序遍历，<strong>从顶至底</strong></p><p>一棵二叉树是平衡二叉树的条件：</p><ol><li>它的左子树和右子树高度相差1</li><li>左子树和右子树本身也是平衡二叉树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> Math.abs(depth(root.left)-depth(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">depth</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(depth(node.left),depth(node.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(nlogn)   最坏的情况下(满二叉树)，需要遍历所有节点判断以这个节点为根节点的子树是否是平衡二叉树，满二叉树的高度是O(logn)。各层执行 depth(root) 的时间复杂度为 O(N) （每层开始，最多遍历 N个节点，最少遍历 （N+1）&#x2F;2个节点）。–（不太理解）</p><p>—-引用力扣K神  </p></blockquote><p>空间复杂度：O(N)。最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</p><p><strong>方法二：</strong></p><p>自底向下的后序遍历</p><p>一直获取root的最左边的节点，以及最右边的节点，逐层往上依次判断节点是否是高度小于等于1，比如对于root的左子树中的其中一个节点，这个节点是某一个节点的左结点，它不是平衡的，那么就会返回-1，这个节点的父节点的left就会返回-1，然后一直往上遍历，每到if判断中就会返回-1，最终-1返回到root，结束，而root 的右子树就不需要再遍历了，节省了很多时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> heigth(root) != -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">heigth</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> heigth(root.left);<br>        <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> heigth(root.right);<br>        <span class="hljs-keyword">if</span>(right == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> Math.abs(left - right) &lt;= <span class="hljs-number">1</span> ? Math.max(left,right) + <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 o(n) 最差需要遍历所有节点</p><p> 空间复杂度 o(n)</p><hr><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路：</strong></p><p><strong>方法一：</strong>一次遍历</p><p>两个节点只有三种情况：</p><ol><li>两个节点都位于根节点的左子树中</li><li>两个节点都位于根节点的右子树中</li><li>一个节点位于根节点的左子树，一个节点位于根节点的右子树<strong>（这种情况下根节点就是他们的最近公共祖先节点）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootValue</span> <span class="hljs-operator">=</span> root.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pValue</span> <span class="hljs-operator">=</span> p.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">qValue</span> <span class="hljs-operator">=</span> q.val;<br>            <span class="hljs-keyword">if</span>(rootValue &gt; pValue &amp;&amp; rootValue &gt; qValue)&#123;<br>                <span class="hljs-comment">//两节点都位于二叉树的左子树</span><br>                root = root.left;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rootValue &lt; pValue &amp;&amp; rootValue &lt; qValue)&#123;<br>                <span class="hljs-comment">//两节点都位于二叉树的右子树</span><br>                root = root.right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//一个位于左子树，一个位于右子树，说明root此时就是最近的公共节点</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以优化，始终令p.val&gt;q.val</p><hr><p>——未完待续</p>]]></content>
    
    
    <categories>
      
      <category>DateStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-运行时数据区域</title>
    <link href="/2022/03/24/Java/JVM/2.java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2022/03/24/Java/JVM/2.java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.运行时数据区域"></a>1.运行时数据区域</h1><p>java虚拟机在执行java程序的过程中会把<strong>它所管理的内存</strong>划分为若干不同的数据区域。</p><p>这些数据区域包括：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p><img src="/image/jvm/1.6.png"></p><p><img src="/image/jvm/1.7.png"></p><p><img src="/image/jvm/1.8.png"></p><h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h2><p>程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。在java虚拟机的<strong>概念模型</strong>（代表了所有虚拟机的统一外观）中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p><code>线程私有！！</code>原因：线程是轮流使用处理器，在交换处理器的使用权的过程中一定会出现上下文切换，为了线程切换后能恢复到正确位置，需要各条线程之间的程序计数器互不影响，独立存储。</p><p>线程执行的是java方法：程序计数器记录的是正在执行的虚拟机字节码指令的地址。</p><p>线程执行的是本地native方法，程序计数器的值为空。</p><p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h2 id="1-2-java虚拟机栈"><a href="#1-2-java虚拟机栈" class="headerlink" title="1.2 java虚拟机栈"></a>1.2 java虚拟机栈</h2><p><code>线程私有！！</code></p><p>java虚拟机栈描述的是java方法执行的内存模型。</p><p>首先需要来说一下<strong>栈帧</strong>的概念。</p><p>javac -g jvm&#x2F;demo2.java     编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>javap -v jvm&#x2F;demo2.class   反编译 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br>  descriptor: (II)I<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">8</span>, args_size=<span class="hljs-number">3</span><br>       <span class="hljs-number">0</span>: dconst_1<br>       <span class="hljs-number">1</span>: dstore_3<br>       <span class="hljs-number">2</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class jvm/Person</span><br>       <span class="hljs-number">5</span>: dup<br>       <span class="hljs-number">6</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method jvm/Person.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">9</span>: astore        <span class="hljs-number">5</span><br>      <span class="hljs-number">11</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String 123456</span><br>      <span class="hljs-number">13</span>: astore        <span class="hljs-number">6</span><br>      <span class="hljs-number">15</span>: iconst_2<br>      <span class="hljs-number">16</span>: istore        <span class="hljs-number">7</span><br>      <span class="hljs-number">18</span>: iload_1<br>      <span class="hljs-number">19</span>: iload_2<br>      <span class="hljs-number">20</span>: iadd<br>      <span class="hljs-number">21</span>: ireturn<br>    LineNumberTable:<br>      line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">10</span>: <span class="hljs-number">2</span><br>      line <span class="hljs-number">11</span>: <span class="hljs-number">11</span><br>      line <span class="hljs-number">12</span>: <span class="hljs-number">15</span><br>      line <span class="hljs-number">13</span>: <span class="hljs-number">18</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>      <span class="hljs-number">22</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Ljvm/demo2;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">22</span>     <span class="hljs-number">1</span>     a   I<br>          <span class="hljs-number">0</span>      <span class="hljs-number">22</span>     <span class="hljs-number">2</span>     b   I<br>          <span class="hljs-number">2</span>      <span class="hljs-number">20</span>     <span class="hljs-number">3</span>     c   D<br>         <span class="hljs-number">11</span>      <span class="hljs-number">11</span>     <span class="hljs-number">5</span>    p1   Ljvm/Person;<br>         <span class="hljs-number">15</span>       <span class="hljs-number">7</span>     <span class="hljs-number">6</span>     d   Ljava/lang/String;<br>         <span class="hljs-number">18</span>       <span class="hljs-number">4</span>     <span class="hljs-number">7</span>     f   I<br></code></pre></td></tr></table></figure><p><strong>栈帧存储了：</strong></p><ul><li><p><strong>局部变量表</strong></p><p>它存放了<strong>方法参数</strong>和<strong>方法内定义的局部变量</strong>。一个变量槽的大小是由具体的虚拟机来定义的，一般来说一个变量槽大小为32bit，所以long和double需要两个变量槽，其他数据类型需要1个。</p><p>局部变量表中，最基本的存储单元是Slot（变量槽），下面表中的Slot表示的是索引开始的位置，可以看到int类型的a变量变量槽的下标是从1开始，int类型的b变量变量槽的下标是从2开始，所以a变量占用1个变量槽，而double类型的c变量槽的下标是从3开始的，引用类型对象p1是从5开始的，因此double类型占用2个变量槽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalVariableTable:<br>    Start  Length  Slot  Name   Signature<br>        <span class="hljs-number">0</span>      <span class="hljs-number">22</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Ljvm/demo2;<br>        <span class="hljs-number">0</span>      <span class="hljs-number">22</span>     <span class="hljs-number">1</span>     a   I<br>        <span class="hljs-number">0</span>      <span class="hljs-number">22</span>     <span class="hljs-number">2</span>     b   I<br>        <span class="hljs-number">2</span>      <span class="hljs-number">20</span>     <span class="hljs-number">3</span>     c   D<br>       <span class="hljs-number">11</span>      <span class="hljs-number">11</span>     <span class="hljs-number">5</span>    p1   Ljvm/Person;<br>       <span class="hljs-number">15</span>       <span class="hljs-number">7</span>     <span class="hljs-number">6</span>     d   Ljava/lang/String;<br>       <span class="hljs-number">18</span>       <span class="hljs-number">4</span>     <span class="hljs-number">7</span>     f   I<br></code></pre></td></tr></table></figure><p>这个内存区域会出现两种异常情况：</p><p>1.如果线程请求的栈深度大于虚拟机所允许的深度(即栈帧太大或者虚拟机栈容量太小)，将抛出StackOverflowError</p><p>2.如果java虚拟机栈的容量可以动态扩展，当栈扩展到无法申请到足够的内存会抛出OutOfMemoryError异常。（HotSpot虚拟机的栈容量是不允许动态扩展的，出现这种异常的唯一原因就是(系统可以创建多线程)在创建线程申请内存时就因无法获得足够的内存而出现OOM ：unable to create native thread）</p></li><li><p>操作数栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">8</span>, args_size=<span class="hljs-number">3</span><br>        <span class="hljs-number">0</span>: dconst_1<br>        <span class="hljs-number">1</span>: dstore_3<br>        <span class="hljs-number">2</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class jvm/Person</span><br>        <span class="hljs-number">5</span>: dup<br>        <span class="hljs-number">6</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method jvm/Person.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">9</span>: astore        <span class="hljs-number">5</span><br>       <span class="hljs-number">11</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String 123456</span><br>       <span class="hljs-number">13</span>: astore        <span class="hljs-number">6</span><br>       <span class="hljs-number">15</span>: iconst_2<br>       <span class="hljs-number">16</span>: istore        <span class="hljs-number">7</span><br>       <span class="hljs-number">18</span>: iload_1<br>       <span class="hljs-number">19</span>: iload_2<br>       <span class="hljs-number">20</span>: iadd<br>       <span class="hljs-number">21</span>: ireturn<br></code></pre></td></tr></table></figure><p>stack&#x3D;2表示操作数栈大小为2， locals&#x3D;8,表示局部变量表的长度（Slot的数量）为8， args_size&#x3D;3表示该方法的形参个数。如果是实例方法，第一个形参是this引用。</p></li><li><p>动态连接</p><p>动态链接又称为<code>指向运行时常量池的方法引用</code>。每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。 包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking）。在Java源文件被编译到字节码文件中时，<strong>编译期间生成的各种字面量和符号引用都保存在class文件的常量池里。这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p><p>比如 <code>11: ldc     #4     // String 123456</code>     #4表示去常量池中#4的位置找,可以发现是String类型，它的值在#39，是字符串123456</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">10.</span>#<span class="hljs-number">37</span>        <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Class              #<span class="hljs-number">38</span>            <span class="hljs-comment">// jvm/Person</span><br>   #<span class="hljs-number">3</span> = Methodref          #<span class="hljs-number">2.</span>#<span class="hljs-number">37</span>         <span class="hljs-comment">// jvm/Person.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">39</span>            <span class="hljs-comment">// 123456</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">40</span>            <span class="hljs-comment">// jvm/demo2</span><br>   #<span class="hljs-number">6</span> = Methodref          #<span class="hljs-number">5.</span>#<span class="hljs-number">37</span>         <span class="hljs-comment">// jvm/demo2.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">7</span> = Fieldref           #<span class="hljs-number">41.</span>#<span class="hljs-number">42</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">8</span> = Methodref          #<span class="hljs-number">5.</span>#<span class="hljs-number">43</span>         <span class="hljs-comment">// jvm/demo2.add:(II)I</span><br>   ..............<br>   #<span class="hljs-number">39</span> = Utf8               <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure></li><li><p>方法的返回地址</p></li></ul><p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h2><p><code>线程私有</code></p><p>本地方法栈为虚拟机使用到的本地方法服务。和虚拟机栈差不多（为java方法服务）</p><h2 id="1-4-java堆"><a href="#1-4-java堆" class="headerlink" title="1.4 java堆"></a>1.4 java堆</h2><p><code>所有线程共享</code></p><p>java几乎所有的对象实例都是在堆中分配内存。</p><p>java堆可能分为新生代、老年代。</p><p><strong>新生代：</strong>顾名思义，用来存放新生的对象。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。</p><p><strong>老年代：</strong>一定时间内都不被回收的对象放在老年代中。老年代的对象比较稳定，所以MajorGC不会频繁执行。</p><p>Eden空间、From Survivor空间、To Survivor空间等总结到垃圾收集器时再详细说。</p><blockquote><p>这些区域划分仅仅是<strong>一部分垃圾收集器</strong>的共同特性或者说设计风格而已，而非某个java虚拟机具体实现的固有内存布局（比如HotSpot虚拟机中有采用分代设计的、以及不采用分代设计的垃圾收集器），更不是《java虚拟机规范》中对java堆的进一步细致划分。</p></blockquote><p>在java堆中没有内存完成分配，并且堆也无法再扩展时，java虚拟机将抛出OOM异常。</p><h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h2><p><code>所有线程共享</code></p><p>用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p><strong>永久代：</strong>主要存放Class和Meta（元数据）的信息。</p><p>永久代中很少进行垃圾收集行为，但并非数据进入方法区就“永久”存在了，这个区域的垃圾回收主要是对常量池的回收和对类型的卸载。</p><p>JDK8以前，HotSpot虚拟机用永久代来实现方法区。<strong>JDK7以前，运行时常量池和字符串常量池放在方法区中，JDK7，字符串常量池被放在了堆中，运行时常量池还在方法区（永久代）中。</strong></p><p>JDK8，HotSpot废弃了永久代的概念，采用本地内存的元空间实现方法区。此时运行时常量池还在方法区中，只是现在方法区在本地内存中。</p><p>如果方法区无法满足新的内存分配需求时，将抛出OOM（内存溢出）异常。</p><h3 id="1-5-1-运行时常量池"><a href="#1-5-1-运行时常量池" class="headerlink" title="1.5.1 运行时常量池"></a>1.5.1 运行时常量池</h3><p>运行时常量池是方法区的一部分。</p><p>类加载后，保存class文件中描述的符号引用，以及由符号引用翻译出来的直接引用。在运行期间新的常量也可以放入运行时常量池中（ String.intern() ），它具有动态性。</p><p>当常量池无法申请到内存时，将抛出OOM（内存溢出）异常。</p><hr><h1 id="2-常量池、字符串常量池、运行时常量池的区别"><a href="#2-常量池、字符串常量池、运行时常量池的区别" class="headerlink" title="2.常量池、字符串常量池、运行时常量池的区别"></a>2.常量池、字符串常量池、运行时常量池的区别</h1><h2 id="2-1-常量池"><a href="#2-1-常量池" class="headerlink" title="2.1 常量池"></a>2.1 常量池</h2><p>常量池，即class文件常量池。java文件被编译成 class文件，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池（Constant  Pool），用于存放编译器生成的各种字面量（ Literal ）和 符号引用（Symbolic References）。</p><h2 id="2-2-字符串常量池"><a href="#2-2-字符串常量池" class="headerlink" title="2.2 字符串常量池"></a>2.2 字符串常量池</h2><p>在JDK1.6及更早版本中【String Pool】位于【方法区】</p><p>在JDK7及以上版本中【String Pool】位于【堆】 </p><p>字符串常量池中专门开辟了一个内存区域，定义为StringTable，底层是使用哈希表的形式存储的。</p><h2 id="2-3-运行时常量池"><a href="#2-3-运行时常量池" class="headerlink" title="2.3 运行时常量池"></a>2.3 运行时常量池</h2><p>运行时常量池始终位于方法区中。常量池中的信息在运行的时候会被加载到运行时常量池</p><p>在JDK1.7中【运行时常量池】位于【永久代】 </p><p>在JDK1.8中【运行时常量池】位于【元空间】</p><p><strong>具体我们以一个例子来说明。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>   &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s1 + s2;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s2);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> s7.intern();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s9</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cd&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>反编译结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">4</span>, locals=<span class="hljs-number">10</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>        <span class="hljs-number">11</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-number">13</span>: aload_1<br>        <span class="hljs-number">14</span>: aload_2<br>        <span class="hljs-number">15</span>: invokedynamic #<span class="hljs-number">5</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)L</span><br>java/lang/String;<br>        <span class="hljs-number">20</span>: astore        <span class="hljs-number">5</span><br>        <span class="hljs-number">22</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class java/lang/String</span><br>        <span class="hljs-number">25</span>: dup<br>        <span class="hljs-number">26</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String c</span><br>        <span class="hljs-number">28</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">31</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class java/lang/String</span><br>        <span class="hljs-number">34</span>: dup<br>        <span class="hljs-number">35</span>: ldc           #<span class="hljs-number">9</span>                  <span class="hljs-comment">// String d</span><br>        <span class="hljs-number">37</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">40</span>: invokedynamic #<span class="hljs-number">5</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)L</span><br>java/lang/String;<br>        <span class="hljs-number">45</span>: astore        <span class="hljs-number">6</span><br>        <span class="hljs-number">47</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class java/lang/String</span><br>        <span class="hljs-number">50</span>: dup<br>        <span class="hljs-number">51</span>: aload_2<br>        <span class="hljs-number">52</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">55</span>: astore        <span class="hljs-number">7</span><br>        <span class="hljs-number">57</span>: aload         <span class="hljs-number">7</span><br>        <span class="hljs-number">59</span>: invokevirtual #<span class="hljs-number">10</span>                 <span class="hljs-comment">// Method java/lang/String.intern:()Ljava/lang/String;</span><br>        <span class="hljs-number">62</span>: astore        <span class="hljs-number">8</span><br>        <span class="hljs-number">64</span>: ldc           #<span class="hljs-number">11</span>                 <span class="hljs-comment">// String cd</span><br>        <span class="hljs-number">66</span>: astore        <span class="hljs-number">9</span><br>        <span class="hljs-number">68</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">9</span><br>        line <span class="hljs-number">13</span>: <span class="hljs-number">13</span><br>        line <span class="hljs-number">14</span>: <span class="hljs-number">22</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">47</span><br>        line <span class="hljs-number">16</span>: <span class="hljs-number">57</span><br>        line <span class="hljs-number">17</span>: <span class="hljs-number">64</span><br>        line <span class="hljs-number">23</span>: <span class="hljs-number">68</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">69</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">66</span>     <span class="hljs-number">1</span>    s1   Ljava/lang/String;<br>            <span class="hljs-number">6</span>      <span class="hljs-number">63</span>     <span class="hljs-number">2</span>    s2   Ljava/lang/String;<br>            <span class="hljs-number">9</span>      <span class="hljs-number">60</span>     <span class="hljs-number">3</span>    s3   Ljava/lang/String;<br>           <span class="hljs-number">13</span>      <span class="hljs-number">56</span>     <span class="hljs-number">4</span>    s4   Ljava/lang/String;<br>           <span class="hljs-number">22</span>      <span class="hljs-number">47</span>     <span class="hljs-number">5</span>    s5   Ljava/lang/String;<br>           <span class="hljs-number">47</span>      <span class="hljs-number">22</span>     <span class="hljs-number">6</span>    s6   Ljava/lang/String;<br>           <span class="hljs-number">57</span>      <span class="hljs-number">12</span>     <span class="hljs-number">7</span>    s7   Ljava/lang/String;<br>           <span class="hljs-number">64</span>       <span class="hljs-number">5</span>     <span class="hljs-number">8</span>    s8   Ljava/lang/String;<br>           <span class="hljs-number">68</span>       <span class="hljs-number">1</span>     <span class="hljs-number">9</span>    s9   Ljava/lang/String;<br>                                     <br></code></pre></td></tr></table></figure><p>首先javac编译器进行编译，<strong>在常量池中生成字节码信息。这时a b ab 等都是常量池中的符号，还不是java对象。</strong></p><p>String s1 &#x3D; “a” ;</p><p>在运行时，运行到<code>0: ldc    #2    // String a</code>的时候，才会将常量池#2位置的a符号变为a字符串对象（懒加载），然后去StringTabe中查找是否有a这个字符串对象， 如果没有，将其放入其中，如果有，这个对象就直接指向StringTable中的这个a字符串对象。</p><p>String s3 &#x3D; “ab”;</p><p>String s4 &#x3D; “a” + “b”;</p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，所以这句话在编译过之后实际上就等于 String s4 &#x3D; “ab”;</p><p>这一行也可以看出来s3和s4就是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br><span class="hljs-number">8</span>: astore_3<br><span class="hljs-number">9</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br><span class="hljs-number">11</span>: astore        <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>String s5 &#x3D; s1 + s2;</p><p>字符串对象拼接。</p><p>底层等于 new String(“a”+”b”); 它指向存放在堆中新分配的地址中的对象。因此s5指向这个地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span>: aload_1<br><span class="hljs-number">14</span>: aload_2<br><span class="hljs-number">15</span>: invokedynamic #<span class="hljs-number">5</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)L</span><br>java/lang/String;<br><span class="hljs-number">20</span>: astore        <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>String s6 &#x3D; new String(“c”) + new String(“d”);</p><p>String s9 &#x3D; “cd”;</p><p>编译时，在常量池中生成c  d符号，运行时，创建”c”对象，如果StringTable中没有，就加入到其中，创建”d”对象，如果StringTable中没有，就加入到其中，然后拼接”c” 和”d”为”cd”，在堆中申请内存空间，存入其中，返回这个内存空间的地址。”cd”并没有存入StringTable中。</p><p>所以s6 !&#x3D; s9</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-number">22</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class java/lang/String</span><br>        <span class="hljs-number">25</span>: dup<br>        <span class="hljs-number">26</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String c</span><br>        <span class="hljs-number">28</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">31</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class java/lang/String</span><br>        <span class="hljs-number">34</span>: dup<br>        <span class="hljs-number">35</span>: ldc           #<span class="hljs-number">9</span>                  <span class="hljs-comment">// String d</span><br>        <span class="hljs-number">37</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">40</span>: invokedynamic #<span class="hljs-number">5</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)L</span><br>java/lang/String;<br>        <span class="hljs-number">45</span>: astore        <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>String s7 &#x3D; new String(s2);<br>String s8 &#x3D; s7.intern();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">47</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class java/lang/String</span><br><span class="hljs-number">50</span>: dup<br><span class="hljs-number">51</span>: aload_2<br><span class="hljs-number">52</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="hljs-number">55</span>: astore        <span class="hljs-number">7</span><br><span class="hljs-number">57</span>: aload         <span class="hljs-number">7</span><br><span class="hljs-number">59</span>: invokevirtual #<span class="hljs-number">10</span>                 <span class="hljs-comment">// Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="hljs-number">62</span>: astore        <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>intern方法的作用：主动将串池中还没有的字符串对象放入串池。</p><ul><li>1.8将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</li><li>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>java内存区域</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-垃圾收集器与内存分配策略</title>
    <link href="/2022/03/24/Java/JVM/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2022/03/24/Java/JVM/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-为什么只有堆和方法区内存需要垃圾收集器进行回收"><a href="#1-为什么只有堆和方法区内存需要垃圾收集器进行回收" class="headerlink" title="1.为什么只有堆和方法区内存需要垃圾收集器进行回收"></a>1.为什么只有堆和方法区内存需要垃圾收集器进行回收</h1><p>对于程序计数器、虚拟机栈、本地方法栈是线程私有的，三个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。每个栈帧中将要分配多少内存在编译期间就可以确定，因此这几个区域的内存分配和回收具有确定性，因此不需要编写复杂的垃圾收集算法，<strong>一个方法执行完，栈帧出栈后，即被销毁。内存就会被回收。</strong></p><p>而堆和方法区分配的内存具有不确定性，只有当处于运行期间时，我们才知道到底创建了多少对象，需要在运行期间给这些对象分配内存。因此这部分区域的<strong>内存分配和回收是动态的</strong>。</p><h1 id="2-回收堆"><a href="#2-回收堆" class="headerlink" title="2.回收堆"></a>2.回收堆</h1><p><strong>即判断对象是否可以被回收</strong></p><h2 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h2><p><strong>原理：</strong>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一，当引用失效时，计数器就减一，当计数器的值为0时表示这个对象不再被引用，可以被回收。</p><p>**优点:**原理简单，引用计数器只占了很小一部分空间，效率高。</p><p><strong>缺点：</strong>会出现对象之间循环引用的问题。当两个对象互相引用，并且除此之外再也没有其他对象引用他们，以后垃圾回收也不会回收他们，因为他们的引用计数器值都是1，但实际上他们没有再被其他对象引用，是需要回收的。</p><h2 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h2><p><strong>原理：</strong>通过一系列称为”GC Root”的根对象作为起始节点集合，从这些节点开始根据引用关系向下搜索，如果从GC Root到这个对象不可达时，没有引用链相连，说明这个对象是不可能再被使用的，就会被判定为可回收的对象。</p><p><strong>哪些对象可以作为GC Root对象？</strong></p><ul><li>栈帧中局部变量表中引用的对象</li><li>在方法区中常量引用的对象。如字符串常量池中的String Table中的引用。String s1 &#x3D; “abc”;</li><li>方法区中类静态属性引用的变量。比如public static String str &#x3D; “abc” ; 静态成员变量是str，对象是”abc” </li><li>本地方法栈中native方法引用的对象</li><li>java虚拟机内部的引用，如基本数据类型对应的Class对象，异常对象(NullPointException)、以及系统类加载器</li><li>被同步锁（synchronized关键字）持有的对象</li><li>反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存</li><li>如果只针对堆中某一部分进行垃圾收集，那么在这个部分中可能有被其他部分对象所引用，为了维护可达性分析的正确性，这时需要将其他部分的那些对象也加入GC Roots中。</li></ul><h2 id="2-3-引用"><a href="#2-3-引用" class="headerlink" title="2.3 引用"></a>2.3 引用</h2><p><strong>强引用：</strong>只要强引用关系存在，垃圾收集器永远不会回收被引用的对象。String str &#x3D; new String(“Reference”);  GC Roots对象的引用是强引用</p><p><strong>软引用：</strong>没有被GC Root对象直接引用（即没有被强引用，如果间接被GC root引用也不行），但被软引用引用。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。SoftReference<String> sr &#x3D; new SoftReference<String>(new String(“CacheData”));</p><p><strong>弱引用：</strong>没有被GC Root对象直接引用（即没有被强引用，如果间接被GC root引用也不行），但被弱引用引用。无论当前堆内存是否足够，垃圾收集器都会将只被弱引用关联的对象回收。WeakReference<String> wr &#x3D; new WeakReference<String>(new String(“CacheData”));</p><p><strong>虚引用：</strong>无法通过虚引用来获得一个对象实例，为一个对象设置虚引用关联的唯一目的知识为了能在这个对象被收集器回收时收到一个系统通知。</p><p><strong>引用队列：</strong>软引用、弱引用本身也是一个对象，他们在创建时被分配了一个引用队列，如果引用的对象被回收后，需要将它们加入引用队列，只需要遍历引用队列就可以将它们回收。</p><h2 id="2-4-finalize"><a href="#2-4-finalize" class="headerlink" title="2.4 finalize()"></a>2.4 finalize()</h2><p>要宣告一个对象死亡，最多会经历两次标记，第一次是可达性分析，当对象在可达性算法中被判定为不可达，这是第一次标记<strong>，这时虚拟机会看这个对象的finalize方法()是否被调用过，如果以前调用过了，那这个对象会直接被判定为可回收</strong>，如果没有，虚拟机会调用这个方法，并把对象加入一个队列中，在某一时间虚拟机会对队列中的对象进行第二次遍历**(虚拟机并不一定会等finalize()执行结束)**，如果在finalize()方法中这个对象此时被其他对象引用，则这个对象不会被回收，否则会被标记，回收（第二次）。</p><h1 id="3-回收方法区"><a href="#3-回收方法区" class="headerlink" title="3.回收方法区"></a>3.回收方法区</h1><p>方法区的垃圾收集主要是<code>回收废弃的常量</code>和<code>不再使用的类型(类)</code></p><p>类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h1 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4.垃圾收集算法"></a>4.垃圾收集算法</h1><p>下面的算法都属于追踪式垃圾收集算法。</p><p><strong>Full GC：</strong>整堆收集。整个java堆和方法区的垃圾收集。</p><p><strong>Partial GC :</strong> 部分收集。不是收集完整的java堆</p><ul><li>Minor GC&#x2F;Young GC（只对新生代的垃圾收集）</li><li>Major GC&#x2F;Old GC（只对老年代的垃圾收集）</li><li>Mixed GC（收集整个新生代以及部分来年代的垃圾收集）</li></ul><h2 id="4-1-标记-清除算法"><a href="#4-1-标记-清除算法" class="headerlink" title="4.1 标记-清除算法"></a>4.1 标记-清除算法</h2><p>顾名思义，先标记，后清除。即先将需要回收的对象标记出来（也可以标记存活对象，回收没被标记的对象），标记完成后，统一回收被标记的对象。</p><p><strong>缺点：</strong>1.执行效率不稳定。当java堆中有大量需要回收的对象时，标记这个操作需要耗费大量时间，因为回收的对象多，所以回收也会耗费很多时间。2.内存碎片会变多。标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后分配大对象时由于每个空间都不足以满足大对象的内存空间，无法找到连续内存而提前触发垃圾收集。</p><h2 id="4-2-标记-复制算法"><a href="#4-2-标记-复制算法" class="headerlink" title="4.2 标记-复制算法"></a>4.2 标记-复制算法</h2><p>标记-复制算法通常被简称为<strong>复制算法</strong>。</p><p>Fenichel提出的<strong>半区复制</strong></p><p>将堆内存一比一划分为两个大小相等的区域，每次只使用其中的一块，当这一块的内存用完了就将还存活的对象复制到另一块，然后把这一块全部清空。避免了内存碎片的产生，但是当这个区域存活的对象非常多时，复制的效率就比较低。</p><p>Andrew Appel提出了改进方案</p><p><strong>Appel式回收</strong>：使用分代的垃圾收集机制，HotSpot虚拟机将新生代划分为Eden区，Survivor From区，Survivor To区。HotSpot虚拟机默认Eden, Survivor From, Survivor To的大小比例是8:1:1   每次分配内存时只使用Eden区，Survivor From区，当内存空间不足时，会触发一次Minor GC，通过GC Roots的引用链看包含哪个对象，即这个对象就不会被回收，虚拟机会将它们复制到Survivor To中，并将它们的年龄+1 (一开始是0)，然后一次性将Eden区，Survivor From区的可回收对象清空。然后交换Survivor From区和Survivor To，逐渐地，当To区不足以容纳一次Minor GC 之后存活的对象时，检查哪个年龄超过阈值15 或者比较大的年龄，将这些对象复制到老年代中。</p><p>有时候新生代内存十分紧张时，To区的对象不必等到年龄超过15，而是直接晋升到老年代。当需要分配内存的对象是一个大对象时，也直接进入老年代。</p><p>当老年代内存不足时，会再次触发一次Minor GC，若空间仍然不足，则触发Full GC。当触发Full GC 后内存空间还是不足，则触发<strong>OOM</strong>内存溢出异常。</p><p>HotSpot虚拟机的新生代垃圾收集器均采用这个策略来设计新生代的内存布局。</p><h2 id="4-3-标记-整理算法"><a href="#4-3-标记-整理算法" class="headerlink" title="4.3 标记-整理算法"></a>4.3 标记-整理算法</h2><p>标记的动作和标记-清除中的是一样的，先标记存活对象，然后将存活对象整体移动到内存空间的一端，直接清除边界以外的内存。</p><p>移动操作是必须全程暂停用户应用程序，<code>Stop The World！</code></p><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p><strong>在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong> </p><p><strong>标记-清除算法</strong>和<strong>标记-整理算法</strong>各有缺点。</p><p>标记清除算法中，容易产生大量的内存碎片，导致空间碎片化，这可以通过”分区空闲分配链表”来解决，将碎片空间进行逻辑连接，因此在标记清除算法中内存分配和访问是很耗时的。标记整理算法需要STW来将存活对象移动到堆的一侧，并更新所有引用这些对象的地方，不过这个停顿时间只有在垃圾收集时才会触发，这个是标记整理算法耗时的地方。</p><p><strong>由于内存分配和访问相比垃圾收集频率高得多</strong>，所以使用标记清除算法的程序的吞吐量是小于使用标记整理算法的。</p><p>所以大部分垃圾收集器对老年代中对象的回收都是基于标记-整理算法。</p><h1 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5.垃圾收集器"></a>5.垃圾收集器</h1><ul><li><p>新生代垃圾收集器：Serial收集器、ParNew收集器、Parallel Scavenge收集器</p></li><li><p>老年代垃圾收集器：CMS收集器、Serial Old收集器、Parallel Old收集器</p></li><li><p>全堆垃圾收集器：G1</p></li></ul><h2 id="5-1-Serial收集器"><a href="#5-1-Serial收集器" class="headerlink" title="5.1 Serial收集器"></a>5.1 Serial收集器</h2><p>Serial（串行）收集器。这个收集器是<strong>单线程工作</strong>的<strong>新生代</strong>垃圾收集器，是专门收集新生代的垃圾收集器，它只使用一个处理器或一条垃圾收集线程去进行垃圾收集工作，并且它在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。<code>Stop The World！</code></p><p><strong>优点：</strong>与其他收集器的单线程相比，Serial收集器简单而高效，它是所有收集器里额外内存消耗最小的，没有线程交互的开销，所以垃圾收集的效率也比较高。</p><p>它是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。</p><p><img src="/image/jvm/3.1.png"></p><h2 id="5-2-ParNew收集器"><a href="#5-2-ParNew收集器" class="headerlink" title="5.2 ParNew收集器"></a>5.2 ParNew收集器</h2><p>ParNew是运行在服务端模式下的HotSpot虚拟机中的垃圾收集器，是专门收集新生代的垃圾收集器。ParNew收集器使用<strong>多条线程</strong>进行垃圾收集，除此之外，和Serial收集器几乎一样。</p><p>ParNew收集器和CMS收集器（老年代）配合工作，后来ParNew合并进了CMS收集器中，称为了CMS专门处理新生代的部分。</p><p><img src="/image/jvm/3.2.png"></p><h2 id="5-3-Parallel-Scavenge收集器"><a href="#5-3-Parallel-Scavenge收集器" class="headerlink" title="5.3 Parallel Scavenge收集器"></a>5.3 Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器是一款基于标志复制算法的<strong>吞吐量优先</strong>的新生代垃圾收集器，也可以使用多条线程进行垃圾收集工作，但是这款收集器的目标是<strong>达到一个可控制的吞吐量</strong>，而不是追求垃圾收集的时用户线程的停顿时间。吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+运行垃圾收集时间)</p><h2 id="5-4-Serial-Old收集器"><a href="#5-4-Serial-Old收集器" class="headerlink" title="5.4 Serial Old收集器"></a>5.4 Serial Old收集器</h2><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。（在服务端模式下）它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器发生失败时的后备方案。</p><h2 id="5-5-Parallel-Old收集器"><a href="#5-5-Parallel-Old收集器" class="headerlink" title="5.5 Parallel Old收集器"></a>5.5 Parallel Old收集器</h2><p><strong>Parallel 收集器的老年代版本</strong>，支持多线程并行收集，基于标记整理算法实现。JDK6时开始提供。</p><p><img src="/image/jvm/3.3.png"></p><h2 id="5-6-CMS收集器"><a href="#5-6-CMS收集器" class="headerlink" title="5.6 CMS收集器"></a>5.6 CMS收集器</h2><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的老年代收集器。</strong></p><p>CMS收集器是基于<strong>标记清除算法</strong>的垃圾收集器。</p><ol><li><p><strong>初始标记</strong></p><p>标记一下GC Roots能直接关联到的对象，速度比较快。需要STW</p></li><li><p><strong>并发标记</strong></p><p>从GC Roots的直接关联对象开始遍历整个对象图，耗时，但不需要STW</p></li><li><p><strong>重新标记</strong></p><p>修正并发标记期间因用户线程继续运作导致标记产生变动的那部分对象的标记记录（增量更新），停顿时间稍微大于初始标记，远小于并发标记的时间，需要STW</p><p><em>注：增量更新</em></p></li><li><p><strong>并发清除</strong></p><p>清理删除掉标记阶段判断已经死亡的对象，因为CMS采用的是标记清除算法，所以不需要移动存活对象，因此这个阶段可以与用户线程同时并发，不需要STW。</p><p>但是在这个过程会产生<strong>浮动垃圾</strong>，即在并发标记和并发清理阶段与用户线程并发的时候用户线程产生的新的垃圾对象，由于并发清除阶段新垃圾没有被标记，因此<strong>并发清理阶段的垃圾CMS无法在这次垃圾收集时处理，只能等到下次垃圾收集时再清理</strong>。</p></li></ol><p>缺点：</p><p><strong>1.它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></p><p><strong>2.CMS收集器对处理器资源十分敏感。</strong>在并发阶段，它虽然不会导致用户线程停顿，但是却会因占用了一部分线程而导致应用程序变慢，降低总吞吐量，CMS默认启动的回收线程数等于（CPU数量+3）&#x2F;4，所以CPU个数越少，CMS对用户线程的影响就越大。</p><p>当CMS运行期间预留的内存无法满足新加进老年代的对象的大小（也可能是内存碎片），就会出现“并发失败”，虚拟机会启动planB：冻结用户线程，临时启用Serial Old收集器重新对老年代进行垃圾收集，不过停顿时间就变长了。</p><p>3.浮动垃圾</p><p><img src="/image/jvm/3.4.png"></p><h2 id="5-7-G1收集器"><a href="#5-7-G1收集器" class="headerlink" title="5.7 G1收集器"></a>5.7 G1收集器</h2><p>G1收集器是一款面向<strong>全堆</strong>进行的、面向服务端应用的垃圾收集器。它不再坚持固定大小以及固定数量的分代区域划分，而是**把连续的堆内存划分为大小相等的独立区域(Region)**，每次垃圾收集到的内存空间都是Region的整数倍，所以它是基于Region的堆内存布局的垃圾收集器。它在延迟可控的情况下获得尽可能高的吞吐量。适用于大内存的堆容量。</p><ol><li><p><strong>初始标记</strong></p><p>标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一个阶段的并发标记可以使用正确的区域来分配内存。需要STW，但是时间很短。</p><p><em>注：TAMS指针：Top at Mark Start指针，每一个Region都有这两个指针，把Region的一部分空间划分出来用于新的对象分配内存，这两个指针用来标记这个范围，G1默认这个区域的对象都是存活的。</em></p></li><li><p><strong>并发标记</strong></p><p>从GC Roots对象开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，标记要回收的对象，这个操作和用户线程并发，对象的引用关系可能会变化，因此收集器通过原始快照算法（SATB）得到引用改变的对象，重新标记。不需要STW</p><p><em>注：原始快照：</em></p></li><li><p><strong>最终标记</strong></p><p>处理并发标记期间未处理完的STAB记录，需要STW</p></li><li><p><strong>筛选回收</strong></p><p>根据优先级列表，优先回收价值收益最大的那些Region，这些Region中剩余的少量存活对象将被复制到一个空的Region<strong>（标记-复制算法）</strong>，然后对这些Region一次性全部回收，垃圾收集器会开启多条垃圾收集线程。需要STW</p></li></ol><p><strong>为什么要将堆划分成一个一个的Region呢？</strong></p><p>这是因为垃圾收集器设计者想要建立起<strong>“停顿预测模型”</strong>（指支持指定在M毫秒内，消耗在垃圾收集上的时间大概率不超过N毫秒），即垃圾收集器去跟踪每个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需要的时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间N，优先处理回收价值收益最大的那些Region，Mixed GC（这也是Garbage First名字的由来）</p><p><strong>G1是如何解决跨Region引用的问题？</strong></p><p>通过使用卡表实现的记忆集。卡表可以是一个字节数组，java堆被分成许多个特定大小（数组中每个元素的大小）的内存块，每一个块就是一个卡页，每个卡表对应一个卡页。G1的每个Region都维护一个记忆集（哈希表，key是其他Region的起始地址，value是集合，存储卡表的索引），它会记录其他Region指向自己的指针，并标记这些指针在哪些卡页&#x2F;卡表的范围内。记忆集可能会占整个堆容量的20%甚至更多。</p><p>Region中还有一个特殊的Humongous区域，专门用来存储大对象（G1认为只要超过了Region容量的一般的对象就是大对象），Humongous Region被看做老年代。</p><p>G1仍然保留新生代和老年代，但是他们不再是固定的了，而是一系列区域的动态集合。</p><h2 id="5-8-Shenandoah收集器"><a href="#5-8-Shenandoah收集器" class="headerlink" title="5.8 Shenandoah收集器"></a>5.8 Shenandoah收集器</h2><p>Shenandoah收集器与G1很像，但有几点不同：</p><ol><li>支持与用户线程并发的整理算法。</li><li>默认不使用分代收集</li><li>不使用记忆集，而是“<strong>连接矩阵</strong>”的全局数据结构来记录跨Region的引用关系。</li></ol><p>Shenandoah收集器的工作阶段分为</p><ul><li><p>初始标记</p><p>标记一下GC Roots能直接关联到的对象。需要STW</p></li><li><p><strong>并发标记</strong></p><p>遍历对象图，标记出全部可达的对象，与用户线程并发。不需要STW</p></li><li><p>最终标记</p><p>处理并发标记期间未处理完的STAB记录，G1的筛选回收中的<em>根据优先级列表，优先回收价值收益最大的那些Region，构成一个回收集</em>合并到了最终标记中。需要STW</p></li></ul><p>前三步和G1一样</p><ul><li><p>并发清理</p><p>清理那些整个Region中连一个存活对象都没有的Region。</p></li><li><p><strong>并发回收</strong></p><p>把回收集中Region中的少量存活对象复制到其他未使用的Region中。这个阶段与G1不同的是G1需要STW，冻结用户线程，而Shenandoah收集器这阶段可以与用户线程并发执行。Shenandoah通过读屏障和转发指针”Brooks Pointers”来实现并发。</p><p><em>Brooks Pointers：在原有对象布局结构的最前面统一新增一个新的引用字段Brooks Pointers，在正常不处于并发移动的情况下，该引用指向对象自己，当要进行移动对象的时候，只需要改变Brooks Pointers指针的值，即旧对象上转发指针的引用位置，使其指向新对象，就可以将所有对该对象的访问转发到新的副本上。只要旧对象的内存空间还在，则可以通过旧地址访问到新对象。</em></p></li><li><p>初始引用更新</p><p>短暂的停顿时间确保所有并发回收阶段进行的收集器线程都已经完成分配给他们的对象移动任务。</p></li><li><p><strong>并发引用更新</strong></p><p>按照物理内存地址的顺序，线性地搜索出引用类型，把旧值改为新值。</p></li><li><p>最终引用更新</p><p>修正存在于GC Roots中的引用</p></li><li><p>并发清理</p><p>现在整个回收集中没有存活的对象了，就调用一次并发清理，回收这些Region的内存空间。</p></li></ul><h2 id="5-9-ZGC收集器"><a href="#5-9-ZGC收集器" class="headerlink" title="5.9 ZGC收集器"></a>5.9 ZGC收集器</h2><p>ZGC收集器是一款基于Region内存布局的，暂时不设置分代的，使用了读屏障、染色质真和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>ZGC的Region分为三种：1.小型Region：容量固定为2MB，用于放置小于256KB的小对象。2.中型Region：容量固定为32MB，用于放置大于等于256KB但小于4KB的对象。3.大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于存放4MB及以上的大对象，每个Region只存放一个大对象。</p><p>ZGC使用读屏障和<strong>染色指针技术</strong>实现并发整理。</p><p>ZGC收集器的工作过程</p><ul><li>并发标记</li><li>并发预备重分配</li><li>并发重分配</li><li>并发重映射</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>jvm</tag>
      
      <tag>垃圾收集器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-类文件结构</title>
    <link href="/2022/03/24/Java/JVM/4.%E7%B1%BB%E6%96%87%E4%BB%B6/%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2022/03/24/Java/JVM/4.%E7%B1%BB%E6%96%87%E4%BB%B6/%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>java虚拟机不仅可以运行java程序，还可以运行其他语言编写的程序。字节码是构成平台无惯性的基石，class文件是由字节码组成的。</p><p>java虚拟机不与任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联。</p><p><strong>Class类文件的结构</strong></p><p>Class文件是一组以<strong>字节</strong>为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，<strong>中间没有添加任何分隔符</strong>。</p><p>Class文件中只有两种数据类型：</p><ul><li><p>无符号数</p><p>是基本数据类型，u1，u2，u4，u8分别代表1个字节(8bit)，2个字节，4个字节，8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值、utf8编码构成的字符串值。</p></li><li><p>表</p><p>由多个无符号数或者其他表作为数据项构成的复合数据类型。表的命名一般以“info”结尾。整个class文件本身也可以视作一张表。</p></li></ul><p>Class文件格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassFile &#123;<br>    u4             magic; <span class="hljs-comment">//Class 文件的标志</span><br>    u2             minor_version;<span class="hljs-comment">//Class 的小版本号</span><br>    u2             major_version;<span class="hljs-comment">//Class 的大版本号</span><br>    u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span><br>    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<span class="hljs-comment">//常量池</span><br>    u2             access_flags;<span class="hljs-comment">//Class 的访问标记</span><br>    u2             this_class;<span class="hljs-comment">//当前类</span><br>    u2             super_class;<span class="hljs-comment">//父类</span><br>    u2             interfaces_count;<span class="hljs-comment">//接口</span><br>    u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br>    u2             fields_count;<span class="hljs-comment">//Class 文件的字段属性</span><br>    field_info     fields[fields_count];<span class="hljs-comment">//一个类会可以有多个字段</span><br>    u2             methods_count;<span class="hljs-comment">//Class 文件的方法数量</span><br>    method_info    methods[methods_count];<span class="hljs-comment">//一个类可以有个多个方法</span><br>    u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>    attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>几个经常会提到的概念：</p><ol><li><p>全限定类名</p><p>把全类名中的 . 换成 &#x2F; 即可。比如Object类的全类名为java.lang.Object，那么它的全限定类名就是java&#x2F;lang&#x2F;Object。一般会在全限定类名后面加上 ; 表示这个全限定类名的结束，避免与其他全限定类名混淆。</p></li><li><p>简单名称</p><p>没有类型和参数修饰的方法或者字段名称，比如有一个类中的方法inc()，一个类中的字段m，他们的简单名称分别是inc，m。</p></li><li><p>方法和字段的描述符</p><p>（1）基本数据类型和方法的返回值是基本数据类型、void、对象的描述符</p><p><img src="/image/jvm/607.png"></p><p>方法返回值是对象类型，则返回值的描述符是字符L加对象的全限定类名。</p><p>（2）数组类型</p><p>每一维度使用一个前置的 [ 字符来描述，比如一个Int型数组int[]的描述符为”[I”，引用类型的数组String[] []的描述符为 “[[Ljava.lang.Object;” </p><p>（3）用描述符描述整个方法</p><p>按照先参数列表、后返回值的顺序描述，void inc()的描述符就是”()V”，int index(char[] a,int b,int c,char[] d,int f)的描述符为”([CII[CI)I”</p></li></ol><h1 id="1-魔数"><a href="#1-魔数" class="headerlink" title="1.魔数"></a>1.魔数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u4             magic; <br></code></pre></td></tr></table></figure><p>class文件的头4个字节被称为<strong>魔数</strong>，它的作用是确定这个文件是否为一个能被虚拟机接收的Cass文件。其他文件比如GIF等也使用魔数来识别文件。</p><p>使用魔数而不是扩展名.class来识别文件是否是Class文件的原因是：文件扩展名可以随意改动，不安全。Class文件的魔数值为0xCAFEBABE。</p><h1 id="2-Class文件的版本"><a href="#2-Class文件的版本" class="headerlink" title="2.Class文件的版本"></a>2.Class文件的版本</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             minor_version;<br></code></pre></td></tr></table></figure><p>第五、六字节是次版本号，JDK1.2-JDK12，次版本号都被固定为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             major_version;<br></code></pre></td></tr></table></figure><p>第七、八字节是主版本号</p><p>java的主版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号加1，比如JDK13可以生成的Class文件的主版本号为45+12&#x3D;57。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><h1 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3.常量池"></a>3.常量池</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span><br>cp_info        constant_pool;<span class="hljs-comment">//常量池</span><br></code></pre></td></tr></table></figure><p>常量池的容量是从1开始计数的，将第0项常量空出来是为了后面某些指向常量池的索引值的数据再特定情况下需要表达“不引用任何一常量池项目”的含义，可把索引值设置为0来表示。</p><p>假如常量池的数量为22，减去第0项常量，所以常量池中有21项可用常量，索引为1~21</p><p>常量池中主要存放的是：</p><ul><li><p><strong>字面量</strong></p><p>文本字符串、final的常量值</p></li><li><p><strong>符号引用</strong></p><p>类和接口的全限定类名</p><p>字段的名称和描述符</p><p>方法的名称和描述符</p><p>被模块导出或者开放的包</p></li></ul><p>下面是常量池中存放的类型。每一项常量结构中第一项都是一个u1的tag，用来标志它是下表中的哪一个结构。</p><p><img src="/image/jvm/601.png"></p><p><img src="/image/jvm/602.png"></p><p><img src="/image/jvm/603.png"></p><h1 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4.访问标志"></a>4.访问标志</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             access_flags;<br></code></pre></td></tr></table></figure><p>常量池结束后，是访问标志，用于标识一些类或者接口层次的访问信息</p><p><img src="/image/jvm/604.png"></p><p>access_flags的最终值等于所有为真的标志的值相与。</p><h1 id="5-当前类-This-Class-索引、父类-Super-Class-索引、接口-Interfaces-索引集合"><a href="#5-当前类-This-Class-索引、父类-Super-Class-索引、接口-Interfaces-索引集合" class="headerlink" title="5.当前类(This Class)索引、父类(Super Class)索引、接口(Interfaces)索引集合"></a>5.当前类(This Class)索引、父类(Super Class)索引、接口(Interfaces)索引集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             this_class;<span class="hljs-comment">//当前类</span><br>u2             super_class;<span class="hljs-comment">//父类</span><br>u2             interfaces_count;<span class="hljs-comment">//接口</span><br>u2             interfaces;<span class="hljs-comment">//一个类可以实现多个接口</span><br></code></pre></td></tr></table></figure><p>Class文件用这三项数据来确定该类型的继承关系。</p><p>类索引用于确定这个类的全限定类名，虚拟机得到u2的值后，换算为十进制，到常量池中找index为这个值的那一行，这一行是一个类型为CONSTANT_Class_info的类描述常量符，通过这个类型中的index找到CONSTANT_Utf8_info类型的字符串常量，就是全限定类名。</p><p>父类索引用于确定这个类的父类的全限定类名，确定操作和类索引的一样。</p><p>接下来的两个字节是接口计数器，表示索引表的容量，如果该类没有实现接口，那这个值是0，后面接口的索引表就不再占用任何字节，确定操作和类索引的一样。</p><h1 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6.字段表集合"></a>6.字段表集合</h1><p>用于描述接口或者类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             fields_count;<span class="hljs-comment">//Class 文件的字段的个数</span><br>field_info     fields;<span class="hljs-comment">//一个类会可以有个字段</span><br></code></pre></td></tr></table></figure><p><img src="/image/jvm/605.png"></p><p>access_flags字段访问标志符有这几种情况。</p><p><img src="/image/jvm/606.png"></p><p>name_index和descriptor_index都是对常量池的引用，需要去常量池中找，分别代表字段的简单名称和字段和方法的描述符。</p><p>attributes_count: 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</p><p>attributes_info: 存放具体属性具体内容。比如它的值是123，就存一个指向123的指针。</p><h1 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7.方法表集合"></a>7.方法表集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             methods_count;<span class="hljs-comment">//Class 文件的方法的数量</span><br>method_info    methods;<span class="hljs-comment">//方法表</span><br></code></pre></td></tr></table></figure><p><img src="/image/jvm/608.png"></p><p>access_flags的类型有</p><p><img src="/image/jvm/609.png"></p><h1 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8.属性表集合"></a>8.属性表集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br></code></pre></td></tr></table></figure><p>Class文件，方法表，字段表都可以有属性表集合。</p><p>属性表的结构</p><p><img src="/image/jvm/610.png"></p><p><strong>Code属性</strong></p><p>使用位置：<strong>方法表的属性集合中</strong></p><p>java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在Code属性中。不过并非所有的方法表都存在这个属性，比如接口或者抽象类的方法中就不存在Code属性。</p><p><img src="/image/jvm/611.png"></p><p><strong>u2       attribute_name_index</strong>是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它 代表了该属性的属性名称</p><p><strong>u4      attribute_length</strong>指示了属性值的长度，由于属性名称索引与属性长度一共为 6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</p><p><strong>u2     max_stack</strong>代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都 不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</p><p><strong>u2     max_locals</strong>代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），当局部变量表空间不足时，变量槽会被重用。</p><p>java编译器根据 同时生存的最大局部变量数量和类型计算出max_locals的大小</p><blockquote><p>方法参数（包括实例方法中的隐藏参数“this”）、显式异常处 理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中 定义的局部变量都需要依赖局部变量表来存放。</p></blockquote><p><strong>u4     code_length</strong>和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度， code是用于存储字节码指令的一系列字节流。</p><blockquote><p>虽然它是一个u4类型的长度值，理论上最大值可以达 到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它 实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</p></blockquote><p><strong>u2     attributes_count</strong>表示Code的属性表的容量</p><p><strong>attribute_info      attributes</strong>是Code的属性表,包括以下内容</p><ul><li><p>LineNumberTable属性</p><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。 它并不是运行时必需的属性，但默认会生成到Class文件之中</p></li><li><p>LocalVariableTable及LocalVariableTypeTable属性</p><p>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它 也不是运行时必需的属性，但默认会生成到Class文件之中</p></li></ul><p>等等…………..书上还有很多属性，这里不一一介绍了。</p><p>还有字节码指令他们的功能和种类，可以去看《深入理解java虚拟机》P251</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>jvm</tag>
      
      <tag>class文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-类加载机制</title>
    <link href="/2022/03/24/Java/JVM/4.%E7%B1%BB%E6%96%87%E4%BB%B6/%E7%AC%AC7%E7%AB%A0/"/>
    <url>/2022/03/24/Java/JVM/4.%E7%B1%BB%E6%96%87%E4%BB%B6/%E7%AC%AC7%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>一个类的<strong>完整生命周期</strong>如下：</p><p><img src="/image/jvm/702.png"></p><h1 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1.类加载过程"></a>1.类加载过程</h1><p><strong>类加载机制</strong>：java虚拟机吧描述类的数据结构从Class文件加载到内存，并对数据进行校验、转换解析、初始化，最终形成可以被虚拟机直接使用的java类型，这个过程就是类加载机制。</p><h2 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h2><p>在加载阶段，虚拟机需要完成三个步骤：</p><ul><li><p><strong>通过一个类的全限定名来获取定义此类的二进制字节流。</strong></p><p>首先java虚拟机会按照CLASSPATH路径，加上类的全限定名来寻找是否有一个这样的xxx文件，比如有一个类的全限定名为jmv&#x2F;demo1，通过<code>demo1.class.getClassLoader().getResource(&quot;&quot;).getPath();</code>可以获取到CLASSPATH为&#x2F;D:&#x2F;project&#x2F;leetcode&#x2F;out&#x2F;production&#x2F;leetcode&#x2F;，所以这个文件的位置就是<code>/D:/project/leetcode/out/production/leetcode/jmv/demo1.class</code>，读取demo1.class，就可以获得二进制字节流。<strong>虚拟机并没有规定二进制字节流（Class文件）从哪里获取，以及如何获取</strong>，它可以从 <code>ZIP</code> 包中读取（日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础）、其他文件生成（典型应用就是 <code>JSP</code>）等等</p><p><em>解释：class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0  1直接在二进制编译器中敲出Class文件在内的任何途径产生。它也可以从各种包中生成等等</em></p></li><li><p><strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p><p>如果二进制字节流是从class文件中获取的话，会将其中的常量池映射到方法区的运行时常量池中，Code部分也会映射到方法区中。（类的字节码放入方法区，方法区中的数据存储格式完全由虚拟机实现自行定义，HotSpot内部采用 C++ 的 instanceKlass 描述 java 类）</p></li><li><p><strong>在内存中生成一个代表这个类的java.long.Class对象，作为方法区这个类的各种数据的访问入口。</strong></p><p>_java_mirror即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用 ，所有实例对象想要访问方法区中的字节码都需要去访问代表这个类的java.long.Class对象（类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息），这个对象将作为程序访问方法区中的类型数据的外部接口。</p><p><img src="/image/jvm/701.png"></p></li></ul><p>以上是非数组类的加载过程，对于数组类，它本身不通过类加载器创建，它是由java虚拟机直接在内存中动态构造的。</p><h2 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h2><p>连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身安全。</p><ol><li><p>文件格式验证</p><p><strong>验证字节流是否符合Class文件格式的规范。</strong></p><ul><li><p>是否以魔数0xCAFEBABE开头</p></li><li><p>主版本号、次版本号是否在当前java虚拟机接收的范围之内</p></li><li><p>常量池的常量中是否有不被支持的常量类型，tag</p></li><li><p>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量</p></li><li><p>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</p></li><li><p>等等……..</p></li></ul></li><li><p>元数据验证</p><p><strong>对字节码描述的信息进行语义分析，保证不存在与《java语言规范》定义相悖的元数据信息</strong></p><ul><li>这个类是否有父类（除了java.lang.Object，所有的类都应该有父类）</li><li>这个类是否继承了不允许被继承的类（被final修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>等等….</li></ul></li><li><p>字节码验证</p><p><strong>对类的方法体（Class文件的Code属性）进行校验分析</strong></p><ul><li>保证类型转换总是有效的，比如不能把父类对象赋值给子类数据类型，或者赋值给毫无关系的数据类型，只能是把子类对象赋值给父类数据类型。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li><li>等等….</li></ul></li><li><p>符号引用验证</p><p><strong>验证该类是否缺少或者禁止访问它依赖的某些外部类、方法、字段等资源</strong></p><ul><li>符号引用通过字符串描述的全限定名是否可以找到这个类</li><li>符号引用中的类、字段、方法是否可以被当前类访问，看访问修饰符</li><li>等等….</li></ul></li></ol><h2 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h2><p>对<strong>类中定义的变量</strong>（静态变量）分配内存并设置类变量初始值的阶段。</p><p>通常情况下，初始值是零值。</p><p>基本数据类型的零值：</p><p><img src="/image/jvm/703.png"></p><p>特殊情况：当类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p><blockquote><p>ConstantValue属性；使用位置：字段表；含义：由final关键字定义的常量值；</p></blockquote><h2 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h2><p>java虚拟机将常量池中的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。</p><p><strong>符号引用</strong>：使用一组符号来描述所引用的目标，在内存中仅仅是一个符号，utf-8字符串，虚拟机并不知道这个符号代表的内容的确切位置。</p><p><strong>直接引用：</strong>可以直接指向目标的指针，或者是能间接定位到目标的句柄，通过它虚拟机可以知道这个内容的内存地址，可以找到它。</p><h2 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h2><p>直到初始化阶段，java虚拟机才真正开始执行类中编写的java程序代码，将主导权移交给应用程序。</p><p>在准备阶段，变量已经赋过一次系统要求的初始零值，而<strong>在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</strong></p><p>初始化阶段就是执行类构造器<clinit>()方法的过程，<clinit>()方法是javac编译器自动生成的。</p><p>编译期间编译器会由语句在源文件中出现的顺序依次收集类中所有类变量的赋值动作和静态语句块（static{ } ）中的语句，并将它们合并在一起，放入自动生成的类构造器<clinit>()中。</p><p><strong>要点</strong>：</p><ul><li>java虚拟机中，父类的<clinit>()方法先执行，然后再执行子类的<clinit>()方法。</li><li>如果类中没有类变量的赋值，静态语句块，编译器可以不为这个类生成<clinit>()方法</li><li>执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，接口的实现类也是如此</li><li>一个类的<clinit>()方法在多线程环境中需要被加锁同步</li></ul><h1 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h1><p><strong>通过一个类的全限定名来获取定义此类的二进制字节流。</strong>实现这一动作的代码被称为：类加载器</p><p>以JDK 8为例</p><table><thead><tr><th align="center">名称</th><th align="center">负责加载的类的位置</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Bootstrap Class Loader（启动类加载器）</td><td align="center">JAVA_HOME&#x2F;jre&#x2F;lib或者是被-Xbootclasspath参数所指定的路径</td><td align="center">无法直接访问</td></tr><tr><td align="center">Extension Class Loader(拓展类加载器)</td><td align="center">JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td align="center">上级为Bootstrap，显示为null</td></tr><tr><td align="center">Application Class Loader(应用程序类加载器)</td><td align="center">classpath</td><td align="center">上级为Extension</td></tr><tr><td align="center">自定义类加载器</td><td align="center">自定义</td><td align="center">上级为Application</td></tr></tbody></table><h2 id="2-1-Bootstrap-ClassLoader（启动类加载器）"><a href="#2-1-Bootstrap-ClassLoader（启动类加载器）" class="headerlink" title="2.1 Bootstrap ClassLoader（启动类加载器）"></a>2.1 Bootstrap ClassLoader（启动类加载器）</h2><p>可通过在控制台输入指令，使得类被启动类加器加载。</p><p>因为启动类加载器是用c++语言编写的，所以启动类加载器无法被java程序直接引用，null就代表了启动类加载器。</p><p>负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p><h2 id="2-2-Extension-Class-Loader-拓展类加载器"><a href="#2-2-Extension-Class-Loader-拓展类加载器" class="headerlink" title="2.2 Extension Class Loader(拓展类加载器)"></a>2.2 Extension Class Loader(拓展类加载器)</h2><p>这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</p><h2 id="2-3-Application-Class-Loader-应用程序类加载器"><a href="#2-3-Application-Class-Loader-应用程序类加载器" class="headerlink" title="2.3 Application Class Loader(应用程序类加载器)"></a>2.3 Application Class Loader(应用程序类加载器)</h2><p>这个类加载器是在类sun.misc.Launcher$AppClassLoader中以java代码实现的，负责加载当前应用 classpath 下的所有 jar 包和类。</p><h2 id="2-4-双亲委派模型"><a href="#2-4-双亲委派模型" class="headerlink" title="2.4 双亲委派模型"></a>2.4 双亲委派模型</h2><p>各种类加载器之间的层次关系被称为类加载器的“双亲委派模型”</p><p><img src="/image/jvm/704.png"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，这里的子父类不是继承的关系，是使用组合关系来复用父加载器的代码。</p><p><strong>双亲委派模型的工作过程：</strong>如果一个类加载器收到了类加载的请求，在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则，进行加载，但是它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一个层次的类加载器都是这样，因此所有的加载请求最终都应该传送到最顶层的启动类加载器，只有当父加载器无法完成这个加载请求时，即它的搜索范围中没有找到所需的类，子加载器才会去尝试自己完成加载。否则就是父类去加载。</p><p><strong>双亲委派模型的好处</strong></p><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载<strong>（JVM  区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）</strong>，也保证了 Java 的核心 API  不被篡改。比如java.lang.Object类，它存在于rt.jar包下，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器加载，因此Object类在程序的各种类加载器环境中都能保证是同一个类</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们也编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p><p>双亲委派源码：</p><p>private final ClassLoader parent;<br>protected Class<?> loadClass(String name, boolean resolve)        throws ClassNotFoundException    {        synchronized (getClassLoadingLock(name)) {            // 首先，检查请求的类是否已经被加载过            Class<?> c &#x3D; findLoadedClass(name);<br>            if (c &#x3D;&#x3D; null) {<br>                long t0 &#x3D; System.nanoTime();<br>                try {<br>                    if (parent !&#x3D; null) {&#x2F;&#x2F;父加载器不为空，调用父加载器loadClass()方法处理<br>                        c &#x3D; parent.loadClass(name, false);<br>                    } else {&#x2F;&#x2F;父加载器为空，使用启动类加载器 BootstrapClassLoader 加载<br>                        c &#x3D; findBootstrapClassOrNull(name);<br>                    }<br>                } catch (ClassNotFoundException e) {<br>                   &#x2F;&#x2F;抛出异常说明父类加载器无法完成加载请求<br>                }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>            <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过</span><br>            Class&lt;?&gt; c = findLoadedClass(name);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//父加载器不为空，调用父加载器loadClass()方法处理</span><br>                        c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span><br>                        c = findBootstrapClassOrNull(name);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                   <span class="hljs-comment">//抛出异常说明父类加载器无法完成加载请求</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                    <span class="hljs-comment">//自己尝试加载</span><br>                    c = findClass(name);<br><br>                    <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                    sun.misc.PerfCounter.getFindClasses().increment();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolve) &#123;<br>                resolveClass(c);<br>            &#125;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>JDK9引入了java模块化系统，扩展类加载器被平台类加载器替代</p><p><img src="/image/jvm/705.png"></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>jvm</tag>
      
      <tag>class文件</tag>
      
      <tag>类加载器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-自定义线程池</title>
    <link href="/2022/03/24/Java/JUC/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/03/24/Java/JUC/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/juc/mythread1.png"></p><hr><p><code>为什么要设置线程池？</code></p><p>在高并发的情况下，当一下子有多个任务到达时，如果对每个任务都创建一个线程，比较占用堆内存，甚至可能会出现OOM，而且会增加CPU的负荷，因为要并行处理这么多线程，上下文切换的开销大，所以我们使用线程池，使用一定数量的线程来处理多个任务，充分利用已有线程，多的任务就在阻塞队列里等待处理。</p><hr><p>自定义线程池的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/20</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPool</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS,<span class="hljs-number">10</span>,(queue,task) -&gt;&#123;<br>            <span class="hljs-comment">//拒绝策略，当线程池中的阻塞队列满了，接下来的任务该如何抉择</span><br>            <span class="hljs-comment">//1.死等</span><br>            <span class="hljs-comment">//queue.put(task);</span><br>            <span class="hljs-comment">//2.超时不等</span><br>            <span class="hljs-comment">//queue.offer(task,500,TimeUnit.MILLISECONDS);</span><br>            <span class="hljs-comment">//3.放弃执行</span><br>            <span class="hljs-comment">//什么也不写</span><br>            <span class="hljs-comment">//4.抛出异常</span><br>            <span class="hljs-comment">//throw new RuntimeException(&quot;任务执行失败&quot;);//后面的任务都不会执行</span><br>            <span class="hljs-comment">//自己执行任务</span><br>            task.run();<br><br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            threadPool.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在执行任务...&quot;</span>+ finalI);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">rejecctPolicy</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; rejectpolicy,T task)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span>&#123;<br>    <span class="hljs-comment">//任务等待队列，Runnable是对任务的抽象,对业务逻辑的抽象</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">//集合来存放线程集合，这里面是线程池中真正创建的线程，并且正在处理任务</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//你想要线程池中一共有这么多个线程来处理任务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threadNum;<br><br>    <span class="hljs-comment">//获取任务的超时时间，超时就让线程结束啦</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-keyword">private</span> rejecctPolicy&lt;Runnable&gt; rejectpolicy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> threadNum,<span class="hljs-type">long</span> timeout,TimeUnit timeUnit,<span class="hljs-type">int</span> QueueCapacity,rejecctPolicy&lt;Runnable&gt; rejectpolicy)</span>&#123;<br>        <span class="hljs-built_in">this</span>.threadNum = threadNum;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(QueueCapacity);<br>        <span class="hljs-built_in">this</span>.rejectpolicy = rejectpolicy;<br>    &#125;<br><br><br>    <span class="hljs-comment">//如果有线程的话，线程池让线程执行任务</span><br>    <span class="hljs-comment">//如果没有线程，就创建线程，执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (threads)&#123;<br>            <span class="hljs-comment">//当正在处理任务的线程数小于期望创建的线程数时，就创建线程，来执行，否则任务就加入等待队列</span><br>            <span class="hljs-keyword">if</span>(threads.size() &lt; threadNum)&#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                System.out.println(<span class="hljs-string">&quot;新增线程&quot;</span>+thread);<br>                threads.add(thread);<br>                thread.start();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">//如果阻塞队列已经放不下了，新来的任务需要</span><br><br>                <span class="hljs-comment">// 1.死等</span><br>                <span class="hljs-comment">// taskQueue.put(task);</span><br>                <span class="hljs-comment">//2.超时则不等待</span><br>                <span class="hljs-comment">//taskQueue.offer(task,timeout,timeUnit);</span><br>                <span class="hljs-comment">//3.让调用者放弃任务执行</span><br>                <span class="hljs-comment">//4.让调用者抛出异常</span><br>                <span class="hljs-comment">//5.让调用者自己执行任务</span><br><br>                taskQueue.tryPut(rejectpolicy,task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//线程，用Worker类再包装一下</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span>  Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span>&#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-comment">//执行task,当任务执行完毕，还需要去队列中获取任务继续执行</span><br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout,timeUnit)) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;准备执行任务&quot;</span>+task);<br>                    task.run();<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (threads)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程被移除&quot;</span>+<span class="hljs-built_in">this</span>);<br>                threads.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt;&#123;<br>    <span class="hljs-comment">//创建任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//每次只能有一个线程成功取得队头任务，所以取任务的时候需要加锁</span><br>    <span class="hljs-comment">// 没有获得锁的线程只能等待获取下一个任务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">//生产者条件遍历（休息室）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//队列中能容纳的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-comment">//外界定义队列的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//线程们阻塞获取任务</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//队列空就等待，无法获取任务</span><br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            <span class="hljs-comment">//唤醒生产任务的线程，使之继续生产</span><br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//带超时的等待</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span>(queue.isEmpty())&#123;<br>                <span class="hljs-comment">//将超时时间转换为纳秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//返回值是剩余等待时间，超时就不等了，不用永久等待了</span><br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            <span class="hljs-comment">//唤醒生产任务的线程，使之继续生产</span><br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时时间的阻塞添加，超时后任务就不等了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task,<span class="hljs-type">long</span> timeout,TimeUnit timeUnit)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span>(queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//队列满就等待，无法继续生产任务</span><br>                    System.out.println(<span class="hljs-string">&quot;等待加入队列....&quot;</span>);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;任务对象加入阻塞队列&quot;</span>+task);<br>            queue.addLast(task);<br>            <span class="hljs-comment">//添加完就应该唤醒获得任务的进程</span><br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞添加任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//队列满就等待，无法继续生产任务</span><br>                    System.out.println(<span class="hljs-string">&quot;等待加入队列....&quot;</span>);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;任务对象加入阻塞队列&quot;</span>+task);<br>            queue.addLast(task);<br>            <span class="hljs-comment">//添加完就应该唤醒获得任务的进程</span><br>            emptyWaitSet.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//外界获取队列元素个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(rejecctPolicy&lt;T&gt; rejectpolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(queue.size() == capacity)&#123;<br>                rejectpolicy.reject(<span class="hljs-built_in">this</span>,task);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;任务对象加入阻塞队列&quot;</span>+task);<br>                queue.addLast(task);<br>                <span class="hljs-comment">//添加完就应该唤醒获得任务的进程</span><br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-线程核心基础</title>
    <link href="/2022/03/24/Java/JUC/%E7%BA%BF%E7%A8%8B%E5%85%AB%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/24/Java/JUC/%E7%BA%BF%E7%A8%8B%E5%85%AB%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-线程和进程的区别"><a href="#1-线程和进程的区别" class="headerlink" title="1.线程和进程的区别"></a>1.线程和进程的区别</h1><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h1 id="2-实现多线程的方法"><a href="#2-实现多线程的方法" class="headerlink" title="2.实现多线程的方法"></a>2.实现多线程的方法</h1><p><font color='blue'>这是Thread类中的run()方法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.target != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.target.run();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>下面两个创建线程的方法都是</p><h2 id="2-1-实现Runnable接口"><a href="#2-1-实现Runnable接口" class="headerlink" title="2.1 实现Runnable接口"></a>2.1 实现Runnable接口</h2><p>实现Runnbale接口，必须重写run()方法，在run方法中定义需要执行的任务。然后创建一个Thread类，将实现类传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableStyle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【用Runnable，线程被创建....】&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableStyle</span>());<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：【用Runnable，线程被创建….】</p><p>Thread.start()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.threadStatus != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.group.add(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.start0();<br>                started = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!started) &#123;<br>                        <span class="hljs-built_in">this</span>.group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>this.start0();</code>可以看出来是这句话真正创建了线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>可是深入进去这个方法是一个本地方法，是由c&#x2F;c++编写的，供JVM调用。所以<code>Thread.start()</code>将线程启动后，在底层代码中，JVM将会自动回调<code>Thread.run()</code>方法。由于实现Runnable接口后，将实现类的实例传到Thread的构造器中，<code>Runnable target;</code>  这个target就是这个实例，因此在Thread.run() 中实际上又调用了我们重写的run()方法，因此会有这样的输出结果。</p><p><em>Thread.run() 源码：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.target != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.target.run();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-继承Thread类"><a href="#2-2-继承Thread类" class="headerlink" title="2.2 继承Thread类"></a>2.2 继承Thread类</h2><p>直接继承Thread类来重写run()方法，最终这个重写的run()方法体的内容将会直接覆盖父类run()方法中的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStyle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;继承thread类，线程被创建...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">threadStyle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadStyle</span>();<br>        threadStyle.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>实现Runnable接口创建线程是<strong>优于</strong>继承Thread创建线程。</p><ul><li>java不支持多继承，一个类只能继承一个父类，如果已经继承了Thread类的话，就不能再继承其他类了，大大限制了可扩展性。</li><li><em>实现Runnable接口比较节约资源。——有待考证，不太理解</em></li><li>从代码架构的角度，使用接口有利于降低程序间的耦合度，线程具体要执行的任务与线程的整个生命周期相关的代码应该解耦，因为线程的生命周期相关的方法是start()、线程阻塞，线程终止等，这是由Thread类所管理的，他们目的不一样，所以应该解耦。</li></ul><h2 id="2-3-创建线程的错误观点"><a href="#2-3-创建线程的错误观点" class="headerlink" title="2.3 创建线程的错误观点"></a>2.3 创建线程的错误观点</h2><p>以下这些，仅仅是在代码层面的千变万化，但其本质是万变不离其宗的。</p><p><strong>1.线程池创建线程</strong></p><p>本质是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>.group, r, <span class="hljs-built_in">this</span>.namePrefix + <span class="hljs-built_in">this</span>.threadNumber.getAndIncrement(), <span class="hljs-number">0L</span>);<br></code></pre></td></tr></table></figure><p><strong>2.通过Callable和FutureTask创建线程</strong></p><p><img src="/image/juc/1.png"></p><p><img src="/image/juc/2.png"></p><p><strong>3.定时器创建线程</strong></p><p>本质是Thread thread &#x3D; new Thread(…..)</p><p><strong>4.匿名类部类，lambda表达式</strong></p><h2 id="2-4-有多少种实现线程的方法"><a href="#2-4-有多少种实现线程的方法" class="headerlink" title="2.4 有多少种实现线程的方法"></a>2.4 有多少种实现线程的方法</h2><p>从不同的角度看，会有不同的答案。</p><p>1.两种本质实现方法</p><p>实现Runnable接口和继承Thread类，比较他们的优缺点，通过看源代码，发现其实他们的本质是一样的，都是通过Thread的构造方法来创建一个新线程</p><p>2.几种代码实现方法</p><p>其他的外在表现形式的本质还是通过thread类创建线程</p><h1 id="3-启动线程"><a href="#3-启动线程" class="headerlink" title="3.启动线程"></a>3.启动线程</h1><p>只有start()方法是启动线程的方法，<strong>会经历线程的各个生命周期</strong>。</p><p>在当前线程（一般是主线程）中创建新线程对象，主线程执行start()方法，start()方法内的本地方法start0()会通知JVM在有空闲的情况下去运行这个线程，不过至于这个线程何时去运行，由线程调度器决定，所以这个线程可能稍后或者很久都不运行。</p><p>不能重复执行start()方法，因为第一次调用过后，线程状态会被改变，在第二次再执行start()后，线程状态就不是初始的创建的状态了。</p><p>如果直接调用run()方法的话，它就是一个普通的方法，最终的线程还是主线程，并没有做通知虚拟机等相关操作，并不能执行新线程。所以必须由虚拟机回调这个方法才可以</p><h1 id="4-停止线程"><a href="#4-停止线程" class="headerlink" title="4.停止线程"></a>4.停止线程</h1><p>如果<strong>没有外界干涉</strong>的情况下，线程通常的停止过程：</p><ol><li>run()方法执行完毕</li><li>有一点异常出现，但没有被捕获</li></ol><p>在有外界干涉的情况下，正确停止线程的方法是使用<code>interrupt</code>，好处：数据安全，并且我们要把主动权交给被中断线程。</p><p><strong>原理：</strong>使用interrupt来<strong>通知</strong>，而不是<strong>强制</strong>。</p><h3 id="4-1停止线程的几种情况"><a href="#4-1停止线程的几种情况" class="headerlink" title="4.1停止线程的几种情况"></a>4.1停止线程的几种情况</h3><ol><li>当线程处于正在运行时（不处于阻塞状态），使用interrupt停止线程，如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RigthWayToStopThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)&#123;<br>            <span class="hljs-comment">//当前线程是否响应中断取决于线程内的代码逻辑是否响应这个中断，如果不响应就可以继续运行。</span><br>            <span class="hljs-comment">//本例中，当接收到中断信号时，就会响应中断，这是人为编写的</span><br>            <span class="hljs-keyword">if</span>(Thread.currentThread().interrupted())&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i + <span class="hljs-string">&quot; &quot;</span>+Thread.currentThread().getName());<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程停止了&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">RigthWayToStopThread</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RigthWayToStopThread</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现当这个线程可以响应到停止信号，就会停止运行。</p><ol start="2"><li>当线程处于阻塞时，使用interrupt停止线程：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RigthWayToStopThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().interrupted())&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i + <span class="hljs-string">&quot; &quot;</span>+Thread.currentThread().getName());<br>            &#125;<br>        &#125;<br>            System.out.println(<span class="hljs-string">&quot;线程停止&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">RigthWayToStopThread</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RigthWayToStopThread</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>        <span class="hljs-comment">// Thread.sleep(500);</span><br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><p>这种情况就和第一点的一样了，线程正在运行的时候被停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打印i的值和线程名称...省略</span><br>线程停止<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>第二种情况是由于使用sleep语句时需要try catch将这个异常捕捉，所以当使用Interrupt停止线程时，此时正处于sleep阻塞状态，这个interrupt信号会被catch住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打印i的值和线程名称...省略</span><br>java.lang.InterruptedException: sleep interrupted<br>at java.base/java.lang.Thread.sleep(Native Method)<br>at juc.thread.RigthWayToStopThread.run(RigthWayToStopThread.java:<span class="hljs-number">20</span>)<br>at java.base/java.lang.Thread.run(Thread.java:<span class="hljs-number">834</span>)<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ol start="3"><li>每次迭代的过程都阻塞</li></ol><p>把sleep语句放到for循环内，（阻塞时间大于每次的运行时间）每次阻塞的时候，如果有interrupt信号，都会被catch捕捉到异常。也不需要  **if(Thread.currentThread().interrupted()){    break;  } **语句了</p><p>sleep的try catch 一旦响应中断，便会把中断标志位清除，回到没有被中断的状态。</p><h3 id="4-2-处理中断的方法"><a href="#4-2-处理中断的方法" class="headerlink" title="4.2 处理中断的方法"></a>4.2 处理中断的方法</h3><ol><li><p>优先选择：<strong>传递中断</strong>。catch了InterruptedExcetion之后，在方法签名中抛出异常，在底层方法中不能把异常吞了！！</p><p>当run()方法调用了一个方法a()，而a中有try catch相关的内容捕获停止信号，当一个线程想要停止run()对应的线程，a()方法感知到了interrupt信号，会捕获异常，但是会把interrupt标志位清除，所以run()方法还是可以正常运行，a方法的catch打印了中断信息也不会被发现。</p><p>正确的方法是a方法在方法签名中抛出这个异常，让run处理这个异常，可以是保存日志等等….</p></li><li><p>无法或不想传递中断：<strong>恢复中断</strong></p><p>在catch子句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便在后序的执行中，依然能够检查到刚才的中断。</p></li><li><p>不应屏蔽中断</p></li></ol><h3 id="4-3-哪些方法可以响应中断"><a href="#4-3-哪些方法可以响应中断" class="headerlink" title="4.3 哪些方法可以响应中断"></a>4.3 哪些方法可以响应中断</h3><p>响应中断指当中断信号发出时，这些方法可以感知到这个中断，并捕获。</p><p>wait()  sleep()  join() 等等</p><h3 id="4-4-错误的停止方法"><a href="#4-4-错误的停止方法" class="headerlink" title="4.4 错误的停止方法"></a>4.4 错误的停止方法</h3><ol><li><p>stop，suspend，resume方法</p><p>**stop()**来停止线程会导致线程运行一半突然停止，没办法完成一个基本单位的操作，会造成脏数据。 stop是不安全的。</p></li><li><p>volatile设置boolean标记位</p><p>无法处理长时间阻塞的情况</p></li></ol><h1 id="5-线程的生命周期"><a href="#5-线程的生命周期" class="headerlink" title="5.线程的生命周期"></a>5.线程的生命周期</h1><p><img src="/image/juc/3.png"></p><p>补充：当线程刚刚被唤醒时，由于唤醒它的线程持有这个锁，因此线程不能立刻获得到锁，因此会进入BLOCKED阶段，如果在wait阶段被中断，会直接进入终止状态。</p><h2 id="5-1-NEW"><a href="#5-1-NEW" class="headerlink" title="5.1 NEW"></a>5.1 NEW</h2><p>初始状态，线程被构建，但是还没有调用start()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSixStatus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(i+<span class="hljs-string">&quot; &quot;</span>+Thread.currentThread().getName());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadSixStatus</span> <span class="hljs-variable">threadSixStatus</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSixStatus</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadSixStatus);<br>        System.out.println(thread.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">NEW<br></code></pre></td></tr></table></figure><p>可见刚刚创建的线程的状态是NEW，没有start()启动线程，所以不会运行Runnable接口实现类的run()方法。</p><h2 id="5-2-RUNNABLE-可运行的-运行中的"><a href="#5-2-RUNNABLE-可运行的-运行中的" class="headerlink" title="5.2 RUNNABLE(可运行的&#x2F;运行中的)"></a>5.2 RUNNABLE(可运行的&#x2F;运行中的)</h2><p>运行状态，java线程将操作系统中的<strong>就绪</strong>和<strong>运行</strong>两种状态笼统的称为“运行中”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSixStatus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(i+<span class="hljs-string">&quot; &quot;</span>+Thread.currentThread().getName());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadSixStatus</span> <span class="hljs-variable">threadSixStatus</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSixStatus</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadSixStatus);<br>        System.out.println(thread.getState());<br>        thread.start();<br>        System.out.println(thread.getState());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(thread.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">NEW<br>RUNNABLE<br><span class="hljs-number">0</span> Thread-<span class="hljs-number">0</span><br><span class="hljs-number">1</span> Thread-<span class="hljs-number">0</span><br><span class="hljs-number">2</span> Thread-<span class="hljs-number">0</span><br>  ......<br><span class="hljs-number">707</span> Thread-<span class="hljs-number">0</span><br>RUNNABLE<br>  ......<br><span class="hljs-number">999</span> Thread-<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>thread.start();之后，线程就处于RUNNABLE状态，这时如果被分到了CPU，就运行，没有被分到CPU，就处于就绪状态，等会，当开始运行时，jvm会调用run()方法，输出上面的内容。</p><h2 id="5-3-BLOCKED"><a href="#5-3-BLOCKED" class="headerlink" title="5.3 BLOCKED"></a>5.3 BLOCKED</h2><p>阻塞状态，表示线程阻塞于锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSixStatus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        syn();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadSixStatus</span> <span class="hljs-variable">threadSixStatus</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSixStatus</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadSixStatus);<br>        thread1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadSixStatus);<br>        thread2.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;thread1的状态：&quot;</span>+thread1.getState());<br>        System.out.println(<span class="hljs-string">&quot;thread2的状态：&quot;</span>+thread2.getState());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syn</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">thread1的状态：TIMED_WAITING<br>thread2的状态：BLOCKED<br></code></pre></td></tr></table></figure><p>这是由于线程1先被启动，然后进入syn()方法中，就会处于睡眠10s的状态，由于main函数中获取线程1状态前睡眠10ms，所以当获取线程1的状态时，线程1一定处于睡眠，所以是TIMED_WAITING，而此时线程1拿着syn()方法的锁，线程2无法运行syn()方法，只能阻塞自身等待锁，所以是BLOCKED</p><h2 id="5-4-WAITING"><a href="#5-4-WAITING" class="headerlink" title="5.4 WAITING"></a>5.4 WAITING</h2><p>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特性动作，如通知或中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSixStatus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        syn();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadSixStatus</span> <span class="hljs-variable">threadSixStatus</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSixStatus</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadSixStatus);<br>        thread1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadSixStatus);<br>        thread2.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;thread1的状态：&quot;</span>+thread1.getState());<br>        System.out.println(<span class="hljs-string">&quot;thread2的状态：&quot;</span>+thread2.getState());<br>        System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;thread1的状态：&quot;</span>+thread1.getState());<br>        System.out.println(<span class="hljs-string">&quot;thread2的状态：&quot;</span>+thread2.getState());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syn</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;线程进入到wait等待&quot;</span>);<br>            wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">thread1的状态：TIMED_WAITING<br>thread2的状态：BLOCKED<br>-------------<br>线程进入到wait等待<br>thread1的状态：WAITING<br>thread2的状态：TIMED_WAITING<br>线程进入到wait等待<br></code></pre></td></tr></table></figure><p>这说明线程1先进入WAITING状态，然后会释放这个锁，线程2拿到锁后进入sleep，休眠时间过了之后也会进入WAITING状态，此时控制台显示程序并没有停止运行，注意框住的部分。</p><p><img src="/image/juc/4.png"></p><h2 id="5-5-TIMED-WAITING"><a href="#5-5-TIMED-WAITING" class="headerlink" title="5.5 TIMED_WAITING"></a>5.5 TIMED_WAITING</h2><p>超时 &#x2F; 计时等待状态，该状态不同于WAITING,它是可以在指定时间自行返回的。</p><p>看BLOCKED中的代码。</p><h2 id="5-6-TERMINATED"><a href="#5-6-TERMINATED" class="headerlink" title="5.6 TERMINATED"></a>5.6 TERMINATED</h2><p>终止状态，表示当前线程已经执行完毕。线程的run()方法、call()方法正常执行完毕或者线程抛出一个未捕获的异常(Exception)、错误(Error)，线程就进入终止状态。一旦进入终止状态，线程将不再拥有运行的资格，也不能再转换到其他状态，生命周期结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSixStatus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(i+<span class="hljs-string">&quot; &quot;</span>+Thread.currentThread().getName());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadSixStatus</span> <span class="hljs-variable">threadSixStatus</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSixStatus</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadSixStatus);<br>        System.out.println(thread.getState());<br>        thread.start();<br>        System.out.println(thread.getState());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(thread.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1s钟程序一定执行完毕了，所以打印线程状态是TERMINATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">  ......<br><span class="hljs-number">999</span> Thread-<span class="hljs-number">0</span><br>TERMINATED<br></code></pre></td></tr></table></figure><p>阻塞状态：一般把Blocked(被阻塞)、Waiting(等待)、Timed_waiting(计时等待)都称为阻塞状态。</p><h1 id="6-Thread类的重要方法详解"><a href="#6-Thread类的重要方法详解" class="headerlink" title="6.Thread类的重要方法详解"></a>6.Thread类的重要方法详解</h1><h2 id="6-1-sleep"><a href="#6-1-sleep" class="headerlink" title="6.1 sleep()"></a>6.1 sleep()</h2><p>线程sleep的时候不释放lock以及synchronized的monitor锁，等sleep时间到了以后，线程正常结束后才释放锁。</p><p>sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间再执行，休眠期间如果被中断，会抛出异常并清除中断状态。</p><p><code>TimeUnit.SECONDS.sleep(1);</code>比<code>Thread.sleep()</code>更优雅</p><p>sleep()不需要放在同步代码块中。</p><h2 id="6-2-join"><a href="#6-2-join" class="headerlink" title="6.2.join()"></a>6.2.join()</h2><p>当有新的子线程加入时，子线程调用jion()，主线程会等子线程执行完毕后再往下运行，如果子线程不调用这个方法，当它还没执行完的时候，主线程就会继续执行。</p><p><strong>当join()的时候主线程的状态是WAIT</strong>，一个线程去等待另一个线程</p><p>下面的代码就说明了主线程不一定会等子线程执行完再执行，因为start()方法启动线程，线程不一定立刻就获得到CPU资源。如果在子线程中slepp，那主线程应该是第一个执行完，然后才是子线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">join</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;执行&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：<strong>（这个顺序具有随机性）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>开始执行<br>main执行<br>Thread-<span class="hljs-number">1</span>开始执行<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果加入了join()</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">join</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始执行&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            t1.join();<br>            t2.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;执行&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：<strong>（一定是这个顺序）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">1</span>开始执行<br>Thread-<span class="hljs-number">0</span>开始执行<br>main执行<br></code></pre></td></tr></table></figure><p><strong>当join()期间遇到中断是什么情况？</strong></p><p>是主线程被中断，抛出异常。最好将异常抛出给子线程。</p><h2 id="6-3-yield"><a href="#6-3-yield" class="headerlink" title="6.3 yield()"></a>6.3 yield()</h2><p>yield()的作用是<code>让步</code>，会让线程释放CPU时间片，但是线程的状态还是Runnable。</p><p>它能够让当前线程从“运行状态”进入到“就绪状态”，从而让其他等待线程获取执行权，但是不能保证在当前线程调用yield()之后，其他线程就一定能获得执行权，也有可能是当前线程又回到“运行状态”继续运行</p><h1 id="7-Object类的重要方法详解"><a href="#7-Object类的重要方法详解" class="headerlink" title="7.Object类的重要方法详解"></a>7.Object类的重要方法详解</h1><p>Object类是所有对象的父类，所有对象都可以调用以下的方法。</p><p>wait()和notify()必须放在synchronized代码块中，如果不通过同步块包住的话，JVM会抛出<code>IllegalMonitorStateException</code>异常。</p><h2 id="7-1-wait"><a href="#7-1-wait" class="headerlink" title="7.1 wait()"></a>7.1 wait()</h2><p><img src="/image/juc/waitSet.png"></p><p><strong>某个线程必须拥有对象的monitor锁才可以调用wait()方法</strong>，并且这个线程调用后会进入WAITING阻塞状态。</p><p><code>一旦调用了wait方法会释放这个对象锁，该线程会进入休息室WaitSet，等待有人唤醒</code></p><p><strong>什么情况下会被唤醒？</strong></p><ol><li>另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程。</li><li>另一个线程调用这个对象的notifyAll()方法</li><li>过了wait(long timeout)规定的超时时间，但是如果传入0就是永久等待</li><li>线程遇到中断，即调用了interrupt()，发生中断</li></ol><h2 id="7-2-notify"><a href="#7-2-notify" class="headerlink" title="7.2 notify()"></a>7.2 notify()</h2><p>notify()只会唤醒单个正在阻塞的线程，这个线程会重新转为就绪状态，等待虚拟机分配CPU，如果有多个线程在等待，<code>它只会选取其中一个去唤醒，选取规则由虚拟机去实现</code>。</p><h2 id="7-3-notifyAll"><a href="#7-3-notifyAll" class="headerlink" title="7.3 notifyAll()"></a>7.3 notifyAll()</h2><p>会唤醒所有阻塞的线程。</p><hr><p><code>wait()和notify()相互作用</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitAndNotify</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitAndNotify1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (object)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;获得了锁&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;将要阻塞，会释放锁&quot;</span>);<br>                    object.wait();<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;再次获得了锁&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitAndNotify2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (object)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;得到了锁&quot;</span>);<br>                object.notify();<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;已经唤醒了一个阻塞线程，它可能一会就获得锁&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">waitAndNotify1</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitAndNotify1</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w1);<br>        thread1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">waitAndNotify2</span> <span class="hljs-variable">w2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitAndNotify2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w2);<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">线程Thread-<span class="hljs-number">0</span>获得了锁<br>线程Thread-<span class="hljs-number">0</span>将要阻塞，会释放锁<br>线程Thread-<span class="hljs-number">1</span>得到了锁<br>线程Thread-<span class="hljs-number">1</span>已经唤醒了一个阻塞线程，它可能一会就获得锁<br>线程Thread-<span class="hljs-number">0</span>再次获得了锁<br></code></pre></td></tr></table></figure><p><code>notify()和notifyAll()的区别</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitAndNotify</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitAndNotify1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (object1)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;获得了object1锁&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;将要阻塞，会释放object1锁&quot;</span>);<br>                    object1.wait();<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;再次获得了object1锁，将要运行结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitAndNotify2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (object1)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;获得了object1锁&quot;</span>);<br>                object1.notifyAll();<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;已经唤醒object1对象锁的全部阻塞线程&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">waitAndNotify1</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitAndNotify1</span>();<br>        <span class="hljs-type">waitAndNotify1</span> <span class="hljs-variable">w3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitAndNotify1</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w1);<br>        thread1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w3);<br>        thread3.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">waitAndNotify2</span> <span class="hljs-variable">w2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitAndNotify2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w2);<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">线程Thread-<span class="hljs-number">0</span>获得了object1锁<br>线程Thread-<span class="hljs-number">0</span>将要阻塞，会释放object1锁<br>线程Thread-<span class="hljs-number">1</span>获得了object1锁<br>线程Thread-<span class="hljs-number">1</span>将要阻塞，会释放object1锁<br>线程Thread-<span class="hljs-number">2</span>获得了object1锁<br>线程Thread-<span class="hljs-number">2</span>已经唤醒object1对象锁的全部阻塞线程<br>线程Thread-<span class="hljs-number">0</span>再次获得了object1锁，将要运行结束<br>线程Thread-<span class="hljs-number">1</span>再次获得了object1锁，将要运行结束<br></code></pre></td></tr></table></figure><p>entry set：入口集</p><p>wait set：等待集</p><p><img src="/image/juc/6.png"></p><h2 id="7-4-使用wait-和notify-模拟生产者消费者模式"><a href="#7-4-使用wait-和notify-模拟生产者消费者模式" class="headerlink" title="7.4 使用wait()和notify()模拟生产者消费者模式"></a>7.4 使用wait()和notify()模拟生产者消费者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerAndCustomer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BlockedQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockedQueue</span>();<br>        <span class="hljs-type">Producer</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(queue);<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(queue);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(p);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(c);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    BlockedQueue queue;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(BlockedQueue queue)</span>&#123;<br>        <span class="hljs-built_in">this</span>.queue = queue;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            queue.in();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    BlockedQueue queue;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">(BlockedQueue queue)</span>&#123;<br>        <span class="hljs-built_in">this</span>.queue = queue;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            queue.take();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockedQueue</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; list;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockedQueue</span><span class="hljs-params">()</span>&#123;<br>        maxSize = <span class="hljs-number">10</span>;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(list.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;消费者拿到【&quot;</span>+list.get(<span class="hljs-number">0</span>)+<span class="hljs-string">&quot;】,仓库还剩&quot;</span>+(list.size() - <span class="hljs-number">1</span>)+<span class="hljs-string">&quot;件&quot;</span>);<br>        list.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">this</span>.notify();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(list.size() == maxSize)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>  String.valueOf(System.currentTimeMillis());<br>        list.add(num);<br>        System.out.println(<span class="hljs-string">&quot;生产者生产了【&quot;</span>+num+<span class="hljs-string">&quot;】仓库里有&quot;</span>+list.size()+<span class="hljs-string">&quot;件东西&quot;</span>);<br>        <span class="hljs-built_in">this</span>.notify();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">1</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">2</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">3</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">4</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">5</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">6</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">7</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">8</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">9</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">10</span>件东西<br>仓库满啦..生产者等待 <br>消费者拿到【<span class="hljs-number">1647305874352</span>】,仓库还剩<span class="hljs-number">9</span>件<br>消费者拿到【<span class="hljs-number">1647305874352</span>】,仓库还剩<span class="hljs-number">8</span>件<br>消费者拿到【<span class="hljs-number">1647305874352</span>】,仓库还剩<span class="hljs-number">7</span>件<br>消费者拿到【<span class="hljs-number">1647305874352</span>】,仓库还剩<span class="hljs-number">6</span>件<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">7</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">8</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">9</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874352</span>】仓库里有<span class="hljs-number">10</span>件东西<br>仓库满啦..生产者等待 <br>    .........<br>仓库空啦..消费者等待<br>生产者生产了【<span class="hljs-number">1647305874362</span>】仓库里有<span class="hljs-number">1</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874362</span>】仓库里有<span class="hljs-number">2</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874362</span>】仓库里有<span class="hljs-number">3</span>件东西<br>生产者生产了【<span class="hljs-number">1647305874362</span>】仓库里有<span class="hljs-number">4</span>件东西<br>消费者拿到【<span class="hljs-number">1647305874362</span>】,仓库还剩<span class="hljs-number">3</span>件<br>消费者拿到【<span class="hljs-number">1647305874362</span>】,仓库还剩<span class="hljs-number">2</span>件<br>消费者拿到【<span class="hljs-number">1647305874362</span>】,仓库还剩<span class="hljs-number">1</span>件<br>消费者拿到【<span class="hljs-number">1647305874362</span>】,仓库还剩<span class="hljs-number">0</span>件<br>仓库空啦..消费者等待<br>    ....<br></code></pre></td></tr></table></figure><h1 id="8-wait-、notify-、sleep-的异同"><a href="#8-wait-、notify-、sleep-的异同" class="headerlink" title="8.wait()、notify()、sleep()的异同"></a>8.wait()、notify()、sleep()的异同</h1><ul><li>相同点：阻塞、响应中断、清除中断标志位</li><li>不同点：是否被包括在同步方法中、是否释放锁、是否必须指定时间、所属类是哪个</li></ul><h1 id="9-线程的各个属性"><a href="#9-线程的各个属性" class="headerlink" title="9.线程的各个属性"></a>9.线程的各个属性</h1><p><img src="/image/juc/thread.png"></p><ol><li><code>线程id</code>的那个属性初始值是0，但是获取前会被加1，所以第一个线程也就是主线程main的id是1，后面的子线程依次增加。</li><li><code>线程名字</code>可以通过Thread类中的setName方法来设置，也可以不设置，使用默认的Thread-number，number从0开始，每次加1</li><li><code>守护线程</code>：服务于用户线程的，不影响jvm的退出。</li><li><code>线程优先级</code>：java虚拟机中，有10个级别，默认是5。一般是将java虚拟机中的优先级映射到操作系统上的优先级，不同的操作系统优先级范围级别可能不同，所以我们不要随意改变优先级，否则导致映射后的优先级不符合我们的预期。优先级也可能会被操作系统改变</li></ol><h1 id="10-线程安全问题"><a href="#10-线程安全问题" class="headerlink" title="10.线程安全问题"></a>10.线程安全问题</h1><h2 id="10-1-共享的成员变量和静态变量"><a href="#10-1-共享的成员变量和静态变量" class="headerlink" title="10.1 共享的成员变量和静态变量"></a>10.1 共享的成员变量和静态变量</h2><p>根据它们的状态是否能够改变，分两种情况</p><ul><li>如果只有读操作，则线程安全 </li><li>如果有读写操作，则这段代码是<strong>临界区</strong>，需要考虑线程安全</li></ul><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></p><h2 id="10-2-死锁、活锁、饥饿"><a href="#10-2-死锁、活锁、饥饿" class="headerlink" title="10.2 死锁、活锁、饥饿"></a>10.2 死锁、活锁、饥饿</h2><p><code>死锁</code>：每个线程都不放弃自己的锁，同时也期望得到对方的锁。</p><p>死锁可以通过线程按照相同的顺序获取锁来解决，但是这样会产生饥饿。</p><p><strong>死锁的例子</strong>，注意一下，object1和object2必须是static的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dead</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰。</span><br>    <span class="hljs-comment">//因为静态成员变量是存储方法 区内存中，而且只会存在一份数据。</span><br>    <span class="hljs-comment">//非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(flag);<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (object1)&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了object1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (object2)&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了object2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (object2)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了object2&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (object1)&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了object1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>   &#123;<br>        <span class="hljs-type">dead</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dead</span>();<br>        <span class="hljs-type">dead</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dead</span>();<br>        d1.flag = <span class="hljs-number">0</span>;<br>        d2.flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d2);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>死锁的例子：<strong>哲学家就餐问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    chopsticks left;<br>    chopsticks right;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name,chopsticks left,chopsticks right)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.right = right;<br>        <span class="hljs-built_in">this</span>.left = left;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;拿上筷子&quot;</span> + left.name + <span class="hljs-string">&quot;,&quot;</span> + right.name + <span class="hljs-string">&quot;开始吃饭..&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(name + <span class="hljs-string">&quot;放下筷子&quot;</span> + left.name + <span class="hljs-string">&quot;,&quot;</span> + right.name + <span class="hljs-string">&quot;开始思考..&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c1&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c2&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c3&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c4&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c5&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家1&quot;</span>,c1,c2);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家2&quot;</span>,c2,c3);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家3&quot;</span>,c3,c4);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家4&quot;</span>,c4,c5);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家5&quot;</span>,c5,c1);<br>        p1.start();<br>        p2.start();<br>        p3.start();<br>        p4.start();<br>        p5.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">chopsticks</span>&#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">chopsticks</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name  = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">哲学家<span class="hljs-number">3</span>拿上筷子c3,c4开始吃饭..<br>哲学家<span class="hljs-number">1</span>拿上筷子c1,c2开始吃饭..<br>哲学家<span class="hljs-number">3</span>放下筷子c3,c4开始思考..<br>哲学家<span class="hljs-number">3</span>拿上筷子c3,c4开始吃饭..<br>哲学家<span class="hljs-number">1</span>放下筷子c1,c2开始思考..<br>哲学家<span class="hljs-number">5</span>拿上筷子c5,c1开始吃饭..<br>哲学家<span class="hljs-number">5</span>放下筷子c5,c1开始思考..<br>哲学家<span class="hljs-number">5</span>拿上筷子c5,c1开始吃饭..<br>哲学家<span class="hljs-number">3</span>放下筷子c3,c4开始思考..<br>哲学家<span class="hljs-number">5</span>放下筷子c5,c1开始思考..<br></code></pre></td></tr></table></figure><p>此时已经发生了死锁，线程处于BLOCKED状态。</p><h2 id="10-3-活锁"><a href="#10-3-活锁" class="headerlink" title="10.3 活锁"></a>10.3 活锁</h2><p><code>活锁</code>：两个线程互相改变对方的结束条件，最终谁也无法结束。都处于Runnable状态。</p><p>比如当两个线程同时改变一个共享变量，它的初始值是10，并且线程1结束运行的条件是这个变量大于0，线程2运行的结束条件是这个变量小于20，</p><h2 id="10-4-饥饿"><a href="#10-4-饥饿" class="headerlink" title="10.4 饥饿"></a>10.4 饥饿</h2><p><code>饥饿</code>：一个线程由于优先级太低，始终得不到CPU调度执行，也不能结束。</p><h2 id="10-5-对象发布和初始化"><a href="#10-5-对象发布和初始化" class="headerlink" title="10.5 对象发布和初始化"></a>10.5 对象发布和初始化</h2><p>发布是让其他类可以访问到这个变量，就是把这个变量发布。</p><p>逸出是不让其他类可见的变量被其他类访问，或者改变它的值。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-顺序&amp;交替输出</title>
    <link href="/2022/03/24/Java/JUC/%E4%BA%A4%E6%9B%BF%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BA/"/>
    <url>/2022/03/24/Java/JUC/%E4%BA%A4%E6%9B%BF%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a>固定运行顺序</h1><p><code>问题：先打印2后打印1</code></p><ol><li>使用wait()和notify()组合</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shunxu</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//2还没有打印</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span>(!flag)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br><br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                flag = <span class="hljs-literal">true</span>;<span class="hljs-comment">//2已经打印了</span><br>                lock.notify();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>        thread.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用park()和unpark()组合</li></ol><p>park()和unpark()以线程为单位来阻塞和唤醒线程，而notify只能随机唤醒一个线程。</p><p><img src="/image/juc/park.png"></p><ul><li><p>先调用park()，再调用unpark()：如果counter&#x3D;0，则线程进入阻塞队列，调用unpark()，counter&#x3D;1，线程继续运行，再次赋值counter&#x3D;0</p></li><li><p>先调用unpark()，再调用park()：线程正在运行，赋值counter&#x3D;1，调用park()，赋值counter&#x3D;0，线程不停止运行。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shunxu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>            LockSupport.unpark(thread);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>        thread.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h1><p><code>问题：交替输出abc，假设循环5次，则输出结果是abcabcabcabcabc</code></p><ol><li>使用wait()&amp;notify()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shunxu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">waitnotify</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitnotify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            a1.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            a1.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            a1.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>        &#125;).start();<br>    &#125;<br><br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">waitnotify</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">waitnotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-built_in">this</span>.num = num;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> nextflag)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>                <span class="hljs-keyword">while</span>(!(flag == <span class="hljs-built_in">this</span>.flag))&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                <span class="hljs-built_in">this</span>.flag = nextflag;<br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用ReentrantLock，创建多个休息室，先让所有线程进入休息室等待，主线程唤醒一个线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shunxu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-type">waitnotify</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitnotify</span>(<span class="hljs-number">5</span>,lock);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            a1.print(<span class="hljs-string">&quot;a&quot;</span>,c1,c2);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            a1.print(<span class="hljs-string">&quot;b&quot;</span>,c2,c3);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            a1.print(<span class="hljs-string">&quot;c&quot;</span>,c3,c1);<br>        &#125;).start();<br><br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            c1.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br><br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">waitnotify</span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">static</span> ReentrantLock lock;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">waitnotify</span><span class="hljs-params">(<span class="hljs-type">int</span> num,ReentrantLock lock)</span>&#123;<br>        <span class="hljs-built_in">this</span>.num = num;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition c1,Condition c2)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                c1.await();<br>                System.out.print(str);<br>                c2.signal();<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li><code>三个线程交替输出1~99</code></li></ol><p>重点在于设置volatile保证共享变量的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//3个线程交替打印 1  2  3</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">parctice</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">waitNotify</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitNotify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            w.print(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            w.print(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            w.print(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">waitNotify</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> res;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">waitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> res)</span>&#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.res = res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> nextflag)</span>&#123;<br>        <span class="hljs-keyword">while</span>(res &lt; <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>                <span class="hljs-keyword">while</span>(!(flag == <span class="hljs-built_in">this</span>.flag))&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">99</span>)&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;[&quot;</span>+res+<span class="hljs-string">&quot;]&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>                    res++;<br>                    <span class="hljs-built_in">this</span>.flag = nextflag;<br>                    notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-jdk提供的线程池</title>
    <link href="/2022/03/24/Java/JUC/%E5%AE%98%E6%96%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/03/24/Java/JUC/%E5%AE%98%E6%96%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/juc/jdkthread.png"></p><h1 id="1-线程池的状态"><a href="#1-线程池的状态" class="headerlink" title="1.线程池的状态"></a>1.线程池的状态</h1><p>ThreadPoolExecutor使用int的高三位表示线程池的状态，低29为表示线程数量。</p><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>高三位111表示的是负数：- 3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">29</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> <span class="hljs-number">536870911</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">536870912</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">536870912</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">1073741824</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1610612736</span>;<br></code></pre></td></tr></table></figure><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p><h1 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h1><h2 id="2-1-最全的"><a href="#2-1-最全的" class="headerlink" title="2.1 最全的"></a>2.1 最全的</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数<ul><li>maximumPoolSize - corePoolSize &#x3D; 救急线程数</li></ul></li><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）<ul><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的 SynchronousQueue</li><li>优先队列 PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul><p><strong>救急线程</strong>就是当核心线程都在处理任务，并且阻塞队列里已经满了的时候，如果再来一个任务，急救线程就会被创建，来处理这个任务，当超过救急线程空闲时的最大生存时间，它会被释放。（当阻塞队列有容量限制时才可以使用救急线程）</p><p><strong>拒绝策略</strong>：如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li><li>CallerRunsPolicy：让调用者运行任务</li><li>DiscardPolicy：放弃本次任务</li><li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li></ul><h2 id="2-2-newFixedThreadPool"><a href="#2-2-newFixedThreadPool" class="headerlink" title="2.2 newFixedThreadPool"></a>2.2 newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>用法：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>(), threadFactory);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法可以给线程起名字。</p><h2 id="2-3-newCachedThreadPool"><a href="#2-3-newCachedThreadPool" class="headerlink" title="2.3 newCachedThreadPool"></a>2.3 newCachedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>用法：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p><h3 id="2-4-newSingleThreadExecutor"><a href="#2-4-newSingleThreadExecutor" class="headerlink" title="2.4 newSingleThreadExecutor"></a>2.4 newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Executors</span>.FinalizableDelegatedExecutorService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>()));<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>用法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br></code></pre></td></tr></table></figure><p>线程数固定为1，不能修改，没有急救线程，当任务数多于1时会放入无界队列排队，任务执行完毕这个线程也不会释放。</p><h1 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3.提交任务"></a>3.提交任务</h1><p><img src="/image/juc/jdkthread2.png"></p><h1 id="4-定时执行任务"><a href="#4-定时执行任务" class="headerlink" title="4.定时执行任务"></a>4.定时执行任务</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-1-schedule"><a href="#4-1-schedule" class="headerlink" title="4.1 schedule()"></a>4.1 schedule()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">pool.schedule(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;任务1执行...&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<span class="hljs-comment">//延时1s之后执行</span><br>pool.schedule(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;任务2执行...&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<span class="hljs-comment">//延时1s之后执行</span><br></code></pre></td></tr></table></figure><p>（无论核心线程数是1还是更多）一旦第一个任务执行受到了异常，第二个任务也不会受到影响，还是会被执行。</p><h2 id="4-2-scheduleAtFixedRate"><a href="#4-2-scheduleAtFixedRate" class="headerlink" title="4.2 scheduleAtFixedRate()"></a>4.2 scheduleAtFixedRate()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pool.scheduleAtFixedRate(()-&gt;&#123;&#125;,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>以固定速率执行任务</p><p>第一个参数是任务对象，第二个参数是<code>针对当前时间来说，延时的时间</code>（主线程调用这个方法后，多长时间后才开始工作），第三个参数是执行间隔（每隔这么长时间就执行一次任务，一直执行）</p><p>当一个任务的执行时间超过了执行间隔，就等这个任务执行完后立刻执行下一个任务，不会让任务重叠。</p><p>假如每个任务执行需要耗时2s，执行间隔是1s，明显已经超过了执行间隔，每个任务之间的时间是2s，就是任务执行时间。</p><h2 id="4-3-scheduleWithFixedDelay"><a href="#4-3-scheduleWithFixedDelay" class="headerlink" title="4.3 scheduleWithFixedDelay()"></a>4.3 scheduleWithFixedDelay()</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">pool.scheduleWithFixedDelay(<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>&#123;&#125;,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>第三个参数是执行间隔（这个是真正的间隔，严格意义上每个任务之间都必须有这个间隔时间），其他的参数和上面的那个方法一样</p><p>假如每个任务执行需要耗时2s，再加上执行间隔1s，每个任务之间的时间是3s</p><p><img src="/image/juc/jdkthread4.png"></p><h1 id="5-结束任务"><a href="#5-结束任务" class="headerlink" title="5.结束任务"></a>5.结束任务</h1><h2 id="5-1-shutdown"><a href="#5-1-shutdown" class="headerlink" title="5.1 shutdown()"></a>5.1 shutdown()</h2><p>线程池状态变为<code>SHUTDOWN</code>，不会接收新任务， 但已经提交的任务（在阻塞队列中）会执行完，调用这个方法的线程在运行完这一行会继续往后执行，不会等待线程全部SHUTDOWN之后再往后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>pool.shutdown();<br></code></pre></td></tr></table></figure><h2 id="5-2-shutdownNow"><a href="#5-2-shutdownNow" class="headerlink" title="5.2 shutdownNow()"></a>5.2 shutdownNow()</h2><p>线程池状态变为<code>STOP</code>，不会接收新任务，会将队列中的任务返回，不再执行，并用interrupt的方式中断正在执行的线程。（夺笋那）</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-ReentrantLock</title>
    <link href="/2022/03/24/Java/JUC/ReentrantLock/"/>
    <url>/2022/03/24/Java/JUC/ReentrantLock/</url>
    
    <content type="html"><![CDATA[<p>相对于synchronized，它具备：</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量（多个休息室）</li></ul><p>它和synchronized一样支持可重入</p><p>基本语法格式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">//获取锁</span><br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//临界区</span><br>    System.out.println(<span class="hljs-string">&quot;t1获得锁&quot;</span>);<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//释放锁</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1-可重入"><a href="#1-可重入" class="headerlink" title="1.可重入"></a>1.可重入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        m1();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;进入了m1&quot;</span>);<br>            m2();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;进入了m2&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-可中断的"><a href="#2-可中断的" class="headerlink" title="2.可中断的"></a>2.可中断的</h1><p>被动，必须由其他线程执行那个打断方法才能让这个线程不死等下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);<br>                <span class="hljs-comment">//获得了锁，此时可以被其他线程打断</span><br>                lock.lockInterruptibly();<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                System.out.println(<span class="hljs-string">&quot;被打断&quot;</span>);<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            thread.start();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>        thread.interrupt();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="3-锁超时"><a href="#3-锁超时" class="headerlink" title="3.锁超时"></a>3.锁超时</h1><p>一旦超时，就自动退出阻塞队列，不等了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>            System.out.println(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);<br>            <span class="hljs-comment">//尝试获得锁，如果没有获得，会进入阻塞队列，等待1秒，如果还没有获得到锁就不等了</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS))&#123;<br>                    System.out.println(<span class="hljs-string">&quot;等了1s，获取不到锁，退出&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        lock.lock();<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        thread.start();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>可以使用锁超时解决哲学家就餐问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> juc.thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> qq</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2022/3/16</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    chopsticks left;<br>    chopsticks right;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name,chopsticks left,chopsticks right)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.right = right;<br>        <span class="hljs-built_in">this</span>.left = left;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-keyword">if</span>(left.tryLock())&#123;<br>               <span class="hljs-keyword">try</span>&#123;<br>                   <span class="hljs-keyword">if</span>(right.tryLock())&#123;<br>                       <span class="hljs-keyword">try</span>&#123;<br>                           eat();<br>                       &#125;<span class="hljs-keyword">finally</span> &#123;<br>                           right.unlock();<br>                       &#125;<br>                   &#125;<br>               &#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//只有左手筷子，则会放下筷子</span><br>                   left.unlock();<br>               &#125;<br>           &#125;<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;拿上筷子&quot;</span> + left.name + <span class="hljs-string">&quot;,&quot;</span> + right.name + <span class="hljs-string">&quot;开始吃饭..&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(name + <span class="hljs-string">&quot;放下筷子&quot;</span> + left.name + <span class="hljs-string">&quot;,&quot;</span> + right.name + <span class="hljs-string">&quot;开始思考..&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c1&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c2&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c3&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c4&quot;</span>);<br>        <span class="hljs-type">chopsticks</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">chopsticks</span>(<span class="hljs-string">&quot;c5&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家1&quot;</span>,c1,c2);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家2&quot;</span>,c2,c3);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家3&quot;</span>,c3,c4);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家4&quot;</span>,c4,c5);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;哲学家5&quot;</span>,c5,c1);<br>        p1.start();<br>        p2.start();<br>        p3.start();<br>        p4.start();<br>        p5.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">chopsticks</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">chopsticks</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name  = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4.条件变量"></a>4.条件变量</h1><p>创建新的条件变量：<code>Condition c1 = lock.newCondition();</code>  <code>Condition c2 = lock.newCondition();</code></p><p>阻塞前必须先获得锁：<code>lock.lock();</code></p><p>进入休息室等待：<code>c1.await();</code></p><p>由其他线程唤醒这个休息室中的线程：<code>c1.signal();</code></p><h1 id="5-原理"><a href="#5-原理" class="headerlink" title="5.原理"></a>5.原理</h1><h2 id="5-1-构造器"><a href="#5-1-构造器" class="headerlink" title="5.1 构造器"></a>5.1 构造器</h2><p>默认实现是非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>.NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-加锁"><a href="#5-2-加锁" class="headerlink" title="5.2 加锁"></a>5.2 加锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.sync.acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">//调用同步器类的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.tryAcquire(arg) &amp;&amp; <span class="hljs-built_in">this</span>.acquireQueued(<span class="hljs-built_in">this</span>.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), arg)) &#123;<br>        selfInterrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>this.tryAcquire(arg)</code>：尝试去加锁，如果加锁成功就不会进入if语句块，如果加锁失败，尝试创建一个Node对象，将这个线程关联到这个Node对象上，让这个线程进入Node阻塞队列</p><p><img src="/image/juc/jdkthread5.png"></p><p>灰色表示线程正式被阻塞，三角形内的-1表示这个Node对象关联的线程有责任去唤醒它的后继结点，处于链表尾部的节点上面的三角形值是0，它不需要唤醒任何节点</p><p><img src="/image/juc/jdkthread6.png"></p><h2 id="5-3-释放锁"><a href="#5-3-释放锁" class="headerlink" title="5.3 释放锁"></a>5.3 释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.tryRelease(arg)) &#123;<br>        <span class="hljs-comment">//队列中的头结点，那个虚拟节点</span><br>        AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//唤醒后继节点</span><br>            <span class="hljs-built_in">this</span>.unparkSuccessor(h);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有其他新的线程来竞争，那队列的第一个有线程关联的节点的线程就成功获得锁。</p><p><img src="/image/juc/jdkthread7.png"></p><p>但是如果有新的线程来竞争，就不一定谁获得锁了，如果这时队列中第一个线程没有成功获得锁，就需要继续阻塞等待。</p><p><img src="/image/juc/jdkthread8.png"></p><h2 id="5-4-锁重入"><a href="#5-4-锁重入" class="headerlink" title="5.4 锁重入"></a>5.4 锁重入</h2><p><strong>重入获得锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取当前锁的状态，为0表示还没有被任何线程持有</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//将状态改为1，说明有线程获得了锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            <span class="hljs-comment">//将锁的持有者改为current线程</span><br>            <span class="hljs-built_in">this</span>.setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//当前线程就是锁的持有者</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == <span class="hljs-built_in">this</span>.getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-comment">//state++</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>重入释放锁：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != <span class="hljs-built_in">this</span>.getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//c为0表示线程完全释放了锁</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">this</span>.setExclusiveOwnerThread((Thread)<span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-可打断"><a href="#5-5-可打断" class="headerlink" title="5.5 可打断"></a>5.5 可打断</h2><p><code>lock.lock();</code>默认是不可打断的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(AbstractQueuedSynchronizer.Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-built_in">this</span>.head &amp;&amp; <span class="hljs-built_in">this</span>.tryAcquire(arg)) &#123;<br>                <span class="hljs-built_in">this</span>.setHead(node);<br>                p.next = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br><span class="hljs-comment">//如果有线程打断，只是把中断标志位设置为true</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node)) &#123;<br>                interrupted |= <span class="hljs-built_in">this</span>.parkAndCheckInterrupt();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;<br>        <span class="hljs-comment">//没有捕捉中断异常...</span><br>        <span class="hljs-built_in">this</span>.cancelAcquire(node);<br>        <span class="hljs-keyword">if</span> (interrupted) &#123;<br>            selfInterrupt();<br>        &#125;<br><br>        <span class="hljs-keyword">throw</span> var5;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>lock.lockInterruptibly();</code>：默认是可打断的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.tryAcquire(arg)) &#123;<br>            <span class="hljs-built_in">this</span>.doAcquireInterruptibly(arg);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        AbstractQueuedSynchronizer.Node p;<br>        <span class="hljs-keyword">do</span> &#123;<br>            p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-built_in">this</span>.head &amp;&amp; <span class="hljs-built_in">this</span>.tryAcquire(arg)) &#123;<br>                <span class="hljs-built_in">this</span>.setHead(node);<br>                p.next = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span>(!shouldParkAfterFailedAcquire(p, node) || !<span class="hljs-built_in">this</span>.parkAndCheckInterrupt());<br><span class="hljs-comment">//如果有线程打断就会退出上面的循环，并抛出这个中断异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>        <span class="hljs-built_in">this</span>.cancelAcquire(node);<br>        <span class="hljs-keyword">throw</span> var4;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-条件变量"><a href="#5-6-条件变量" class="headerlink" title="5.6 条件变量"></a>5.6 条件变量</h2><p>每个条件变量就对应着一个等待队列，实现类是ConditionObject（是AbstractQueuedSynchronizer的内部类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Condition</span> <span class="hljs-variable">waitSet1</span> <span class="hljs-operator">=</span> lock.newCondition();<br>waitSet1.await();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">waitSet2</span> <span class="hljs-operator">=</span> lock.newCondition();<br>waitSet2.await();<br></code></pre></td></tr></table></figure><p><code>await();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//将线程关联一个节点，并将它加入到这个阻塞队列中</span><br>        AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.addConditionWaiter();<br>        <span class="hljs-comment">//将线程上所有的锁都释放掉，因为锁是可重入的，所以要全部释放</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>.fullyRelease(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(!AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>.isOnSyncQueue(node)) &#123;<br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> ((interruptMode = <span class="hljs-built_in">this</span>.checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>.acquireQueued(node, savedState) &amp;&amp; interruptMode != -<span class="hljs-number">1</span>) &#123;<br>            interruptMode = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.unlinkCancelledWaiters();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.reportInterruptAfterWait(interruptMode);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/juc/jdkthread11.png"></p><p><code>signal()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>.isHeldExclusively()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//每次取的都是队列的第一个</span><br>        AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.doSignal(first);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doSignal()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(AbstractQueuedSynchronizer.Node first)</span> &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.lastWaiter = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">while</span>(!AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>.transferForSignal(first) &amp;&amp; (first = <span class="hljs-built_in">this</span>.firstWaiter) != <span class="hljs-literal">null</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/juc/jdkthread9.png"></p><p><img src="/image/juc/jdkthread10.png"></p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>juc</tag>
      
      <tag>并发编程</tag>
      
      <tag>ReentrantLock锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-自顶向下</title>
    <link href="/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/ComputerNetWork/%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/ComputerNetWork/%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>计算机网络中的协议</strong></p><p>[TOC]</p><h1 id="1-应用层协议"><a href="#1-应用层协议" class="headerlink" title="1.应用层协议"></a>1.应用层协议</h1><p>🚀🎈🏆💬👍❤️💪😂👌😑😓⚡👴🏻⭐❓🥳❗️✔️❌🙏</p><p>定义了运行在不同端系统上的应用程序进程如何相互传递报文。位于应用层的信息分组称为<strong>报文</strong>。</p><p>各层的所有协议被称为协议栈。</p><p>应用层协议定义了：</p><p><img src="/../../../image/protocol/%E5%8D%8F%E8%AE%AE.png" alt="协议"></p><h2 id="1-1-HTTP协议⭐"><a href="#1-1-HTTP协议⭐" class="headerlink" title="1.1 HTTP协议⭐"></a>1.1 HTTP协议⭐</h2><p>HTTP协议是基于TCP&#x2F;IP协议之上的应用层协议。HTTP默认端口号为80。它也可以承载在TLS和SSL之上，通过加密、认证的方式实现数据传输的安全，称为HTTPS，HTTPS默认端口号为443。</p><h3 id="1-1-1-工作原理"><a href="#1-1-1-工作原理" class="headerlink" title="1.1.1 工作原理"></a>1.1.1 工作原理</h3><p>当客户端输入一个URL后，HTTP协议就开始运作了。HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文。服务器以一个响应报文作为响应。</p><h3 id="1-1-2-请求报文格式"><a href="#1-1-2-请求报文格式" class="headerlink" title="1.1.2 请求报文格式"></a>1.1.2 请求报文格式</h3><p>请求行和首部行编码为ASCII码。请求体根据header中的Content-Type规定body里采用什么编码。</p><h4 id="1-1-2-1-请求行-request-line"><a href="#1-1-2-1-请求行-request-line" class="headerlink" title="1.1.2.1 请求行(request line)"></a>1.1.2.1 请求行(request line)</h4><p><strong>字段：请求方法  URI  协议</strong></p><p>①GET：  GET  &#x2F;books&#x2F;?sex&#x3D;man&amp;name&#x3D;Professional  HTTP&#x2F;1.1 或 GET  &#x2F;index.html  HTTP&#x2F;1.1</p><p>用来获取&#x2F;查询资源，请求访问指定服务器上的资源。直接在浏览器中键入网址搜索的方式，其请求方法就是GET，当浏览器请求一个对象时，在URL字段中会包含这个对象的标志，即GET请求的数据信息都在URL中，比如这个URI，books是访问服务器资源的路径，sex&#x3D;man&amp;name&#x3D;Professional 是请求参数信息，即浏览器要访问的对象。这就是GET方法的一个缺点，请求参数全部暴露在URL中，不安全。而且URL长度有限，无法包含许多请求参数。</p><p>②POST： POST  &#x2F;books&#x2F;some  HTTP&#x2F;1.1</p><p>用来提交表单。在form表单中，可以主动选择method为POST(当然也可以指定为GET)，一般POST不用来获取资源，而是向服务器提交&#x2F;上传资源，比如提交用户数据验证登录用户、上传文件之类的。一般这些请求参数都放到请求体中。</p><p>③HEAD：HEAD  &#x2F;index.html  HTTP&#x2F;1.1</p><p>获得报文首部。和GET方法一样，只是HEAD只返回首部，即响应报文仅包含首部信息，HEAD一般是开发者用来进行调试跟踪，用于确认 URI 的有效性及资源更新的日期时间。</p><p>④PUT：PUT  &#x2F;books&#x2F;some  HTTP&#x2F;1.1</p><p>用于上传对象到指定的Web服务器上的指定路径。</p><p>感觉和POST有点相似，百度查了一下，发现POST不具有幂等性，而PUT具有幂等性。所谓幂等性，即对同一URL的一次和多次请求某一个资源应该具有同样的副作用（指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的）。当服务器上没有这个对象时，就创建这个对象，而当服务器上已经有这个对象时，就不会再次创建了，而是更新这个对象，所以在服务器上这个对象是唯一的。而非幂等性就是提交几次请求，就在服务器上创建几个相同的对象。</p><p>但是会产生安全问题，因为 HTTP&#x2F;1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件。而POST方法，当请求的资源被加密(就拿登录一个淘宝网页来说)，服务器会返回401响应，浏览器会弹出一个对话框，要求浏览器提交用户名、密码，用户在输入身份验证信息后提交到服务器，服务器验证成功后用户才可以进入他自己账号下的淘宝。</p><p>⑤DELETE：用于删除指定服务器上的指定路径的资源，但由于HTTP1.1对于这个方法也不具有验证机制，任何人都可以删除服务器上的内容，因此此方法也被视为是不安全的，一般很少用。</p><h4 id="1-1-2-2-首部行-header-line"><a href="#1-1-2-2-首部行-header-line" class="headerlink" title="1.1.2.2 首部行(header line)"></a>1.1.2.2 首部行(header line)</h4><p>①HOST：<a href="http://www.baicu.com/">www.baicu.com</a></p><p>表示请求对象所在的主机（在web高速缓存中有用）</p><p>②Connection：close</p><p>通知浏览器不使用持续连接，而是一个请求发送完之后就关闭这条连接。</p><p>补充：持续连接：HTTP中默认是持续连接，即Connection：keep-alive，服务器在发送完响应后保持该TCP的连接，在相同的客户和服务器之间，后序的请求和响应报文能通过相同的连接进行传送。  但如果一条连接一定时间没有使用就会自动断开。</p><p>③User-agent：Mozilla&#x2F;5.0 </p><p>用户代理（即浏览器的类型）。</p><p>④Accept：text&#x2F;html，application&#x2F;xhtml+xml，image&#x2F;webp</p><p>客户端可支持的数据类型（Content-Type），以MIME类型来表示。</p><p>⑤Accept-Language：zh-CN；en-US </p><p>客户端可以支持的语言。</p><p>⑥Accept-Encoding：gzip，deflate</p><p>客户端支持的服务器对响应数据的编码格式。</p><p>⑦Content-Type：application&#x2F;x-www-form-urlencoded</p><p>指定请求体的数据编码方式。</p><p>application&#x2F;x-www-form-urlencoded是form表单的默认编码方式，提交的数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，并放到请求体中。</p><p>⑧Content-Length：43</p><p>请求体的长度。</p><p>⑨Origin ：<a href="https://baidu.com/">https://baidu.com</a></p><p>用于指明当前请求来自于哪个站点。</p><p>⑩Cookie：JSESSIONID&#x3D;7BDD60BE24561687329E8DF0C63B0D</p><p>因为 HTTP 是无状态的连接，当会话结束后，在下一次会话中，服务器并不知道和上一次的是否是同一个用户，而且也并不会自动维护用户的上下文。所以当浏览器第一次请求这个服务器时，为了识别用户，服务端给每个第一次登录的用户生成一个唯一标识(session_id)和session，每一个 session_id 和一个session 值绑定在一起，这个值是用户信息加密后的字符串。第一次创建 session 的时候，服务端会在 HTTP 响应中告诉客户端 session_id 并存储在 cookie 字段中，浏览器会提取出这个值，然后以key：value的形式将这个值存储在本地，浏览器后续每次针对该网站的所有请求都会加上这个 session_id，每次服务端收到请求后，就能根据这个 session_id 来确定用户是谁，从而就可以将多次请求转发到同一个Web服务器上。</p><p>服务器生成一个session，并且将它保存在服务器上。<em>Session</em>对象存储特定用户会话所需的属性及配置信息。</p><p>cookie的有效期：看浏览器的设置吧，大概也就是一个月左右。session的有效期：对于用户来说，session的有效期是在浏览器从打开到关闭，对于服务器来说，默认是30分钟session自动销毁，但可以设置。</p><p><strong>Cookie 一般用来保存用户信息</strong>。<strong>Session 的主要作用就是通过服务端记录用户的状态</strong>。</p><p>⑪If-Modified-Since：Web，9  Sep 2015 09:23:24</p><p>缓存的数据的有效时间，即它还没有更新。</p><p>这个是代理缓存服务器向真正的Web服务器发送的查询请求的首部行中有的。首先浏览器向代理服务器发送请求，代理服务器向Web服务器查询 存到代理服务器中的请求对象是否被改变，这个字段的内容是上次修改的时间。</p><h4 id="1-1-2-3-请求体-entity-body"><a href="#1-1-2-3-请求体-entity-body" class="headerlink" title="1.1.2.3 请求体(entity body)"></a>1.1.2.3 请求体(entity body)</h4><p>(data…data..data…data…)</p><p>GET方法没有请求体，其请求参数都在URL中，POST的请求参数在请求体中。</p><h3 id="1-1-3-响应报文格式"><a href="#1-1-3-响应报文格式" class="headerlink" title="1.1.3 响应报文格式"></a>1.1.3 响应报文格式</h3><h4 id="1-1-3-1-状态行-status-line"><a href="#1-1-3-1-状态行-status-line" class="headerlink" title="1.1.3.1 状态行(status line)"></a>1.1.3.1 状态行(status line)</h4><p><strong>字段</strong>：协议  状态码        HTTP&#x2F;1.1  200</p><p><strong>状态码：</strong></p><p>200  OK：请求成功，信息在返回的响应报文中。</p><p>301 Moved Permanently ：请求的对象已经被永久转移了，新的URL定义在响应报文的Location首部行中，客户软件将自动获取新的URL。</p><p>400 Bad Request：一个通用的差错代码，指示该请求不能被服务器理解。</p><p>404 Not Found：被请求的文档不在服务器上。</p><p>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。</p><p><img src="/../../../image/protocol/%E7%8A%B6%E6%80%81%E7%A0%81.png"></p><h4 id="1-1-3-2-首部行-header-line"><a href="#1-1-3-2-首部行-header-line" class="headerlink" title="1.1.3.2 首部行(header line)"></a>1.1.3.2 首部行(header line)</h4><p>①Last-Modified：数据的最后更新时间</p><p>一般是Web服务器为了响应代理缓存器而生成的首部行</p><p>②Connection：close</p><p>首部行告诉客户，发完这个HTTP响应就关闭这个tcp连接</p><p>还有一个情况就是 Connection：keep-alive  </p><p>​keep-alive：timeout&#x3D;20</p><p>③：Content-Encoding：gzip</p><p>内容编码：服务器在发送响应报文时，可以对响应体进行编码，这样减少了传输的资源大小，加快了传输速率，并且也相当于对数据进行了加密。</p><table><thead><tr><th>编码格式</th><th>描述</th></tr></thead><tbody><tr><td>gzip</td><td>表明实体采用 GNU zip 编码</td></tr><tr><td>compress</td><td>表明实体采用 Unix 的文件压缩程序</td></tr><tr><td>deflate</td><td>表明实体采用 zlib 的格式压缩</td></tr><tr><td>identity</td><td>表明没有对实体进行编码。当没有 Content-Encoding 首部是，就默认为这种情况</td></tr></tbody></table><p>④Content-Length：40</p><p>如果消息体进行了内容编码，Content-Length 首部说明的就是编码后（encoded）的body的字节长度，而不是未编码的原始主体长度。字节数。。这个字段的好处：知道报文什么时候全部到达。</p><p>⑤Transfer-Encoding：chunked</p><p>在HTTP&#x2F;1.1中只有这一个值，表示分块传输。</p><blockquote><p>chunked编码使用若干个chunk串连而成，由一个标明长度为0的chunk标示结束。一个chunk块由头部和正文两部分组成，头部存的是这个块中正文部分（数据）的长度，CRLF，正文部分，CRLF。最后一个0的块的头部是0，CLRF，正文部分没有数据，CRLF。</p></blockquote><blockquote><p>Transfer-Encoding和Content-Length是不会同时出现的。Content-Length如果服务器端计算出错的话(因为报文长度经常是不可预测)，假设Content-Length小于响应体的总长度，则传输会被截断，如果大于，则无法判定当前响应已经结束，会将请求持续挂起。为了解决这一问题，产生了Transfer-Encoding</p></blockquote><p>⑥Server：Apache&#x2F;2.2.3</p><p>表明该报文是由一台Apache Web服务器产生的</p><p>⑦Last-Modified：表明对象创建或最后修改的时间和日期</p><p>⑧Content-Type：text&#x2F;html</p><p>说明实体体中的数据类型，以MIME规格定义的数据类型来表示。</p><p><img src="/../../../image/image/324.png" alt="324"></p><p>⑨Date：Tue，18 Aug 2015 15:44:04 GMT</p><p>表明服务器产生并发送这个响应报文的日期和时间。</p><h4 id="1-1-3-3-响应体-entity-body"><a href="#1-1-3-3-响应体-entity-body" class="headerlink" title="1.1.3.3 响应体(entity body)"></a>1.1.3.3 响应体(entity body)</h4><p>(data…data..data…data…)</p><h3 id="1-1-4-历史版本"><a href="#1-1-4-历史版本" class="headerlink" title="1.1.4 历史版本"></a>1.1.4 历史版本</h3><h4 id="1-1-4-1-HTTP-1-0"><a href="#1-1-4-1-HTTP-1-0" class="headerlink" title="1.1.4.1 HTTP&#x2F;1.0"></a>1.1.4.1 HTTP&#x2F;1.0</h4><p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。即默认使用短连接。非持续连接</p><h4 id="1-1-4-2-HTTP-1-1"><a href="#1-1-4-2-HTTP-1-1" class="headerlink" title="1.1.4.2 HTTP&#x2F;1.1"></a>1.1.4.2 HTTP&#x2F;1.1</h4><p><strong>1.长连接：</strong>HTTP 1.1支持持久连接（HTTP&#x2F;1.1的默认模式使用持续连接Connection：keep-alive），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</p><blockquote><p>HTTP&#x2F;1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。 —-javaguide</p></blockquote><p>但是流水线方式，虽然客户端可以在没有接受到服务器的响应报文就发送下一个请求报文，但是在服务器端要求必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 。</p><blockquote><p>若timeout时间内没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔一定时间发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。—-谢希仁</p></blockquote><p><strong>2.Host请求头字段：</strong>（必须有）有时候一个服务器主机提供多个服务，比如假设<a href="http://www.baidu.com、/">www.baidu.com、</a>  <a href="http://www.taobao.com/">www.taobao.com</a> 、<a href="http://www.jd.cm它们的服务器是同一个，那么这些域名对应的IP地址肯定是相同的，那我访问百度的网页，服务器怎么知道我访问的是百度呢？就通过host字段来区分。如果我们不传这个字段还会报一个400">www.jd.cm它们的服务器是同一个，那么这些域名对应的IP地址肯定是相同的，那我访问百度的网页，服务器怎么知道我访问的是百度呢？就通过host字段来区分。如果我们不传这个字段还会报一个400</a>(bad request)的状态码</p><p><strong>3.新增了一些请求方法：</strong>OPTIONS、PUT、DELETE、TRACE、CONNECT （也新增了一些头字段）</p><p><strong>4.新增了错误通知的状态码：</strong>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><p><strong>5.缓存处理：</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><h4 id="1-1-4-3-HTTP-2-0"><a href="#1-1-4-3-HTTP-2-0" class="headerlink" title="1.1.4.3 HTTP&#x2F;2.0"></a>1.1.4.3 HTTP&#x2F;2.0</h4><p><strong>1.二进制分帧：</strong>HTTP&#x2F;1.x都是基于文本的，而HTTP&#x2F;2.0是基于二进制六的。2.0引入了 帧（frame）和流（stream）。在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。http&#x2F;2.0把HTTP消息分解为更小的独立的帧，然后可以交错着通过一个tcp连接发送给服务器，在服务器端通过帧中的标识，重新把帧还原为HTTP请求报文。</p><p><strong>2.多路复用：</strong>由于HTTP&#x2F;1.1的长连接会产生队头阻塞，因此发明了多路复用机制。就是交错发送。</p><p>下面是采用流水线方式的长连接和多路复用的区别。</p><p><img src="/../../../image/protocol/http2.0.png" alt="协议"></p><p><strong>3.头部数据压缩</strong>：</p><p>在HTTP1.1中，HTTP请求和响应都是由请求行、首部行、请求体三部分组成。一般而言，请求体都会经过gzip压缩（根据首部行的Content-Encoding），或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</p><p>在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。</p><p><strong>4.服务器推送（server push）：</strong></p><p>推送技术是指通过客户端与服务器端建立长链接，客户端可以接收由服务器端不定时发送的消息。服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。（服务器向额外推送的话，会发送一个PUSH_PROMISE帧，帧中包含预推送资源的首部，如果客户端响应，说明它需要这个资源，服务器则会发送一个Data帧，包含推送的数据）。</p><h4 id="1-1-4-4-HTTPS"><a href="#1-1-4-4-HTTPS" class="headerlink" title="1.1.4.4 HTTPS"></a>1.1.4.4 HTTPS</h4><p>——-留坑——-看到https再填——–</p><h2 id="1-2-SMTP协议"><a href="#1-2-SMTP协议" class="headerlink" title="1.2 SMTP协议"></a>1.2 SMTP协议</h2><p>使用TCP可靠传输服务。代理1对应的服务器1所在端口是25，代理2对应的服务器所在的端口是110</p><p><strong>工作原理：</strong>用户代理1客户端向用户代理2客户端发送邮件，首先代理1会通过SMTP协议将邮件（其中携带着目的地的邮箱地址，即用户代理2对应的服务器）push给代理1对应的邮件服务器1，然后服务器1将邮件通过SMTP协议发送给代理2的邮件服务器，代理2通过POP3或IMAP协议从服务器2中pull邮件。</p><p><img src="/../../../image/protocol/SMTP.jpg" alt="324"></p><p><strong>SMTP协议与HTTP协议的区别：</strong></p><ol><li>SMTP是一个推协议，即将数据推给接收方。HTTP是一个拉协议，从接收方获取数据。</li><li>SMTP的报文必须是按照标准ASCII码编码，而HTTP报文的实体体不需要用ASCII码编码，而是根据首部行的Content-Type来编码。</li><li>SMTP将所有报文对象放在一个报文中，HTTP则是一个对象封装一个报文。</li></ol><h2 id="1-3-DNS协议"><a href="#1-3-DNS协议" class="headerlink" title="1.3 DNS协议"></a>1.3 DNS协议</h2><p>DNS请求和响应报文使用UDP数据报经过端口53发送。</p><h3 id="1-3-1-DNS层次结构"><a href="#1-3-1-DNS层次结构" class="headerlink" title="1.3.1 DNS层次结构"></a>1.3.1 DNS层次结构</h3><h4 id="1-3-1-1-根DNS服务器"><a href="#1-3-1-1-根DNS服务器" class="headerlink" title="1.3.1.1 根DNS服务器"></a>1.3.1.1 根DNS服务器</h4><p>根域：. </p><p>根域名服务器中有一个根域名列表，里面记载着顶级域名和对应的TLD服务器的IP地址）。</p><h4 id="1-3-1-2-TLD-DNS-服务器"><a href="#1-3-1-2-TLD-DNS-服务器" class="headerlink" title="1.3.1.2 TLD(DNS)服务器"></a>1.3.1.2 TLD(DNS)服务器</h4><p>顶级域比如：com、cn、net、edu等等</p><p>TLD服务器管理着注册在该顶级域下的所有二级域的权威DNS服务器的IP地址，即它提供了权威DNS服务器的IP地址。</p><h4 id="1-3-1-3-权威DNS服务器"><a href="#1-3-1-3-权威DNS服务器" class="headerlink" title="1.3.1.3 权威DNS服务器"></a>1.3.1.3 权威DNS服务器</h4><p>二级域比如：baidu.com、taobao.com、zzu.edu</p><p>权威DNS服务器管理着注册在该二级域下的所有三级&#x2F;四级域的主机的IP地址。三&#x2F;四级域有<a href="http://www.baidu.com、www.taobao.com、gaia.cs.umass.edu/">www.baidu.com、www.taobao.com、gaia.cs.umass.edu</a>      <strong>权威服务器下记录着主机的IP地址</strong></p><p><img src="/../../../image/protocol/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="协议"></p><h4 id="1-3-1-4-本地DNS服务器（不在DNS层次结构中）"><a href="#1-3-1-4-本地DNS服务器（不在DNS层次结构中）" class="headerlink" title="1.3.1.4 本地DNS服务器（不在DNS层次结构中）"></a>1.3.1.4 本地DNS服务器（不在DNS层次结构中）</h4><p>这个DNS服务器地址是通过在主机的这个位置设置的，常见的有电信、联通、谷歌、阿里等的本地 DNS 服务。当hosts文件中没有对应IP地址时，网络应用程序调用解析器（一段程序），解析器生成dns查询报文，通过协议栈将报文发送出去，这时发送的目的地就是主机上配置的dns服务器的地址。</p><p>自动获得DNS服务器地址：</p><p>这里分两种情况。1.你的电脑是直连运营商网络，即手机是4G网，电脑连接着手机的热点。这时候本地DNS服务器就是通过DHCP（系统）分配到的运营商的DNS服务器。2.你的电脑连接的是家里的WiFi，即通过路由器上网，这时候电脑如果想上网，需要先通过路由器，那么所有的DNS查询报文都会先经过路由器，然后再通过路由器向上层转发DNS报文。并且路由器执行DHCP服务，所以路由器就将它自己的IP地址分配给了主机的本地DNS服务器的IP地址。</p><p><img src="/../../../image/protocol/%E6%9C%AC%E5%9C%B0DNS.png" alt="协议"></p><h3 id="1-3-2-DNS记录和报文和缓存"><a href="#1-3-2-DNS记录和报文和缓存" class="headerlink" title="1.3.2 DNS记录和报文和缓存"></a>1.3.2 DNS记录和报文和缓存</h3><h4 id="1-3-2-1-资源记录（RR）"><a href="#1-3-2-1-资源记录（RR）" class="headerlink" title="1.3.2.1 资源记录（RR）"></a>1.3.2.1 资源记录（RR）</h4><p>所有DNS服务器寻出了资源记录，这些记录提供了主机名到IP地址的映射。资源记录是一个包含了下列字段的4元组：  （Name，Value，Type，TTL），其中TTL是资源记录应当从缓存中删除的时间（资源记录的生存时间）。</p><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>A</td><td>主机名（如<a href="http://www.baidu.com)/">www.baidu.com）</a></td><td>该主机名对应的IP地址（202.108.22.5）</td></tr><tr><td>NS</td><td>域（如com）</td><td>权威DNS服务器的主机名（它知道如何获取该域中主机IP地址）（如baidu.com）</td></tr><tr><td>CHAME</td><td>主机别名（如foo.com）</td><td>规范主机名（relay1.bar.foo.com）</td></tr><tr><td>MX</td><td>邮件服务器别名（如foo.com）</td><td>规范主机名（mail.bar.foo.com）</td></tr></tbody></table><p>获取除了邮件服务器以外的服务器主机的别名，DNS客户应该请求一条CHAME记录。</p><blockquote><p>对于Type&#x3D;NS，如果这个DNS服务器上有一条这样的记录，那必定也有一条A记录，该记录提供了再NS记录的Value字段中的权威DNS服务器的IP地址。比如，本地DNS服务器向根DNS服务器发送一个查询报文，查询gaia.cs.umass.edu的IP地址，但是根DNS服务器中没有该主机名的一条A记录，但是它有一条NS记录，（umass.edu，dns.umass.edu，NS），即umass.edu域的权威DNS服务器的主机名是dns.umass.edu。然后还有一条A记录，（dns.umass.edu，192.168.167.91，A）, 即根DNS服务器指定 则本地DNS服务器去dns.umass.edu服务器中查到了umass.edu域的IP地址，再接着去umass.edu域DNS服务器查询是否有主机的记录。</p><p>其实也可能dns.umass.edu中没有gaia.cs.umass.edu的IP地址，但是它有一条NS记录：（cs.umass.edu，dns.cs.umass.edu，NS），然后还有一条A记录，（dns.cs.umass.edu，192.168.167.91，A），即它知道cs.umass.edu域的权威服务器dns.cs.umass.edu的IP地址，它觉得dns.cs.umass.edu可能知道gaia.cs.umass.edu的IP地址。然后本地DNS服务器再向dns.cs.umass.edu查询，最终找到了一条包含主机名的A记录。</p><p>———————摘自 《自顶向下》。因为感觉对这个查询过程有点迷，就摘了两段理解了一下。</p></blockquote><h4 id="1-3-2-2-报文格式"><a href="#1-3-2-2-报文格式" class="headerlink" title="1.3.2.2 报文格式"></a>1.3.2.2 报文格式</h4><p><img src="/../../../image/protocol/DNS%E6%8A%A5%E6%96%87.png" alt="协议"></p><h4 id="1-3-2-3-DNS缓存"><a href="#1-3-2-3-DNS缓存" class="headerlink" title="1.3.2.3 DNS缓存"></a>1.3.2.3 DNS缓存</h4><p>首先是本地：<strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts</p><p>本地DNS服务器可以将之前收到的主机名到IP地址的映射缓存到它的本地存储器中，这样下次如果请求相同主机名的IP地址就直接查缓存就行了，缓存没有再进行迭代查询。</p><p>由于主机名和IP地址之间的映射不是永久的，所以DNS服务器在一段时间就将丢弃缓存的信息。</p><h3 id="1-3-3-查询方式"><a href="#1-3-3-查询方式" class="headerlink" title="1.3.3 查询方式"></a>1.3.3 查询方式</h3><p>递归查询和迭代查询。</p><p>区别：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。</p><p>可以从算法上面理解，做递归题时，⭐你永远要明白这个方法的作用并且相信它能完成这个任务⭐，所以你在第一层，向得到后面层的结果，就直接调用这个方法，相信它一定给你预期的完成结果，然后你仅仅拿到返回值之后再进行return或者什么操作就行了。对于DNS查询也是这样，第一层是请求主机去问本地DNS服务器，请求主机不管本地DNS服务器怎么操作，请求主机就相信本地DNS服务器一定能交给它那个IP地址，请求主机很省心。</p><p>对于迭代，就是需要自己通过一遍遍的运算，一步步找结果。即本地DNS服务器一个一个的去查IP地址，先查根DNS服务器，查到一个相关的结果，再去另一个地方查。</p><h3 id="1-3-4-负载均衡"><a href="#1-3-4-负载均衡" class="headerlink" title="1.3.4 负载均衡"></a>1.3.4 负载均衡</h3><p>当一个Web站点有冗余web服务器时（即同一个域名对应多个IP地址，这样做的目的是减小一个web服务器的访问负担），此时如果一个主机请求该站点的IP地址，DNS服务器会返回这个IP地址集合，但在每次的响应中循环这些地址的次序（轮询），因为客户端总是向IP地址排在最前面的服务器发送http请求报文。</p><p>但是轮询是有缺点的，如果某一个服务器出现故障，DNS服务器可不知道，会按照原样返回一定顺序的IP地址集合。所以这时候加入了负载均衡器，将该站点域名映射到负载均衡器上，DNS服务器只返回负载均衡器的IP地址，由负载均衡器来判断应该转发请求到哪个Web服务器上。</p><h3 id="1-3-5-DNS污染"><a href="#1-3-5-DNS污染" class="headerlink" title="1.3.5 DNS污染"></a>1.3.5 DNS污染</h3><blockquote><p>DNS污染：是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法。由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，则立即伪装成目标域名的DNS服务器给查询者返回虚假错误的IP地址。用户所访问的DNS服务器也会发送正确的数据包，但是由于虚假的IP数据包先到达主机，操作系统就会认为第一个是正确的，从而忽略后面的数据包。</p></blockquote><p>然后用户的本地DNS服务器上就有了一条这个域名与虚假IP地址的映射记录，在记录的有效期内，每次用户再访问这个站点时，本地DNS服务器就会将虚假的IP地址返回。</p><blockquote><p>DNS劫持：通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。这个解决方法是吧系统DNS的IP地址换成国外的DNS服务器的IP地址。</p></blockquote><h1 id="2-运输层协议"><a href="#2-运输层协议" class="headerlink" title="2.运输层协议"></a>2.运输层协议</h1><p>运输层协议为运行在不同主机进程之间提供了逻辑通信。</p><p>在发送端，运输层将从发送应用进程程序接收到的报文段转换成运输层分组，这个分组称为（运输层）<strong>报文段</strong>。🚀🎈🏆💬👍❤️💪😂👌😑😓⚡👴🏻</p><p>——有个问题？我看书上说当生成一个套接字时，就为他分配一个端口号这样的标志符。然后每个tcp头部封装的目的主机端口号其实是套接字的端口号。但是不是说进程有唯一的端口号吗，为什么套接字中目的进程端口号不是进程的端口号，而是目的套接字的端口号？而且多路复用和多路分解也是从套接字中收集报文和将所有报文定向发送进对应进程的对应的套接字中，然后进程再去套接字中取。难道进程套接字的端口号就是进程的端口号？</p><h2 id="2-1-UDP协议"><a href="#2-1-UDP协议" class="headerlink" title="2.1 UDP协议"></a>2.1 UDP协议</h2><h3 id="2-1-1-UDP报文段格式"><a href="#2-1-1-UDP报文段格式" class="headerlink" title="2.1.1 UDP报文段格式"></a>2.1.1 UDP报文段格式</h3><p><img src="/../../../image/protocol/UDP.png" alt="UDP"></p><p>源端口号和目的端口号都是16bit，所以端口号的可取范围是0<del>65535。周知端口号范围是0</del>1023，他们是保留给周知应用层协议使用的，不能被随意使用。</p><p>检验和：发送方的UDP对报文段中所有16bit的和进行反码运算，其实就是源端口号，目的端口号，长度三者相加，如果最高位溢出的话，把溢出的1加到第一位上，得到的结果放在检验和字段中。在接收方，将源端口号，目的端口号，长度，检验和四者相加，如果结果全为1则没有出错。</p><p>UDP既然不提供可靠传输，为什么还要提供检验和？因为不能保证源和目的之间的所有链路都提供差错检验机制。不过UDP只是做了运输协议能够做的最少的工作。</p><h3 id="2-1-2-使用UDP的原因"><a href="#2-1-2-使用UDP的原因" class="headerlink" title="2.1.2 使用UDP的原因"></a>2.1.2 使用UDP的原因</h3><blockquote><ol><li>分组首部开销少。UDP报文段首部仅有8字节，而TCP报文段首部有20字节的首部开销。</li><li>两个主机进行通信时无须先建立连接。TCP在开始数据传输之前需要三次握手，而UDP不需要任何准备即可进行数据传输，所以UDP不会引入建立连接的时延。</li><li>无连接状态。UDP不维护连接状态，也不跟踪这些参数。TCP在端系统中维护连接状态，这个连接状态包括接收发送缓存，拥塞控制参数，序号，确认号，比较麻烦。</li><li>对于从应用层收到的报文，UDP立即就可以发送，而无需考虑其他因素。而TCP有拥塞控制机制，如果当从源到目的之间的多条链路都很拥塞时，TCP会减小发送的速率，所以发送时延就增加了。但是UDP这样是有缺点的，没有拥塞控制机制，会造成UDP收发方之间的高丢包率，并且会挤垮TCP发送方。<em>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</em></li></ol></blockquote><h2 id="2-2-TCP协议🚀"><a href="#2-2-TCP协议🚀" class="headerlink" title="2.2 TCP协议🚀"></a>2.2 TCP协议🚀</h2><blockquote><p>参考：<a href="https://en.m.wikipedia.org/wiki/Transmission_Control_Protocol">https://en.m.wikipedia.org/wiki/Transmission_Control_Protocol</a></p></blockquote><h3 id="2-2-1-TCP报文段结构"><a href="#2-2-1-TCP报文段结构" class="headerlink" title="2.2.1 TCP报文段结构"></a>2.2.1 TCP报文段结构</h3><p><img src="/../../../image/protocol/TCP%E7%BB%93%E6%9E%84.png" alt="TCP结构"></p><p><strong>源端口号和目的端口号</strong>：16bits，指示源套接字的端口号和目的套接字的端口号。</p><p><strong>序号</strong>seq：32bits，如果设置了SYN&#x3D;1，则这个序号是初始序列号，是随机生成的。如果SYN&#x3D;0，则这是当前TCP报文段中的死一个数据字节的累积序列号。</p><p><strong>确认号</strong>ack：32bit，如果设置了ACK标志，则ack字段的值为发送方期望接收的下一个seq序号。</p><p><strong>数据偏移字段</strong>：4bits，指示TCP首部的长度，一般是20字节，即选项字段为空。最大是60字节，此时有选项字段，占40字节。</p><p>3bits的<strong>保留未用字段</strong>，设置为0。</p><p><strong>标志字段</strong>：9bits，在TCP连接和释放中的标志字段。</p><ul><li><p>NS：ECN-nonce - concealment protection</p></li><li><p>CWR：拥塞窗口缩减标志，由发送主机设置。因为接收主机在接收方到发送方的TCP ACK报文段中设置了ECE比特，所以发送主机收到这个报文段后，通过减半拥塞窗口来对一个具有ECE拥塞指示的ACK做出反应，并且在下一个发送的报文段中对CWR比特设置为1，以确认收到了拥塞指示回显</p></li><li><p>ECE：ECN-Echo，明确拥塞通告回显比特。在报文段传输的过程中（链路拥塞），ECN 感知路由器可以在 IP 报头中设置一个标记ECN&#x3D;11，而不是丢弃数据包，以表示即将发生拥塞。数据包到达接收方后，接收方将标志了拥塞指示回显ECE的TCP ACK报文段给发送方。</p></li><li><p>URG：表示 Urgent 指针字段有效，指示报文段中存在着被发送方的上层设置为紧急的数据。</p></li><li><p>ACK：表示确认字段ack中的值是有效的，即该报文段包括一个对已被接收报文段的确认。客户端发送的初始 SYN 数据包之后的所有数据包都应设置此标志。当ACK&#x3D;1时，确认号字段才有效。ACK&#x3D;0时，确认号无效。</p></li><li><p>PSH：推送功能。请求将缓冲的数据推送到接收应用程序。指示接收方应立即将缓冲中的数据交给上层。</p></li><li><p>RST：当接收方接收到的TCP SYN报文段，其源端口和源IP地址与目的主机上的所有套接字都不匹配，即接收到非法的TCP报文段，此时目的主机发送一个特殊重置报文段，这个TCP报文段中的RST标志位为1，指示发送主机不要再发送这个报文段了。</p></li><li><p>SYN：同步序列号。发送方和接收方的第一个数据包中的这个字段有效，表示是建立连接的报文段。</p></li><li><p>FIN：表示发送方要断开连接了，这是它的最后一个数据包。</p></li></ul><p>接收窗口：16bits，用来流量控制，表明接收方希望接收的字节数。</p><p>检验和：16bits，和udp 的是一个作用。</p><p>紧急指针：16bits，该字段指向紧急数据的最后一个字节。</p><p>选择字段：320bits，可选，用于发送方和接收方协商最大的报文段长度（MSS）（三次握手阶段协商）或者用作窗口调节因子时使用。一般不用</p><h3 id="2-2-2-TCP的连接和释放"><a href="#2-2-2-TCP的连接和释放" class="headerlink" title="2.2.2 TCP的连接和释放"></a>2.2.2 TCP的连接和释放</h3><h4 id="2-2-2-1-三次握手"><a href="#2-2-2-1-三次握手" class="headerlink" title="2.2.2.1 三次握手"></a>2.2.2.1 三次握手</h4><blockquote><p>TCP协议栈维护着两个socket缓冲区：send buffer和recv buffer。要通过TCP连接发送出去的数据都先拷贝到send buffer，即将http消息写入TCP协议栈的缓冲区中。这个缓冲区在TCP连接成功后就会被创建。</p></blockquote><ol><li><p>首先，客户端的TCP向服务器端的TCP发送一个TCP SYN报文段。这个报文段没有应用层数据，但是SYN字段被标志位1（表示是建立连接的报文段），SYN&#x3D;1，并且客户端会<strong>适当的随机生成</strong>一个初始序号ISN，即seq&#x3D;client_isn，放在序号字段中。发给服务器。</p></li><li><p>服务器接收到该报文段后，<strong>为该TCP创建缓存和变量</strong>，（但是如果客户端不发送ACK来完成第三次握手的话，通常在1min之后，服务器将终止该半开连接并释放资源），然后向客户端发送允许连接的报文段 SYN ACK报文段。这个报文段也没有应用层数据，SYN&#x3D;1，在TCP首部的确认号字段中ack&#x3D;client_isn+1，服务器选择自己的初始序号seq&#x3D;server_isn。</p><p>🎈ack&#x3D;seq+1的原因：ack指的是期望接收到下一个字节的编号；而客户端第一次发来的SYN报文段中不携带数据，（但是要消耗一个序号），当前报文段最后一个字节的编号还是client_isn,因此当前报文段最后一个字节的编号+1即为确认号。</p></li><li><p>在收到这个报文段后，<strong>客户端也要为该TCP连接分配缓存和变量</strong>。然后向服务器发送一个已收到服务器报文段的一个确认报文段。SYN&#x3D;0，seq&#x3D;client_isn+1，ack&#x3D;server_isn+1。这个报文段的数据字段里可以携带数据。</p></li></ol><p><strong>选择合适的ISN</strong>：TCP提供了可靠的字节流数据传输，它会为应用层的每个字节分配一个序列号，初始序号为ISN（Initial Sequence Number）的字节不是以0或1开头，而是由特定算法生成的，ISN值在[0, 2^32-1]范围内。TCP通信的两端需要交换对方的ISN来控制字节流的传输。交换ISN的过程称为TCP连接建立过程，也称为虚连接或虚电路建立过程。</p><p><strong>通信双方都交换ISN</strong>：发送方需要将IP数据包发送给接收方，但是它们可能不是按序到达的，那么接收方需要知道发送方发送的字节序号。</p><p>🍉TCP 为什么是三次握手，而不是两次或四次？</p><p>因为<strong>信道是不可靠的，但数据传输是必须可靠的</strong>。通信双方必须在通信前达成一致的数据传输信息，保证收到的数据的连续性，防止某一段数据中途丢失，比如客户端和服务器端的初始序号双方都要知道。</p><p>如果是两次握手，假如客户端发送一个SYN报文段，但是由于网络链路的阻塞，很长一段才到达服务器端，对于客户端来说这个报文早已失效，而服务器端认为是一个新的连接请求报文，因此会同意建立连接，并为这个TCP分配资源，在一定时间内一直等待客户端发来数据，因此服务器端的资源就浪费了。三次握手只能说是一个比较优的值，三次握手后就可以保证双方获得了互相的seq，四次握手又有点浪费了，三次就可以了。</p><blockquote><p>参考：TCP 为什么是三次握手，而不是两次或四次？ - wuxinliulei的回答 - 知乎 <a href="https://www.zhihu.com/question/24853633/answer/63668444">https://www.zhihu.com/question/24853633/answer/63668444</a></p></blockquote><h4 id="2-2-2-2-四次挥手"><a href="#2-2-2-2-四次挥手" class="headerlink" title="2.2.2.2 四次挥手"></a>2.2.2.2 四次挥手</h4><p>假设客户端先关闭连接</p><ol><li>客户应用进程发出一个关闭连接命令，因此客户端TCP模块箱服务器端发送一个TCP终止报文段，其中首部的标志位FIN&#x3D;1。</li><li>服务器端收到TCP报文段后，向客户端发送一个ACK确认报文。</li><li>接着服务器端向客户端发送一个终止报文，其中首部的标志位FIN&#x3D;1。</li><li>客户端收到TCP报文段后，向服务器端发送一个ACK确认报文。</li></ol><blockquote><p>在此期间本地端口不可用新连接；这可以防止在后续连接期间传送与先前连接相关联的延迟数据包时可能发生的混淆。</p><p>也可以通过 3 次握手来终止连接，此时主机 A 发送 FIN，主机 B 用 FIN &amp; ACK 回复（两步合二为一），主机 A 用 ACK 回复。</p></blockquote><img src="../../../image/protocol/TCP四次挥手.png"/><h4 id="2-2-2-3-TCP的生命周期"><a href="#2-2-2-3-TCP的生命周期" class="headerlink" title="2.2.2.3 TCP的生命周期"></a>2.2.2.3 TCP的生命周期</h4><p>客户TCP套接字一开始处于CLOSED的状态。客户端的应用程序发起一个新的TCP连接（应用程序调用调用socket，创建TCP套接字，分配端口号等等），然后这些信息传递给TCP协议栈，引起向服务器发送一个SYN报文段。在发送这个报文段的过程中，客户端TCP套接字进入SYN SENT状态，等待接收来自服务器端的SYN ACK报文段。当收到SYN ACK报文段后， 向服务器发送一个ACK报文段。客户端TCP套接字进入ESTABLISHED（已建立）状态。</p><p>对于服务器端，当服务器程序启动并读取配置文件完成初始化操作后，就会进入等待连接模块，在这个模块中，协议栈调用socket创建套接字，然后调用bind，将端口号写入套接字中，然后服务器TCP套接字就进入LISTEN状态，等待来自客户端的连接请求。当收到客户端的SYN报文段后，向客户端发送一个SYN ACK报文段，服务器TCP套接字进入SYN RECEIVED状态，等待ACK报文段。当收到ACK报文段后，服务器TCP套接字进入ESTABLISHED（已建立）状态。如果ACK报文段丢失，那么客户端会重传这个报文段，最终服务器端会收到ACK报文段，并进入ESTABLISHED（已建立）状态。</p><p>这时客户端和服务器端就能发送和接收包含有效载荷数据的TCP报文段了。（PS：第三次握手的时候客户端就可以在报文段中携带数据了）</p><p>——————发送数据—————-接收数据——————发送数据————–接收数据—————-</p><p>等到某个时刻，假设客户端应用程序要关闭连接。这时客户端发送一个FIN比特被置为1的报文段，TCP客户端套接字进入FIN WAIT 1 状态，等待来自服务器的确认的TCP报文段，当客户端收到该报文段后，TCP套接字进入FIN WAIT 2 状态，并等待来自服务器的FIN比特被置为1的TCP报文段，当收到服务器的FIN报文段后，客户端向服务器端发送一个确认报文段，然后套接字进入TIME WAIT 状态。如果携带ACK标志的报文丢失，客户端会重传。当经过了TIME WAIT时间后（一般是30s或1min或2min），客户端所有有关这个TCP连接的资源都被释放。连接终止，进入CLOSED状态。</p><p>当服务器端收到带有FIN比特被置为1的TCP报文段后，服务器端将会向客户端发送一个带有确认的TCP报文段，然后服务器TCP套接字进入CLOSE WAIT 状态，然后向客户端发送一个FIN比特被置为1的TCP报文段，然后服务器TCP套接字进入LAST ACK 状态，等待客户端的确认报文段。收到该报文段后，服务器端所有有关这个TCP连接的资源都被释放。连接终止，进入CLOSED状态。</p><p><img src="/../../../image/protocol/TCPsocket.png"></p><p><strong>TIME WAIT问题：</strong></p><p><strong>为什么客户端在发送过ACK报文段后，需要等待TIME WAIT时间后才彻底释放资源？</strong></p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/51961509">https://zhuanlan.zhihu.com/p/51961509</a></p></blockquote><ol><li>为了保证客户端发送的ACK报文段能到达服务器端。假如客户端再发送完确认的TCP报文段后就关闭了连接，而该报文段在传输过程中丢失了，服务器端会触发超时重传机制，再次向客户端发送FIN比特被置为1的TCP报文段，而此时客户端已经关闭了连接，这个TCP报文段被客户端视作一个非法的TCP报文段，客户端会向服务器端发送一个RST比特被置为1的TCP报文段，表示拒绝此次通信，以后也不要给他发送这个报文段。那么服务器就不能按正常步骤进入CLOSED状态。那么就会耗费服务器的资源。当网络中存在大量的LAST ACK状态，服务器最终会崩溃。</li><li>在第四次挥手后，经过TIME WAIT时间足以让在本次连接中产生的报文段都消失，而不会影响下一次的TCP连接。</li></ol><h3 id="2-2-3-差错控制"><a href="#2-2-3-差错控制" class="headerlink" title="2.2.3 差错控制"></a>2.2.3 差错控制</h3><p><strong>TCP的差错控制机制是GBN和SR的结合体。采用了SACK，与SR更像。</strong></p><h4 id="2-2-3-1-GBN回退N步"><a href="#2-2-3-1-GBN回退N步" class="headerlink" title="2.2.3.1 GBN回退N步"></a>2.2.3.1 GBN回退N步</h4><p>N为窗口长度，即   已发送但未被确认的（分组）序号+可用并且还未发送的（分组）序号 &#x3D; N </p><p>发送方：</p><ul><li>可以连续发送多个分组而不用等待确认。但是可以发送的分组数是有限制的，不能超过N个。</li><li>超时。定时器记录了第一个已发送未被确认分组的ACK报文段的到达时间，如果超时，则发送方将重传这个分组以及它后面已发送还未被确认的所有分组（因为GBN采用的是累积确认）</li><li>当收到第一个已发送未被确认的分组的ACK时，base++，窗口向后挪动一位。</li></ul><p>接收方：</p><p>由于GBN采用累计确认，所以接收方会丢弃所有到达的失序分组，不在缓存中存储失序分组。发送方需要将这些分组重传。如果分组k已接收并交付给应用层，那么所有序号比k小的分组都已经被接收。</p><p><img src="/../../../image/protocol/GBN.png"></p><h4 id="2-2-3-2-SR选择重传"><a href="#2-2-3-2-SR选择重传" class="headerlink" title="2.2.3.2 SR选择重传"></a>2.2.3.2 SR选择重传</h4><p>选择重传可以避免发送方重传不必要的分组。比如发送方正在发送0,1,2,3分组，1,2,3分组都已经收到接收方的ACK，但是分组0没有收到ACK，这有两种情况，1.分组0丢失，接收方没有收到。这时接收方收到的1,2,3分组都在TCP缓存中，发送方需要重传分组0，然后接收方发送ACK 0，并将连续的一段数据交付给上层（分组0的序号为接收窗口的基序号，该分组和以前缓存的起始于基序号的连续的分组一并交付）。2.分组0的ACK丢失或超时，发送方重传分组0，接收方丢弃，并发送一个ACK 0</p><h3 id="2-2-4-TCP流量控制"><a href="#2-2-4-TCP流量控制" class="headerlink" title="2.2.4 TCP流量控制"></a>2.2.4 TCP流量控制</h3><p>如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就可能使该连接的接受缓存溢出，后面到达的数据就不能被接收方接收。因此TCP提供了流量控制机制，避免缓存溢出。</p><blockquote><p><strong>发送方</strong>维护两个变量：LastByteSent和LastByteAcked。LastByteSent - LastByteAcked &#x3D; 发送方发送到连接中但还未被确认的数据量。LastByteSent - LastByteAcked &lt;&#x3D; rwnd</p><p><strong>接收方</strong>维护两个变量：LastByteRead和LastByteRcvd。LastByteRead表示接收方的应用程序从缓存中读取的数据流的最后一个字节编号，LastByteRcvd表示从网络中到达并已经放入接收方的接收缓存的数据流的最后一个字节编号。LastByteRcvd - LastByteRead &#x3D; 缓存中的TCP数据量，LastByteRcvd - LastByteRead &lt;&#x3D; RcvBuffer。接收窗口rwnd &#x3D; RcvBuffer - (LastByteRcvd - LastByteRead) 。接收窗口表示缓存中的剩余空间。</p><p>引用：《自顶向下》</p></blockquote><p>rwnd通过TCP报文首部的Windows size字段指出。当主机A创建一条到主机B的TCP连接后，主机B为这个连接创建一个缓存RcvBuffer，初始值为rwnd，然后通过TCP报文段首部的窗口字段将rwnd通知给主机A，A还可以发送的字节量。</p><p>当rwnd逐渐减小为0时，发送方因被阻塞而不能再发送数据，但是此时接收方也没有TCP数据段发送给发送方，rwnd的状态不能及时更新，发送方不能知道接收方的缓存什么时候有空余空间，双方进入了死锁状态。</p><p><em>当接收方宣布接收窗口的值为0，发送方停止进一步发送数据，开始了“保持定时器”（persist timer），以避免连接的双侧进入死锁，发送方无法发出数据直至收到接收方修改窗口的指示。当“保持定时器”到期时，TCP发送方尝试恢复发送一个小的ZWP包（Zero Window Probe），期待接收方回复一个带着新的接收窗口大小的确认包。一般ZWP包会设置成3次，如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。    ————维基百科</em></p><h3 id="2-2-5-TCP拥塞控制"><a href="#2-2-5-TCP拥塞控制" class="headerlink" title="2.2.5 TCP拥塞控制"></a>2.2.5 TCP拥塞控制</h3><h4 id="2-2-5-1-拥塞窗口"><a href="#2-2-5-1-拥塞窗口" class="headerlink" title="2.2.5.1 拥塞窗口"></a>2.2.5.1 拥塞窗口</h4><p>拥塞窗口表示为cwnd，是任何时刻内确定能被发送出去的字节数的控制因素之一，它和rwnd一同决定发送方能向网络中发送的数据量。<em>。由发送方维护。当一条连接创建后，每个主机独立维护一个拥塞窗口并设置初始值为1</em>MSS，MSS 的值一般为 1460 字节，然后根据链路的拥塞程度，将动态地改变拥塞窗口的大小。</p><p>LastByteSent - LastByteAcked为发送方已发送但未被确认的字节量，LastByteSent - LastByteAcked &lt;&#x3D; min {cwnd，rwnd}，当LastByteSent - LastByteAcked &#x3D; min {cwnd，rwnd}时，说明发送方不能再发送报文段了，需要等待两个窗口都有空闲容量。</p><p><strong>拥塞窗口</strong>是阻止发送方至接收方之间的链路变得拥塞的手段发送方维护的，<strong>滑动窗口</strong>是为了防止接收方TCP缓存满了而导致的溢出。</p><h4 id="2-2-5-2-慢启动"><a href="#2-2-5-2-慢启动" class="headerlink" title="2.2.5.2 慢启动"></a>2.2.5.2 慢启动</h4><p>慢启动初始启动时，拥塞窗口cwnd被设置为1个MSS。每当传输的报文段首次被确认就增加1个MSS，这样一来，每个RTT内，cwnd的值呈现指数增加。</p><ul><li>当cwnd &gt;&#x3D; ssthresh时，（说明链路上可能有拥塞）结束慢启动并且TCP转移到拥塞避免模式。</li><li>当存在一个因超时产生的丢包（即拥塞），TCP发送方将ssthresh（慢启动阈值）设置为cwnd&#x2F;2，然后将cwnd设置为1MSS并重新开始慢启动。</li><li>当检测到3个冗余的ACK，TCP执行快速重传，并进入快速恢复状态。</li></ul><h4 id="2-2-5-3-拥塞避免"><a href="#2-2-5-3-拥塞避免" class="headerlink" title="2.2.5.3 拥塞避免"></a>2.2.5.3 拥塞避免</h4><p>在慢启动阶段，cwnd&#x3D;ssthresh，这个ssthresh的值为上次因为拥塞而设置的ssthresh&#x3D;cwnd&#x2F;2，所以当两者相等时，可能很快又会拥塞，因此cwnd不能再呈指数增加了。</p><p>在拥塞避免阶段，每个RTT只将cwnd的值增加一个MSS。</p><ul><li><p>当出现超时产生的丢包时，TCP发送方将ssthresh设置为cwnd&#x2F;2，然后将cwnd设置为1MSS并重新开始慢启动。</p></li><li><p>当出现丢包时（收到三个冗余ACK触发），ssthresh的值被更新为cwnd&#x2F;2，并进入快速恢复状态。</p></li></ul><h4 id="2-2-5-4-快速恢复"><a href="#2-2-5-4-快速恢复" class="headerlink" title="2.2.5.4 快速恢复"></a>2.2.5.4 快速恢复</h4><p>🚨当收到3个冗余ACK，cwnd &#x3D;  ssthresh + 3*MSS ，然后重传丢失的报文段（快重传），当再次收到重复的之前ACK（说明接收方还是收到的报文段的序列号还是比他期望收到的序列号大，因此接收方继续发送冗余ACK），cwnd &#x3D; cwnd + 1，最终当收到新的数据包的ACK后（丢失的包已经传到接收方了，收到的是丢失的报文段的ACK），说明可以恢复到正常的状态了，cwnd &#x3D; ssthresh（拥塞避免阶段的门限值 6 ），进入拥塞避免阶段。</p><p><img src="/../../../image/protocol/%E6%8B%A5%E5%A1%9E%E6%9C%BA%E5%88%B6.jpg" alt="拥塞机制"></p><p><strong>快重传：</strong>当接收方接收到的报文段的序号比他期望接收到的序列号大时，说明在数据包传输的过程中产生了丢包现象或者重新排序的现象，由于TCP采用累积确认，因此必须接收到有序的报文段，但允许接收方不丢弃失序报文段，同时因为不采用显式确认，所以接收方向发送方发送三个相同数据的冗余ACK（即对已经接收到的最后一个按序字节数据进行重复确认），发送方一旦收到三个冗余的ACK，就进行快速重传，重传冗余ACK后面的那个报文段。</p><blockquote><p>为什么发送方等待3个冗余的ACK，而不是仅仅等待一个冗余ACK？</p></blockquote><blockquote><p>发送n,n+1,n+2但是由于网络原因n+1，n+2先到了，这时候会产生2个n的冗余ack，然后发送端就会重新发送n。大致原因是因为网络传输是不可靠的，丢包、乱序和复制等情况，如果出现三次以上DupAck的就认为丢包的可能性很高，可以进入快速重传机制。—-有待考证</p></blockquote><p>😊TCP 保证可靠传输的机制有如下几种：</p><ul><li>1）校验和 Checksum（稍作了解即可）</li><li>2）序列号和确认应答机制（重要）</li><li>3）重传机制（重要）</li><li>4）流量控制（滑动窗口协议）（非常重要）</li><li>5）拥塞控制（重要）</li></ul><blockquote><p><strong>&#x2F;protocol&#x2F;拥塞机制.jpg 图片</strong>和上面写的<strong>TCP保证可靠传输的方法种类</strong> 来源：<a href="https://juejin.cn/post/6916073832335802382#heading-6">https://juejin.cn/post/6916073832335802382#heading-6</a></p></blockquote><h1 id="3-网络层协议"><a href="#3-网络层协议" class="headerlink" title="3.网络层协议"></a>3.网络层协议</h1><h2 id="3-1-数据平面"><a href="#3-1-数据平面" class="headerlink" title="3.1 数据平面"></a>3.1 数据平面</h2><h3 id="3-1-1-IPv4"><a href="#3-1-1-IPv4" class="headerlink" title="3.1.1 IPv4"></a>3.1.1 IPv4</h3><h4 id="3-1-1-1-IP数据报结构"><a href="#3-1-1-1-IP数据报结构" class="headerlink" title="3.1.1.1 IP数据报结构"></a>3.1.1.1 IP数据报结构</h4><p><img src="/../../../image/protocol/IP.png" alt="IP"></p><p><strong>版本号</strong>：4bits，指示使用的是ipv4还是ipv6</p><p><strong>首部长度</strong>：4bits，用来判断IP数据报的有效载荷的位置。大多数IP数据报不包含选项字段，所以一般首部长度为20字节。</p><p><strong>服务类型</strong>：8bits，主要用来标识这个数据报是实时的还是非实时的，<em>在网络拥塞的情况下会斟酌数据报的发送顺序—-我觉得</em></p><p><strong>数据报长度</strong>：16bits，这是IP数据报的总长度，即首部加数据的长度。所以IP数据报的最大长度为2的16次方，即65535字节。由于下面的原因，IP数据报的长度一般不超过1500字节。</p><blockquote><p>网络层数据包经过数据链路层的封装后，形成“帧”，帧头是14字节，帧尾是4字节。MTU为最大链路层帧长度，其实是帧中有效载荷的长度，即IP数据报的长度。MTU由链路层协议规定，一般以太网和PPP协议都具有1500字节的MTU，所以IP数据报的最大长度为1500字节，而帧长为1518字节。由于TCP&#x2F;IP头部长度为40字节，所以MSS（最大报文段长度，应用层数据的长度）不能超过1460字节。</p><p>同时规定帧的最小长度为64字节，如果IP数据报长度小于64 - 18字节的话，在数据链路层封装的时候会利用填充字段将帧长度填充到64字节。</p><p>——–百度 and 《自顶向下》</p></blockquote><p><strong>16比特的标识、标志、13比特的片偏移</strong>：与IP分片有关。</p><p>由于在传输的过程中可能在不同的链路中采用的是不同的链路层协议，而不同的链路层协议可能有不同的MTU，所以有时候需要路由器对数据包分片。当IP数据报的长度超过MTU时，需要将IP数据报中的数据（TCP报文段）进行分片，然后将分片好的TCP报文段都加上IP首部，然后再都加上链路层首部。</p><p>*标识号：16bits，发送主机会将它发送的每个数据报的标识号加1，即刚从发送主机发送出去的时候每个数据报有唯一的标识号。如果在传输的过程中，路由器对它进行分片，则每个新的片（新的IP数据报）的标识号都是相同的，都是没有分片前的那个标识号。源和目的IP地址也是相同的。</p><p>*标志：分片后，最后一个片的标志为0，其他片的标志为1，说明如果目的主机发现标志为0时，说明目的主机已经收到了初始数据报的最后一个片。</p><p>*片偏移：指定该片应该放在IP数据报的哪个位置，进而可以按照正确的顺序组装TCP报文段，也防止丢失哪个片。</p><blockquote><p>—已解决—-</p><p><em>下面说的都是在TCP发送缓冲区进行分片的情况，是对http报文进行分片，和上面的不一样，上面的是在传输的过程中由路由器进行的分片，而且是对TCP报文段分片。</em></p><p>11111.如果TCP发送缓冲区的数据大小超过MSS，发送主机会将它分片，但是主机如何标识TCP缓冲区中的分片后的数据是来自同一个http报文段，以及如果一个报文段的长度特别小，那么主机会等待TCP缓冲区内的数据量多一点时，再发送，但是这时候应该是将缓冲区中的数据一起，并且加上一个TCP首部，这还能区别是不同的http报文段吗？————–这应该是通过http的Content-Length字段指明body的长度。</p><p>22222.但是如果tcp缓冲区分片，导致一个http请求被分成多个分片放入不同的TCP报文段中，然后有一个TCP报文段丢失了，这时如何使接收方接收到完整的http报文?   ————-发送主机会重传这个报文段，因为TCP有差错检验机制，和累积确认，接收到的报文段会先放在TCP接收缓存中，如果是按序的，就直接交付给上层，如果不是按序的，接收方会发送三个冗余ack，进行快速重传。</p></blockquote><p><strong>寿命</strong>：4bits，TTL字段用来防止数据包在链路中形成环路。每经过一台路由器，TTL字段就减一。当TTL字段减为0时，数据包将要被丢弃。</p><p><strong>协议</strong>：用来标识使用的是TCP协议（6）还是UDP协议（17），或者是其他协议。指示IP数据报的数据部分使用的是哪个协议，应该交给哪个运输层协议。它是网络层和运输层绑定到一起的粘合剂。</p><p><strong>首部检验和</strong>：16bits，将IP首部每2个 字节作为一个数，依次对这些数进行反码运算，然后将运算结果填入到首部检验和字段，当路由器收到IP数据报后，会再次运算检验和（TTL字段和可选的选项字段的值在运输的过程中会发生改变），如果和首部检验和字段不一样，就会丢弃这个数据包。</p><blockquote><p>为什么TCP&#x2F;IP在网络层和运输层都执行检验和的差错检测？</p><ul><li><p>TCP&#x2F;UDP检验和是对整个TCP&#x2F;UDP报文段求，并将和的反码放入检验和字段中，而IP检验和仅仅对IP首部求检验和。</p></li><li><p>TCP&#x2F;UDP和IP不一定都属于同一个协议栈，IP数据报有可能携带的数据字段不是使用的TCP&#x2F;UDP协议。而其他协议不一定有检验和。（TCP可以运行在不同的协议上，如ATM）</p></li></ul><p>————《自顶向下》</p></blockquote><p><strong>源和目的IP地址</strong>：均为32bits</p><p><strong>选项</strong>：32bits，一般不使用选项字段，这样可以节约开销。</p><p><strong>数据</strong>：IP数据报携带的数据，即有效载荷。数据字段包含的是运输层报文段。该字段可以承载TCP、UDP报文段，也可以是其他类型的数据，如ICMP报文段。</p><h4 id="3-1-1-2-IP编址"><a href="#3-1-1-2-IP编址" class="headerlink" title="3.1.1.2 IP编址"></a>3.1.1.2 IP编址</h4><ol><li><p>分类编址</p><p>最开始的时候，IP地址的网络部分被限制为长度为8、16、24比特，这被称为分类编址。具有8、16、24比特的子网地址的子网被成为A、B、C类网络。但是这种方法十分有局限性，比如，如果一个组织有2000台主机，而C类网络能容纳2的8次方-2台&#x3D;254台主机，不够，而B类网络能容纳2的16次方-2台&#x3D;65534台主机，又太大了，会浪费很多地址。</p></li><li><p>CIDR无类别域间路由选择</p><p>由于分类编址的局限性，因此提出了CIDR，这个策略可以划分不同的网络部分，只需要在用点分十进制表示的IP地址的后面加上 &#x2F; 和网络部分的位数就可以了，它可以根据一个组织中的主机数来分配最小可以容纳这个主机数的子网。一个地址的&#x2F;x部分，即32-x比特可以用来区分同一个网络前缀的子网内部的不同主机。</p></li></ol><h4 id="3-1-1-3-DHCP协议分配IP地址"><a href="#3-1-1-3-DHCP协议分配IP地址" class="headerlink" title="3.1.1.3 DHCP协议分配IP地址"></a>3.1.1.3 DHCP协议分配IP地址</h4><p>ICANN组织管理着所有的IP地址，所有的ISP都会先向ICANN申请一块很大的地址，然后当在某个ISP中又有网络管理员，用来从ISP的大地址中给某个组织分配子网的IP地址。当一个组织得到一块子网地址后，会利用这个地址内的DHCP服务器给新进来子网的主机分配IP地址。如果这个子网里没有DHCP服务器，则需要一个DHCP中继代理器（一个路由器），它知道可以给这个子网内的主机分配IP地址的DHCP服务器的地址。</p><p><strong>DHCP协议</strong>：动态主机配置协议。</p><p>111.首先新进子网的主机还没有IP地址，它先使用0.0.0.0作为本主机的源IP地址，向这个子网中发送一个<strong>DHCP发现报文</strong>，目的IP地址是255.255.255.255，利用UDP报文向端口67发送该报文，即将这个发现报文广播到子网的所有主机和路由器上。</p><p>222.DHCP服务器收到发现报文后，就向该子网的所有节点广播，发送一个DHCP提供报文，里面的源IP地址是DHCP服务器的地址，目的IP地址是255.255.255.255，报文中携带给这个主机分配的IP地址和它的租用期等相关信息。</p><p>333.因为该子网中可能有一个或多个DHCP服务器，所以可能接收多个DHCP提供报文，那么这个主机就选择一个DHCP服务器，向它发送DHCP请求报文，源IP地址还是0.0.0.0，目的IP地址是这个服务器的IP地址，里面携带新分配的IP地址以及它的租用期。</p><p>444.DHCP服务器收到后仍然广播发送一个DHCP ACK报文，当用户收到这个报文后，就可以使用新分配的IP地址了。</p><p><img src="/../../../image/protocol/DHCP.jpg" alt="DHCP"></p><p>yiaddr：DHCP向客户分配的IP地址，这个服务器推荐客户机用这个IP地址。</p><h4 id="3-1-1-4-NAT网络地址转换"><a href="#3-1-1-4-NAT网络地址转换" class="headerlink" title="3.1.1.4 NAT网络地址转换"></a>3.1.1.4 NAT网络地址转换</h4><p>当某个组织被分配一块地址后，随着该子网中的主机数越来越多，很有可能这些地址不够分配，所以现在就出现了一个方法：网络地址转换。即这个子网只给路由器分配一个IP地址，将与路由器相连的主机群定义为具有专用地址的地域，就是这个地址只有在这个地域网络中才有效，到互联网中就无效。</p><p>它是如何实现的呢？在路由器（<strong>中间盒</strong>）中有一个NAT转换表，LAN端是这些主机的IP地址和端口号，WAN端是路由器的IP地址和新分配的端口号。</p><p>每次主机向互联网发送数据包时，路由器会根据NAT表将重写源地址和端口号（这个端口号是路由器选择的未在NAT转换表中出现过的端口号，这样才可以唯一定位主机和对应端口号，并在NAT表中增加这个记录），接收外界数据包时，路由器通过查询NAT表，重写目的IP地址和端口号，并向这个主机转发该数据报。</p><table><thead><tr><th>WAN端</th><th>LAN端</th></tr></thead><tbody><tr><td>138.76.29.7，5001</td><td>10.0.0.1，3345</td></tr><tr><td>138.76.29.7，4000</td><td>10.0.0.2，1253</td></tr></tbody></table><p>比如，138.76.29.7是路由器与互联网连接的IP地址，10.0.0.4是与专用网络连接时使用的IP地址。</p><h3 id="3-1-2-IPv6"><a href="#3-1-2-IPv6" class="headerlink" title="3.1.2 IPv6"></a>3.1.2 IPv6</h3><p><img src="/../../../image/protocol/IPv6.png" alt="IPv6"></p><p><strong>版本</strong>：标识这个IP数据报是IPv6</p><p><strong>流量类型</strong>：8bits，就是服务类型，是实时数据还是非实时数据。</p><p><strong>流标签</strong>：20bits，——不太理解——-</p><p><strong>有效载荷</strong>：16bits，给出了IPV6携带的数据的字节数量。IPv6的首部是定长20字节。</p><p><strong>下一个首部</strong>：数据报携带的数据应该交付给哪个运输层协议。</p><p><strong>跳限制</strong>：即数据报的寿命，TTL</p><p><strong>源和目的IP地址</strong>：ipv6将IP地址的长度从32位扩展到128位，还引入了任播地址。</p><p>可以利用隧道进行IPV4到IPv6的迁移。隧道就是两台IPv6路由器中间的中间IPv4路由器的集合。通过隧道的时候，将IPv6数据报作为有效载荷封装到IPv4数据报中，在IPv4路由器中传递，到隧道出口再将IPv6数据报取出，交给IPv6路由器。</p><p><strong>IPv6与IPv4的区别</strong>：1.取消了在传输过程中的分片和重新组装。如果路由器发现IP数据报的长度超过MTU时，直接丢弃这个数据报，并向发送方发送一个“包太大”的ICMP报文。2.取消了选项字段。3.取消了首部检验和，因为运输层和数据链路层的协议已经执行了检验操作，在网络层再进行检验增加了开销，比较耗时。————<em>在上面解释为什么IPv4需要进行检验的时候说运输层可能不是TCP&#x2F;UDP协议，所以可能没有检验和的操作，所以IP数据报中需要进行检验和的操作，现在IPv6里面又说这两层都进行了检验和操作，这不是矛盾了吗？</em></p><h2 id="3-2-控制平面"><a href="#3-2-控制平面" class="headerlink" title="3.2 控制平面"></a>3.2 控制平面</h2><h3 id="3-2-1-OSPF"><a href="#3-2-1-OSPF" class="headerlink" title="3.2.1 OSPF"></a>3.2.1 OSPF</h3><p><strong>OSPF</strong>：开放最短路径优先，是自治系统<strong>内部</strong>的路由选择协议。它是一种链路状态协议，使用洪泛链路状态信息和链路状态路由选择算法LS。所谓洪泛，就是在AS内部，每当一条链路的状态发生变化，与它相连的路由器将向自治系统内所有的其他路由器广播路由选择信息。先通知与这个路由器端口连接的所有路由器，然后通知与之相连的其他路由器，直到通知到AS的所有路由器。其实，即使链路状态不发生改变，每隔至少30min路由器也会周期性的广播一次链路状态信息，目的是增强链路算法的健壮性。</p><p>路由器间如何交流？根据OSPF协议，路由器发送由IP数据报承载的OSPF报文。</p><h3 id="3-2-2-BGP"><a href="#3-2-2-BGP" class="headerlink" title="3.2.2 BGP"></a>3.2.2 BGP</h3><p><strong>BGP</strong>：边界网关协议，自治系统间的路由选择协议。</p><p><strong>通告BGP信息</strong>：当一个AS内新增一个具有某个前缀的子网，与子网相连的路由器会通过BGP协议，将这个子网通告给其他AS。在每个AS内，有连接到其他AS中路由器的网关路由器，也有仅连接在当前AS的内部路由器。在AS内部转发的BGP报文称为iBGP，在AS间转发的BGP报文称为eBGP。两个路由器利用BGP协议进行通信时，他们通过使用179端口的半永久TCP连接交换路由选择信息。</p><p><strong>确定传输的路由</strong>：当某个AS的一台路由器向这个子网发送数据包时，这个路由器到这个子网可能有多条路径，所以路由器需要先确定一个路由。采用的策略：1.热土豆路由选择。路由器仅考虑将分组送出该AS的最短路径，而不管这个AS到目的地其他路径的开销。分组好像”烫手的山芋“。   2.路由器选择算法。路由器被管理员指派本地偏好值，选择具有最高本地偏好值的路由，如果有多条相同本地偏好的路由，那么BGP使用DV算法（看该AS到子网所在的AS的多条路径中，哪个AS跳数最少，看AS-PATH）决定路径。 3.如果经过上面的筛选，还有多条路径，那么就开始热土豆路由选择。4.如果还有，路由器使用BGP标识符来选择路由。</p><h3 id="3-2-3-ICMP"><a href="#3-2-3-ICMP" class="headerlink" title="3.2.3 ICMP"></a>3.2.3 ICMP</h3><p>ICMP报文承载在IP数据报中，由路由器发送给这个分组对应的发送主机上。</p><p>利用这个报文还可以跟踪一台主机到世界上任意一台主机之前的路由的名字和IP地址。</p><p><img src="/../../../image/protocol/ICMP.jpg" alt="ICMP"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络是怎样连接的</title>
    <link href="/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/ComputerNetWork/%E6%80%BB%E7%BB%93/"/>
    <url>/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/ComputerNetWork/%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>网络是怎样连接的</strong></p><p>[TOC]</p><p><img src="/../../../image/image/11.png" alt="11"></p><h1 id="1-浏览器生成HTTP消息"><a href="#1-浏览器生成HTTP消息" class="headerlink" title="1.浏览器生成HTTP消息"></a>1.浏览器生成HTTP消息</h1><h2 id="1-1-浏览器解析URL"><a href="#1-1-浏览器解析URL" class="headerlink" title="1.1 浏览器解析URL"></a>1.1 浏览器解析URL</h2><p><u>URL</u></p><blockquote><p><em>URL的组成   协议:&#x2F;&#x2F;用户名:密码@服务器域名&#x2F;文件路径名</em></p><p><em>协议：http&#x2F;ftp&#x2F;file</em></p><p><em>用户名和密码：指定用户名或密码作为从服务器端获取资源时必要的登录信息，是可省略的。</em></p><p><em>服务器域名：web ftp服务器域名，本机的话是localhost(对应的IP是127.0.0.1)</em></p><p><em>文件路径名：</em>如&#x2F;dir1&#x2F;a.html</p></blockquote><p>如果遇到这种URL（省略文件名）：</p><p><a href="http://baidu.com/">http://baidu.com/</a> 和 <a href="http://baidu.com/">http://baidu.com</a>  ——-&gt; 即<a href="http://baidu.com/index.html">http://baidu.com/index.html</a></p><p><a href="http://baidu.com/dir/">http://baidu.com/dir/</a>  ——-&gt; 即<a href="http://baidu.com/dir/index.html">http://baidu.com/dir/index.html</a></p><p><a href="http://baidu.com/dir">http://baidu.com/dir</a>   ——-&gt; 即 先判断web服务器上是否有文件dir，在判断是否有目录dir </p><h2 id="1-2-HTTP1-1请求消息"><a href="#1-2-HTTP1-1请求消息" class="headerlink" title="1.2 HTTP1.1请求消息"></a>1.2 HTTP1.1请求消息</h2><p><u>HTTP协议</u></p><p>HTTP方法：虽然有这么多，但是经常用的只有前两个，因为比如put delete 方法不安全，因此最多只在公司内网中使用。</p><blockquote><p><strong>注意：通过浏览器的地址栏输入地址，所访问的URL都是get请求</strong></p><p><strong>一. 浏览器会发送get请求的情况</strong></p><ol><li>直接在浏览器地址栏输入某个地址</li><li>点击链接</li><li>表单默认的提交方式</li></ol><p><strong>二.浏览器会发送post请求的情况</strong></p><ol><li>设置表单method &#x3D; “post”</li></ol></blockquote><p>浏览器将URL解析出来的数据填写在请求消息（请求行、消息头、消息体）中对应的内容上</p><p><img src="/../../../image/image/12.png" alt="12"></p><p><strong>消息头字段类型</strong></p><p><img src="/../../../image/image/17.png" alt="17"></p><p><img src="/../../../image/image/18.png" alt="18"></p><p><img src="/../../../image/image/19.png" alt="19"></p><h2 id="1-3-HTTP1-1响应消息"><a href="#1-3-HTTP1-1响应消息" class="headerlink" title="1.3 HTTP1.1响应消息"></a>1.3 HTTP1.1响应消息</h2><p>包括状态行、消息头、消息体</p><p>状态码：1XX——告知浏览器请求的处理进度和情况，主要是临时的响应</p><p>​2XX——表明请求被正常处理了</p><p>​3XX——表明浏览器需要执行进一步操作以正确处理请求</p><p>​4XX——表明客户端发生错误</p><p>​5XX——服务器发生错误</p><p><u>HTTP1.1</u>：头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制(图片)</p><p>在keep-alive中，虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。比如请求网页资源，而一个网页上包含多个图片资源，则浏览器会先给图片预留空间，然后再次发送http请求，获取图片资源。</p><p><u>HTTP2.0</u>：二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧</p><p>1.多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</p><p>2.对于消息头，采用头信息压缩机制。对于相同的头部，不必再通过请求发送，只需发送一次。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。加快传输速率。</p><p>3.在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了HTTPS.</p><p><strong>—————————–TSL协议———————-</strong></p><h1 id="2-发送HTTP请求前的准备"><a href="#2-发送HTTP请求前的准备" class="headerlink" title="2.发送HTTP请求前的准备"></a>2.发送HTTP请求前的准备</h1><p>如果要想服务器发送请求，必须知道它的IP地址才可以发送，因此现在浏览器要向DNS服务器查询服务器的IP地址</p><h2 id="2-1-查询服务器的IP地址"><a href="#2-1-查询服务器的IP地址" class="headerlink" title="2.1 查询服务器的IP地址"></a>2.1 查询服务器的IP地址</h2><p>浏览器调用<strong>解析器</strong>，生成向<strong>DNS服务器</strong>发送查询的请求，解析器再调用os的协议栈向DNS服务器发送这个查询请求，查到后，DNS服务器发送IP地址给协议栈，协议栈在返回到解析器，解析器将IP地址存放到浏览器的指定内存中</p><h3 id="2-1-1-解析器"><a href="#2-1-1-解析器" class="headerlink" title="2.1.1 解析器"></a>2.1.1 解析器</h3><p><strong>定义：</strong>解析器实际上是一段应用程序（程序名为gethostbyname(String  要查询的域名)），包含在OS的Socket库中。</p><p><strong>工作原理：</strong> &lt;内存空间&gt; &#x3D; gethostbyname( 要查询的域名)</p><p>​<code>↓</code>（解析器只负责生成  发送给DNS服务器的查询消息）</p><p>​委托协议栈发送查询消息</p><p>​<code>↓</code></p><p>​  网卡</p><p>​<code>↓</code></p><p>​DNS服务器（本机上配置的那个DNS服务器）</p><p>​<code>↓</code></p><p>​匹配到域名对应的DNS服务器，并查询到IP地址</p><p>​<code>↓</code></p><p>​将IP地址返回给协议栈，协议栈返回给函数体中的接收DNS服务器返回的响应消息</p><p>​<code>↓</code></p><p>​解析器将IP地址存放到浏览器的指定内存中</p><p><u>hosts文件：当用户在浏览器中输入一个url时，协议栈会首先自动从hosts文件中寻找对应的IP地址，如果找到了，就将IP地址给解析器，如果没有找到，则协议栈会将域名提交给DNS域名解析服务器进行IP地址的解析。</u>   比如  本地域名和IP的映射</p><p><img src="/../../../image/image/33.png" alt="33"></p><h3 id="2-1-2-DNS服务器"><a href="#2-1-2-DNS服务器" class="headerlink" title="2.1.2 DNS服务器"></a>2.1.2 DNS服务器</h3><p><strong>来自客户端的查询消息包括：</strong>域名、Class、记录类型</p><p>Class：用来识别网络的信息。现在都是互联网，因此Class&#x3D;IN</p><p>记录类型：表示域名对应为什么记录。A表示域名对应的是IP地址，MX表示域名对应的是邮件服务器</p><p><strong>域名的层次结构</strong></p><p><a href="http://www.baidu.com/">www.baidu.com</a>.         ——&gt;        域名最后面的点 就表示根域。com为一级域。baidu为二级域。www为服务器的名字，大多数Web服务器都采用www这样的名字，只是惯例</p><p><em>根域的DNS服务器的相关信息已经包含在DNS服务器程序的配置文件中了</em></p><p><em>DNS服务器可以将之前查询过的域名缓存下来（超过一个规定的有效期就会被删除）</em></p><p>本地DNS服务器-&gt;根DNS服务器-&gt;TLD(顶级域) DNS服务器-&gt;权威DNS服务器</p><h1 id="3-将网络包通过网卡发送出去"><a href="#3-将网络包通过网卡发送出去" class="headerlink" title="3.将网络包通过网卡发送出去"></a>3.将网络包通过网卡发送出去</h1><p>获得了服务器的IP地址之后，就可以发送HTTP消息了。</p><h2 id="3-1-创建套接字"><a href="#3-1-创建套接字" class="headerlink" title="3.1  创建套接字"></a>3.1  创建套接字</h2><p>协议栈的内部结构：</p><p><img src="/../../../image/image/61.png" alt="61"></p><h3 id="3-1-1-套接字是什么"><a href="#3-1-1-套接字是什么" class="headerlink" title="3.1.1 套接字是什么"></a>3.1.1 套接字是什么</h3><p>套接字是一个概念，它是对 <u>在协议栈内部用于存放控制信息的内存空间</u> 的一个泛称。</p><p>在这个内存空间中存着一张表，每创建一个套接字，就在这张表中增加一行信息，一行就代表一个套接字。简单来说，套接字就是IP+端口。</p><p>套接字是成对出现的，且每个连接有唯一的一堆套接字。</p><p><strong>套接字描述符</strong>是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。因此根据套接字描述符就可以找到其对应的套接字数据结构。</p><h3 id="3-1-2-为什么要创建套接字"><a href="#3-1-2-为什么要创建套接字" class="headerlink" title="3.1.2 为什么要创建套接字"></a>3.1.2 为什么要创建套接字</h3><p>协议栈在执行收发数据的操作时，需要参考套接字中的信息。比如发送过数据之后，长时间没收到相应信息，这时就需要重新参考套接字中的IP地址，重新发送数据包。</p><h3 id="3-1-3-创建过程"><a href="#3-1-3-创建过程" class="headerlink" title="3.1.3 创建过程"></a>3.1.3 创建过程</h3><p>应用程序调用Socket库的socket函数，这里传入使用的是TCP还是UDP连接。然后调用协议栈，协议栈会分配一个套接字的内存空间，并写入初始状态。返回到socket函数中，该函数返回给应用程序一个套接字描述符，来标识唯一的套接字。</p><h2 id="3-2-连接服务器"><a href="#3-2-连接服务器" class="headerlink" title="3.2 连接服务器"></a>3.2 连接服务器</h2><p>客户端套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。</p><p>服务端一般会在系统启动的时候就创建套接字并等待客户端连接。</p><h3 id="3-2-1-TCP头部"><a href="#3-2-1-TCP头部" class="headerlink" title="3.2.1 TCP头部"></a>3.2.1 TCP头部</h3><p><img src="/../../../image/image/71.png" alt="71"></p><h3 id="3-2-2-连接"><a href="#3-2-2-连接" class="headerlink" title="3.2.2 连接"></a>3.2.2 连接</h3><p>应用程序调用Socket库的connect函数，connect(&lt;描述符&gt;，&lt;服务器IP地址和端口号&gt;，…)，这些信息传递给协议栈中的TCP模块，在TCP模块中创建TCP头部，有了服务器的IP地址和端口号，客户端套接字就知道要连接哪个套接字了。</p><p><strong>————————–三次握手————————-</strong></p><p><strong>客户端：</strong>发送TCP连接包给服务器。167</p><p><strong>服务器端：</strong>接收到包，TCP头部的控制位SYN&#x3D;1说明是连接包，则TCP模块会检查接收方指定的端口号上是否有等待连接的套接字，如果有，则为这个套接字复制一个新的副本，并将发送方IP地址、端口号、序号初始值（序号表示是从第几个字节开始发送的）、窗口大小（发送方一次发送多少字节）信息写入进去，并分配发送缓冲区send buffer和接收缓冲区recv buffer的内存空间，然后生成确认号ACK，窗口大小（接受缓冲区的大小），用这些信息生成一个新的TCP头部，发送给客户端。</p><p><strong>客户端：</strong>收到这个包后，客户端会返回一个表示接收确认的ACK号。</p><p>连接成功后，协议栈会向套接字中写入服务器端的IP地址和端口号，将对应状态改为连接完毕。</p><h2 id="3-3-发送数据"><a href="#3-3-发送数据" class="headerlink" title="3.3 发送数据"></a>3.3 发送数据</h2><h3 id="3-3-1-将HTTP请求放入协议栈的缓冲区"><a href="#3-3-1-将HTTP请求放入协议栈的缓冲区" class="headerlink" title="3.3.1 将HTTP请求放入协议栈的缓冲区"></a>3.3.1 将HTTP请求放入协议栈的缓冲区</h3><p>TCP协议栈维护着两个socket缓冲区：send buffer和recv buffer。要通过TCP连接发送出去的数据都先拷贝到send buffer，即将http消息写入协议栈的缓冲区中。</p><p>TCP发送缓存</p><p>协议栈不是一收到数据就马上发给其中的TCP模块。(但如果一个网络包的长度就超过MSS的话，会将其进行以MSS长度单位进行拆分在再发送)</p><p>两个判断要素：1. MTU 一个网络包的最大长度（包含头部的总长度）</p><p>​MSS 一个网络包中能容纳的最大数据长度 &#x3D; MTU - 头部</p><p>​即缓冲区中的数据长度超过或接近MSS，再将数据发送出去。</p><p>​2. 时间。</p><p>​协议栈内部有一个计时器，等到一定时间如果还没有满足MSS就会直接发送数据包。</p><h3 id="3-3-2-加上TCP、IP和MAC头部"><a href="#3-3-2-加上TCP、IP和MAC头部" class="headerlink" title="3.3.2 加上TCP、IP和MAC头部"></a>3.3.2 加上TCP、IP和MAC头部</h3><p>缓冲区将数据发送给协议栈的TCP模块，在其中加上TCP头部</p><p>（TCP报文段）-&gt; 现在来说说IP模块。IP模块生成IP头部和MAC头部</p><p><strong>生成包含接收方IP地址的IP头部</strong></p><p><img src="/../../../image/image/103.png" alt="103"></p><p><strong>接收方IP字段：</strong>直接查询套接字中记录的目的IP地址即可。</p><p>&#x2F;&#x2F;前面调用connect组件进行套接字连接的时候，就已经将服务器IP地址写入套接字中了。</p><p><strong>发送方IP字段：</strong>填写当前计算机中的网卡的IP地址。</p><p>我们可以显而易见的知道每块网卡的MAC地址，这时候选择哪个网卡来发送数据包呢？需要根据接收方的IP地址，使用<strong>路由表</strong>，选择一个合适的目的路由器，并找到对应的IP地址。</p><p>路由表：<img src="/../../../image/image/105.png" alt="105"></p><p><strong>生成以太网用的MAC头部</strong></p><p><img src="/../../../image/image/107.png" alt="107"></p><p><strong>接收方MAC地址：</strong>上方我们已经知道接收方（路由器）的IP地址，然后查询ARP缓存，如果其中有接收方的MAC地址，就直接使用该地址，如果没有，需要通过<strong>ARP协议</strong>（在同一个子网中）广播查询目标路由器的MAC地址。缓存中的值在一定时间内会被删除。</p><p><strong>发送方MAC地址：</strong>网卡的MAC地址</p><h3 id="3-3-3-将数据包发给网卡"><a href="#3-3-3-将数据包发给网卡" class="headerlink" title="3.3.3 将数据包发给网卡"></a>3.3.3 将数据包发给网卡</h3><p><img src="/../../../image/image/115.png" alt="115"></p><p>网卡的作用：将IP包（数字信息）转换成电或光信号发送出去</p><p><strong>网卡初始化：</strong>打开计算机启动OS时，网卡驱动程序会对硬件进行初始化操作，然后硬件才可以进入可使用的状态。</p><p>数据包首先存放到缓冲区中，接着发送给<strong>MAC模块</strong>，然后发送给<strong>PHY模块</strong></p><p><strong>MAC模块：</strong>将数据包的头部加上报头和起始帧分界符，尾部加上FCS帧校验序列。</p><p><u>0和1两种比特分别对应特定的电压和电流，因此就将可以数字信号转换为了电信号。</u></p><p>报头是一串101010….这样0和1交替的比特序列，因为信号是由 数据信号和时钟信号叠加形成的，因此它的作用是测量时钟信号的特殊信号，以便服务端可以根据报头来筛出数据信号。起始帧分界符标识包的起始位置。</p><p><strong>PHY模块：</strong>将数字信号转换为模拟信号（电信号）。并通过网线发送出去</p><h3 id="3-3-4-开始发送数据"><a href="#3-3-4-开始发送数据" class="headerlink" title="3.3.4 开始发送数据"></a>3.3.4 开始发送数据</h3><p>发送数据，直到服务器接收缓冲区剩余空间为0，同时接收方也会取出数据，并发送数据包，其中 tcp头部，更新窗口大小以及ACK号。</p><p><img src="/../../../image/image/94.png" alt="94"></p><h1 id="4-信号通过集线器、交换机到达互联网接入网"><a href="#4-信号通过集线器、交换机到达互联网接入网" class="headerlink" title="4.信号通过集线器、交换机到达互联网接入网"></a>4.信号通过集线器、交换机到达互联网接入网</h1><p><img src="/../../../image/image/140.png" alt="140"></p><p>为了防止信号衰减，局域网中的网线采用双绞线。</p><h2 id="4-1-集线器"><a href="#4-1-集线器" class="headerlink" title="4.1 集线器"></a>4.1 集线器</h2><p>信号到达集线器后，会被广播到整个网络。（按照以太网的基本架构）</p><p><img src="/../../../image/image/142.png" alt="142"></p><p><img src="/../../../image/image/143.png" alt="143"></p><p>信号到达RJ-45接口后，接着就到达集线器的PHY模块了，会进入中继电路，中继电路会将接受的信号广播到集线器的所有端口上，因此信号从所有端口流出，到达连接在集线器上的所有设备，然后这些设备会根据MAC头部的接收方MAC地址判断信号是否是发给自己的，如果是则接受，反之丢弃。</p><p><u>接收信号的设备可以使交换机、路由器、服务器等。</u></p><h2 id="4-2-交换机"><a href="#4-2-交换机" class="headerlink" title="4.2 交换机"></a>4.2 交换机</h2><p><img src="/../../../image/image/150.png" alt="150"></p><p>交换机的一个端口就相当于计算机的一个网卡，只是没有MAC地址。</p><p><strong>MAC地址表：</strong>主要包含两个字段，一个是发送方的MAC地址，另一个是该发送设备连接在交换机的哪个端口上。“发送方”即将信号发送给交换机的那个设备。</p><p><strong>MAC地址表的维护：</strong>1.当交换机收到包时，就会将该发送方设备的MAC地址、以及连接在交换机的端口号写入到地址表中。这样下次当交换机收到发往这个地址的包时，就可以将它转发到正确的端口。2.有时候也会删除地址表中的一段时间都不使用的某条记录。<strong>防止设备移动时产生问题。？？？</strong></p><p><strong>过程：</strong>信号到达网线接口RJ-45后，由PHY模块进行接收，PHY模块将电信号转换为数字信息，再传递给MAC模块，通过FCS检测如果没有出错则将包放到缓冲区中。然后需要通过交换机的MAC表来确认包转发给哪个端口，即查询包的接收方MAC地址&#x2F;&#x2F;<strong>（下一跳路由的MAC地址）</strong>是否已经在MAC地址表中有记录。如果查询到了，( 根据以太网规则，需要先确认信号收发模块没有信号进来。但是现在交换机都是全双工模式，可以不判断了) 就将包的数字信息转换为电信号，发送出去。如果没有查询到，只能将包混发到除了源端口以外的所有端口上，只要有设备响应，返回响应包，交换机就进行MAC地址表的维护工作。</p><h2 id="4-3-路由器"><a href="#4-3-路由器" class="headerlink" title="4.3 路由器"></a>4.3 路由器</h2><p><img src="/../../../image/image/160.png" alt="160"></p><p><strong>路由器：</strong>基于IP设计的。包括端口模块和转发模块。</p><p><strong>端口模块：</strong>结构和网卡基本相同，都有RJ-45接口，PHY模块，MAC模块。因此路由器的端口也具有MAC地址。</p><p><strong>转发模块：</strong>根据路由表的记录来确定转发目标。路由表根据IP头部的IP地址来确定转发目标。路由表会根据子网掩码的情况，忽略主机号，只匹配目标地址的网络号部分。</p><p>接口表示将包通过接口列中指定的路由器网络接口，即端口来进行转发。</p><p><u>网关</u>表示将包转发到网关列中指定的IP地址（下一跳路由器的地址），如果网关列内容为空时，则IP头中的接收方IP地址就是要转发的目标地址。</p><p><u>跃点</u>数表示距离目标IP地址的距离远近，如果多个目标地址都可以的话，会优先选择跃点数小的进行转发。</p><p><strong>路由器的功能：</strong>路由器的地址转换；包过滤</p><p>路由器的地址转换：解决IP地址不足的问题。</p><p>ISP将一些地址作为私有地址（这些地址是固定的，且一般可重复）。在私有地址的用户向互联网发起请求时，数据包先流入路由器，路由器中含有地址转换的模块；地址转换模块管理着地址转换表，通过表里面预先设定的记录 会将含有私有地址的数据包的IP头部中的发送方IP地址转为设定的公有地址，在将数据包传输到以太网中。</p><p><img src="/../../../image/image/179.png" alt="179"></p><p>接收互联网的响应和发送正好相反；公有地址路由器通过收到响应数据的端口来确定数据是发给哪个私有地址，通过地址转换模块将包IP转为私有地址IP进而来发送响应数据</p><p><strong>路由表：</strong></p><p><img src="/../../../image/image/163.png" alt="163"></p><p><strong>过程：</strong>首先，路由器将委托端口的硬件将包接收进来，这一步选择哪个端口接收取决于信号是遵守哪个规范，如果是按照以太网规范进行工作的，就用以太网端口进行接收。</p><p>信号到达网线接口，将其传给PHY模块，MAC模块，将信号转换为数字信息，然后根据FCS进行错误校验，然后<u>检查接收方MAC地址是否与路由器端口的MAC地址一致</u>（这里其实在交换机处已经校验过了，再次校验的原因是，如果交换机的MAC表中没有找到对应的MAC地址，它将会把包转发到所有除源端口以外的端口，这时路由器就需要再校验一遍是不是发给自己的包），一致则接收，否则丢弃。</p><p>当包到达路由器时，MAC头就会被丢弃。然后通过转发模块的路由表选择下一个转发目标的IP地址，然后根据ARP协议查询它的MAC地址，作为接收方MAC地址，发送方MAC地址就是输出端口的MAC地址，然后写入新的MAC头部中。</p><p>然后通过路由表指定的输出端口发送包。不同的网络传输协议可能不同，输出端口所能允许的包长度也不一样，因此有时候需要将包分片，TCP头部和数据部分视作一整个数据包进行切分；根据协议允许的最大传输长度MTU。</p><p>如果路由表中找不到匹配路由时选择默认路由（默认网关），即子网掩码为0.0.0.0  这个值在Windows里面可以直接设置。</p><p><strong>注：</strong>IP（路由器）负责将包送达通信对象这一整体过程，而其中将包传输到下一个路由器的过程是由以太网（交换机）来负责的。这里主要看输出端口的类型，此时输出端口为以太网。</p><h1 id="5-通过接入网到达互联网内部"><a href="#5-通过接入网到达互联网内部" class="headerlink" title="5.通过接入网到达互联网内部"></a>5.通过接入网到达互联网内部</h1><p>接入网，就是指连接互联网与家庭、公司网络的通信线路。一般家用的接入网方式包括ADSL、FTTH、电话线、CATV、ISDN，公司还可能使用专线。</p><p><strong>接入网的整体结构：</strong>ADSL和FTTH</p><p><img src="/../../../image/image/194.png" alt="194"></p><p><img src="/../../../image/image/214.png" alt="完整214"></p><h2 id="5-1-ADSL接入网"><a href="#5-1-ADSL接入网" class="headerlink" title="5.1 ADSL接入网"></a>5.1 ADSL接入网</h2><p>ADSL：不对称数字用户线，利用电话线将用户接入互联网的一种技术。即采用与电话线共用的线路的方式，避免额外接线的方式。</p><h3 id="5-1-1-网络包来到互联网接入路由器"><a href="#5-1-1-网络包来到互联网接入路由器" class="headerlink" title="5.1.1 网络包来到互联网接入路由器"></a>5.1.1 网络包来到互联网接入路由器</h3><p>互联网接入路由器：将私有地址转换成公有地址。</p><p>因为使用路由器上网，BAS下发的参数就会被配置到路由器上，即分配的公有的IP地址也是给路由器。那么计算机会被分配一个私有地址，当向网络发送包时，会先通过路由器将发送方的私有地址转化为公有地址。</p><blockquote><p>计算机被分配一个私有地址，这样说不准确。IP地址其实是分配给计算机上的网卡的。可以在设置窗口中设置IP地址，也可以通过DHCP服务器自动分配IP地址。分配的IP地址会保存在计算机中。</p></blockquote><p><img src="/../../../image/image/200.png" alt="200"></p><h3 id="5-1-2-接入路由器将包发给ADSL-Modem"><a href="#5-1-2-接入路由器将包发给ADSL-Modem" class="headerlink" title="5.1.2 接入路由器将包发给ADSL Modem"></a>5.1.2 接入路由器将包发给ADSL Modem</h3><p>互联网接入路由器和ADSL Modem之间是通过以太网连接的，因此会按照以太网的规则来发送包。</p><p><strong>过程：</strong>互联网接入路由器接收到包后，将MAC头部去掉，并在IP头部前面加上MAC、PPPoE、PPP头部，然后发送给ADSL Modem。MAC头部和PPPoE头部的作用是将包送达BAS的接口。</p><h3 id="5-1-3-ADSL-Modem将ADSL信号发给分离器"><a href="#5-1-3-ADSL-Modem将ADSL信号发给分离器" class="headerlink" title="5.1.3 ADSL Modem将ADSL信号发给分离器"></a>5.1.3 ADSL Modem将ADSL信号发给分离器</h3><blockquote><p><strong>ADSL Modem：</strong>ADSL调制解调器。由调制器和解调器两部分组成，调制器是把计算机的数字信号调制成可在电话线上传输的电信号的装置，在接收端，解调器再把电信号转换成计算机能接收的数字信号。</p></blockquote><p><strong>过程：</strong>ADSL接收到包后，将包拆分成ATM信元，然后通过调制将信元转换成电信号，发送给分离器。</p><p><u>为什么拆分成ATM信元而不是其他格式的呢？</u>原因是许多通信运营商最开始传输数据是通过ATM技术实现的，这种技术传的就是信元，为了避免数据包与其他设备要求传输的类型不同，就直接按照ATM信元来传输了。</p><h3 id="5-1-4-分离器将ADSL信号发给DSLAM"><a href="#5-1-4-分离器将ADSL信号发给DSLAM" class="headerlink" title="5.1.4 分离器将ADSL信号发给DSLAM"></a>5.1.4 分离器将ADSL信号发给DSLAM</h3><p><strong>分离器：</strong>因为网络信号与电话信号都使用了电话线进行传输，所以需要在用户终端和接入互联网部分将二者分离，所以引入了分离器，根据两者信号频率的不同实现了信号的分离。将一定频率以上的信号过滤掉，即过滤掉ADSL使用的高频信号，这样当接收信号时，电话信号会传入电话机，而ADSL信号则传入ADSL Modem中。分离器也有逆向的合并功能，即将电话来的低频的语音信号和ADSL来的高频数据信号频率合并成一个信号通过电话线逆向地发送。</p><blockquote><p>第一个分离器：将电话信号和ADSL信号汇合在一起，发送出去。</p><p>第二个分离器：将电话信号和ADSL信号根据不同频率分离，电话信号就发送给电话交换机，进而发送给电话网，ADSL信号发送给DSLAM。</p></blockquote><p><strong>过程：</strong>第一个分离器将电话信号和ADSL信号汇合在一起，发送出去。进入用户端电话局，内部：通过配线盘，发送给第二个分离器，它将ADSL信号（电信号）分离出来，发送给DSLAM。</p><h3 id="5-1-5-DSLAM将ADSL信号发送给BAS"><a href="#5-1-5-DSLAM将ADSL信号发送给BAS" class="headerlink" title="5.1.5 DSLAM将ADSL信号发送给BAS"></a>5.1.5 DSLAM将ADSL信号发送给BAS</h3><p><strong>DSLAM：</strong>将多个ADSL Modem整合在一个外壳里的设备。具有ATM接口，可以接收ATM信元，也可以将收到的ATM信元还原成原始的包。</p><p><strong>过程：</strong>DSLAM通过读取信号波形，根据振幅和相位判断对应的比特值，将电信号还原为数字信息—信元，通过ATM交换机发送给BAS。</p><h3 id="5-1-6-BAS通过隧道将网络包发给网络运营商"><a href="#5-1-6-BAS通过隧道将网络包发给网络运营商" class="headerlink" title="5.1.6 BAS通过隧道将网络包发给网络运营商"></a>5.1.6 BAS通过隧道将网络包发给网络运营商</h3><p><strong>BAS：</strong>宽带接入服务器，其实它是一种路由器，具有ATM接口，可以接收ATM信元。即运营商的进化型路由器，他们一般把它安装在电话局中。</p><p><strong>BAS的功能：</strong></p><ul><li><p><strong>用户认证和配置下发。</strong></p><p><strong>用户认证：</strong>ADSL和FTTH接入网中都需要先输入用户名和密码，登录之后才能访问互联网，BAS是登录操作的窗口。BAS使用PPPoE方式实现这个功能。客户端将密码发给BAS的过程，可以采用将密码加密的CHAP方式，或者采用不加密的PAP方式。但一般采用CHAP方式。</p><p><u>PPPoE：</u>因为ADSL和FTTH不能像拨号接入上网那样采用HDLC协议作为容器来传输PPP消息，因此他们用以太网包来装载PPP消息，这一规格就称为PPPoE。</p><p><img src="/../../../image/image/220.png" alt="220"></p><p><img src="/../../../image/image/221.png" alt="221"></p><p><strong>FTTH中的PPP：</strong></p><p><img src="/../../../image/image/222.png" alt="222"></p><p><img src="/../../../image/image/231.png" alt="231"></p><p><strong>配置下发：</strong>在校验密码后，BAS向用户下发TCP&#x2F;IP配置信息。这里下发的配置信息包括分配给上网设备的IP地址、DNS服务器的IP地址以及<u>默认网关的IP地址</u>。BAS下发的信息会被配置到互联网接入路由器的BAS端的端口上，这样路由器就完成接入互联网的准备了。</p><p>默认路由：当路由表中没有匹配到其他路由时，网络包就会被转发到这个默认路由上。</p><p>如果接收方的IP地址在互联网接入路由器中没有找到，则将其转发给BAS下发的默认路由，这个转发是按照PPPoE规则进行的，即要转发的包加上MAC、PPPoE、PPP头部。MAC头部中，接收方MAC地址是通过PPPoE的发现机制查询的BAS的MAC地址，发送方MAC地址是互联网接入路由器的BAS端的端口的MAC地址。</p><p><strong>&#x2F;&#x2F;转发给默认路由 默认网关（路由器的地址）知道，通过ARP查询它的MAC地址，所以MAC地址不应该是这个默认路由的MAC地址吗？？？？？？？？？？？？？？？？？？？？？？</strong></p><p><img src="/../../../image/image/227.png" alt="227"></p></li><li><p><strong>使用隧道方式传输网络包。</strong></p><p>BAS将接收到的ATM信元还原为原始的包，然后去掉MAC头部和PPPoE头部，添加隧道专用头部，然后发到隧道出口的专用路由器，在这里，隧道头部被去掉，IP包被取出，并转发到互联网内部网络运营商的路由器上。</p></li></ul><p><strong>为什么要再经过一个DSLAM设备？？、</strong></p><p><img src="/../../../image/image/200.png" alt="200"></p><h2 id="5-2-光纤接入网（FTTH）"><a href="#5-2-光纤接入网（FTTH）" class="headerlink" title="5.2 光纤接入网（FTTH）"></a>5.2 光纤接入网（FTTH）</h2><p><strong>单模光纤：</strong>纤芯的直径为8~10 μm，相位一致，只能传导一条光线，信号的失真比较小。</p><p><strong>多模光纤：</strong>纤芯的直径为50或者62.5 μm，相位一致，可以有多条不同入射角的光线同时传导，但每条光线入射角不同，到达接收端的时间可能不同，信号宽度被拉伸，失真比较大。</p><p><strong>FTTH主要使用单模光纤。</strong></p><h3 id="5-2-1-直连方式"><a href="#5-2-1-直连方式" class="headerlink" title="5.2.1 直连方式"></a>5.2.1 直连方式</h3><p><img src="/../../../image/image/2141.png" alt="2141"></p><p>包从互联网接入路由器发送出去，到达<strong>光纤收发器</strong>，它将电信号转换成光信号，通过光纤发送出去。然后<strong>多路光纤收发器</strong>将光信号转换为电信号，<strong>BAS</strong>端口接收后，将包转发到互联网内部。</p><h3 id="5-2-2-分路方式"><a href="#5-2-2-分路方式" class="headerlink" title="5.2.2 分路方式"></a>5.2.2 分路方式</h3><p><img src="/../../../image/image/2142.png" alt="2142"></p><p>包从互联网接入路由器发送出去，到达<strong>ONU</strong>（类似于ONU），它将电信号转换成光信号，通过光纤发送出去。然后<strong>OLT</strong>，将光信号转换为电信号，<strong>BAS</strong>端口接收后，将包转发到互联网内部。</p><p>多个用户同时收发网络包时信号会在分光器上碰撞，为了避免这一后果，OLT会调整信号发送时机，并向ONU下发指令，ONU根据OLT的指令来发送数据。</p><h2 id="5-2-接入网将网络包传递到了互联网内部的网络运营商"><a href="#5-2-接入网将网络包传递到了互联网内部的网络运营商" class="headerlink" title="5.2 接入网将网络包传递到了互联网内部的网络运营商"></a>5.2 接入网将网络包传递到了互联网内部的网络运营商</h2><p>现在网络包已经到达互联网内部的网络运营商的路由器上了，然后网络包会从这里进入互联网内部。</p><h3 id="5-2-1-网络包首先进入POP"><a href="#5-2-1-网络包首先进入POP" class="headerlink" title="5.2.1 网络包首先进入POP"></a>5.2.1 网络包首先进入POP</h3><p>POP：运营商为用户接入互联网提供的接入点。</p><blockquote><p>专线不需要用户认证和下发配置。</p></blockquote><p><img src="/../../../image/image/235.png" alt="235"></p><p><img src="/../../../image/image/233.png" alt="245"></p><h3 id="5-2-2-通过POP路由器转发到服务器端的局域网"><a href="#5-2-2-通过POP路由器转发到服务器端的局域网" class="headerlink" title="5.2.2 通过POP路由器转发到服务器端的局域网"></a>5.2.2 通过POP路由器转发到服务器端的局域网</h3><p>网络数据包到达POP路由器后，会查看POP路由器的路由表，如果Web服务器与客户端是连接在一个运营商中的，则路由表中应该有转发的目标地址。然后将包转发出去。如果Web服务器与客户端不是连接在一个运营商中，则网络包需要先转发到服务器所在的运营商（运营商的路由器在和其他运营商的路由器交换路由信息，BGP 边界网关协议），然后再接着转发。</p><p>通过IX可以连接所有运营商，以便运营商们交换数据。IX的核心是具有大量高速的以太网端口的二层交换机，将各个网络运营商的路由器连接到IX核心交换机上，当要通过IX发送数据的时候，IX交换机会先通过ARP查询下一跳路由的MAC地址，然后再发送。</p><p><img src="/../../../image/image/245.png" alt="245"></p><h1 id="6-网络包到达服务器端的局域网"><a href="#6-网络包到达服务器端的局域网" class="headerlink" title="6.网络包到达服务器端的局域网"></a>6.网络包到达服务器端的局域网</h1><p>网络包在进入互联网之后，通过通信线路和运营商网络到达服务器pop端，接着通过电话局、接入网到达服务器端的局域网部分。网络包会通过局域网中的防火墙、缓存服务器、负载均衡器。</p><h2 id="6-1-包先经过防火墙"><a href="#6-1-包先经过防火墙" class="headerlink" title="6.1 包先经过防火墙"></a>6.1 包先经过防火墙</h2><p><strong>防火墙的作用：</strong>只允许发往指定服务器的指定应用程序的网络包通过，屏蔽其他不允许通过的包。实现防火墙的方式主要有包过滤、应用层网关、电路层网关，现在主要使用的是包过滤方式。</p><p>包过滤方式的防火墙同接收方IP地址、发送方IP地址、接收方端口号、发送方端口号、控制位来判断是否允许这个网络包通过。比如下图，如果不想让web服务器访问互联网，即设置为第二行，TCP建立连接，发送的包中TCP控制位为SYN&#x3D;1，ACK&#x3D;0，就将这个包禁止，TCP连接操作就失败了。也要通过端口号来限定只允许访问这个端口的应用程序。除此之外，包过滤方式的防火墙还有地址转换的功能。</p><p><img src="/../../../image/image/259.png" alt="259"></p><h2 id="6-2-根据不同的分担负载的方式，将网络包发送到不同的服务器上"><a href="#6-2-根据不同的分担负载的方式，将网络包发送到不同的服务器上" class="headerlink" title="6.2 根据不同的分担负载的方式，将网络包发送到不同的服务器上"></a>6.2 根据不同的分担负载的方式，将网络包发送到不同的服务器上</h2><h3 id="6-2-1-使用负载均衡器来分担负载"><a href="#6-2-1-使用负载均衡器来分担负载" class="headerlink" title="6.2.1 使用负载均衡器来分担负载"></a>6.2.1 使用负载均衡器来分担负载</h3><p>当服务器的访问量上升时，一台服务器难以维持这样的强度，因此需要负载均衡器通过将请求分配给多台功能相同的Web服务器来平衡负载。</p><p><strong>过程：</strong>首先用负载均衡器的IP地址代替Web服务器的实际IP地址注册到DNS服务器上，这样当客户端根据服务器的域名向DNS服务器上查询IP地址的时候，就会返回负载均衡器的IP地址。然后将请求发送到负载均衡器上。</p><p>负载均衡器再判断将请求转发到哪台Web服务器上。（代理）</p><ul><li><p><strong>操作跨多个页面</strong></p><p>即多次请求都要访问同一个Web服务器。因为 HTTP 是无状态的连接，当会话结束后，在下一次会话中，负载均衡器并不知道和上一次的是否是同一个用户，而且也并不会自动维护用户的上下文。所以为了识别用户，服务端（负载均衡器）给每个登录用户生成一个唯一标识(session_id)，每一个 session_id 和一个session 值绑定在一起，这个值是用户信息加密后的字符串。第一次创建 session 的时候，服务端会在 HTTP 响应中告诉客户端 session_id 并存储在 cookie 字段中，浏览器会提取出这个值，然后以key：value的形式将这个值存储在本地，浏览器后续每次针对该网站的所有请求都会加上这个 session_id，每次服务端收到请求后，就能根据这个 session_id 来确定用户是谁，从而就可以将多次请求转发到同一个Web服务器上。</p></li><li><p><strong>操作没有跨多个页面</strong></p><p>根据Web服务器的负载状况来进行判断。负载均衡器可以定期查询服务器的CPU、内存使用率等性能。或者发送网络包，判断返回网络包的时间长短。或者查询根据事先设置的服务器的性能指数。</p></li></ul><h3 id="6-2-2-使用代理服务器来分担负载"><a href="#6-2-2-使用代理服务器来分担负载" class="headerlink" title="6.2.2 使用代理服务器来分担负载"></a>6.2.2 使用代理服务器来分担负载</h3><p>现在一般都省略”服务器”这三个字，直接称为正向代理、反向代理、透明代理，其实他们就是服务器。</p><h4 id="6-2-2-1-正向代理"><a href="#6-2-2-1-正向代理" class="headerlink" title="6.2.2.1 正向代理"></a>6.2.2.1 正向代理</h4><p>正向代理的作用：实现防火墙、缓存。</p><p>实现防火墙：代理在转发的过程中可以查看请求消息的内容，因此可以根据内容判断是否允许访问某服务器，从而实现过滤。</p><p><strong>要点：</strong>使用正向代理，需要在浏览器的设置端口的代理服务器中填写正向代理的IP地址，这样浏览器在发送请求时会直接忽略URL中的域名，而将请求发给正向代理。请求行中的URI是整个URL的内容（网址）。请求到达正向代理时，会根据URI将请求转发给对应的Web服务器。</p><h4 id="6-2-2-2-反向代理"><a href="#6-2-2-2-反向代理" class="headerlink" title="6.2.2.2 反向代理"></a>6.2.2.2 反向代理</h4><p>采用在服务端的缓冲服务器的这种方式就是<strong>反向代理</strong>。</p><p>缓存服务器是一台通过代理机制对数据进行缓存的服务器。代理介于Web服务器和客户端之间，具有对Web服务器访问进行中转的功能。它可以将Web服务器返回的数据保存在磁盘中，并可以代替Web服务器将磁盘中的数据返回给客户端。</p><p><strong>过程：</strong>首先用缓存服务器的IP地址代替Web服务器的实际IP地址注册到DNS服务器上，这样当客户端根据服务器的域名向DNS服务器上查询IP地址的时候，就会返回缓存服务器的IP地址。然后将请求发送到缓存服务器上。（TCP连接也是与缓存服务器建立的连接）。然后缓存服务器会查看请求消息的内容，看缓存中是否有请求的结果数据。</p><p>如果磁盘中没有数据，则缓存服务器将HTTP消息头中加上Via字段（表示该请求经过了缓存服务器），并且根据请求行的URI，判断将这个HTTP请求转发给哪个Web服务器。收到Web服务器的响应后，也会在响应消息头中加上Via字段，并将响应消息保存在缓存中，记录保存的时间。然后将响应消息转发给客户端。</p><p>如果磁盘中有数据，则缓存服务器会将HTTP消息头中加上If-Modified-Since头部（上次保存的时间），将消息转发给Web服务器，询问用户请求的数据是否已经变化，Web服务器会查询一下最近更新时间，没变化就返回一个没变化的响应，反之，和没有命中缓存的步骤是一样的。</p><blockquote><p>如果一个缓存服务器对应多个Web服务器时，在缓存服务器中会设置当URI为**时，将请求转发给××（域名）。即将URI中的目录名与Web服务器进行关联。此时缓存服务器相当于客户端，Web服务器相当于服务端，也要经历先创建套接字，建立连接等步骤。如果一个缓存服务器对应一个Web服务器的话，就直接转发就行了。</p></blockquote><p><img src="/../../../image/image/272.png" alt="272"></p><h4 id="6-2-2-3-透明代理"><a href="#6-2-2-3-透明代理" class="headerlink" title="6.2.2.3 透明代理"></a>6.2.2.3 透明代理</h4><p><strong>定义：</strong>利用缓存服务器判断转发目标，这个不用查询之前设置的URI与Web服务器的对应关系，而是直接查看请求消息的IP头部中的接收方IP地址，然后将请求转发到这个IP地址。</p><p>透明代理被放在从浏览器到Web服务器的路径中，当消息经过时首先经过透明代理。这个请求是被粗暴拦截的，而不是像反向代理那样直接将请求发送到缓存服务器上。</p><h3 id="6-2-3-利用内容分发服务来分担负载"><a href="#6-2-3-利用内容分发服务来分担负载" class="headerlink" title="6.2.3 利用内容分发服务来分担负载"></a>6.2.3 利用内容分发服务来分担负载</h3><p>内容分发服务：一些专门的厂商来部署缓存服务器，并租借给Web服务器运营者，可以被Web服务器控制，这种服务称为内容分发服务。</p><p>它和反向代理不一样的地方是：内容分发服务是将缓存服务器<strong>部署在互联网</strong>中，这样可以有效减少互联网中的流量。即请求不必到达Web服务器端。</p><p>**过程：      1.**记录缓存服务器IP地址的DNS服务器上保存有路由表，这个路由表记了不同缓存服务器部署地点的路由器的路由信息。通过将缓存服务器的IP地址替换Web服务器的IP地址注册到DNS服务器上，当浏览器查询客户端DNS服务器来查找接收方的IP地址的时候，DNS服务器会首先根据路由信息估算他们到客户端DNS服务器的距离，选择最短的。        **2.**重定向服务器。通过将重定向服务器的IP地址替换Web服务器的IP地址注册到DNS服务器上，当请求到达重定向服务器时，它根据路由信息估算缓存服务器到客户端（知道发送方IP地址）的距离 ，选择最近的，通过将缓存服务器的IP地址填到请求头的Location字段返回响应。</p><p>Web服务器在原始数据发生更新时，就会立即通知缓存服务器。</p><h1 id="7-请求到达Web服务器"><a href="#7-请求到达Web服务器" class="headerlink" title="7.请求到达Web服务器"></a>7.请求到达Web服务器</h1><p>当Web服务器前面的缓存服务器、负载均衡器的缓存中都没有请求对应的响应数据时，这时需要将请求转发给Web服务器。</p><h2 id="7-1-服务器的初始化"><a href="#7-1-服务器的初始化" class="headerlink" title="7.1 服务器的初始化"></a>7.1 服务器的初始化</h2><p>当服务器程序启动并读取配置文件完成初始化操作后，就会进入<strong>等待连接模块</strong>，在这个模块中，协议栈调用socket创建套接字，然后调用bind，将端口号写入套接字中（描述符标识唯一的套接字，后面的交互中就直接使用描述符就可以了），然后调用<strong>listen</strong>向套接字中写入等待连接的暂停状态这一控制信息，这时套接字就等待客户端的网络包。协议栈调用accept，一旦客户端的包到达，就开始连接操作，没有包到达，就处于暂停状态。</p><p>当客户端发起连接时，这个模块就会恢复运行，连接结束后，套接字已经连接好了，然后等待连接模块就会复制一个套接字副本给客户端通信模块，启动客户端通信模块，然后让客户端连接到这个新的副本套接字上，就由客户端通信模块与客户端通信了。</p><p><img src="/../../../image/image/301.png" alt="301"></p><h2 id="7-2-服务器接收处理网络包"><a href="#7-2-服务器接收处理网络包" class="headerlink" title="7.2 服务器接收处理网络包"></a>7.2 服务器接收处理网络包</h2><p>当客户端发送的网络包到达服务器后，首先经过服务器端的网卡，MAC模块将电信号或光信号转化为0和1这样的数字信息，然后检验FCS，没有错就存入网卡的缓冲区中。此时网卡会产生中断，CPU就来到这个任务中，调用网卡驱动程序，它根据MAC头部的以太类型（0800 -&gt; IP协议），调用处理该协议的软件（TCP&#x2F;IP协议栈）。进入协议栈后，首先IP模块运行，确认包是发给自己的，然后检查是否有分片，如果有，则将包存到内存中，等到分片全部到达再组装还原为原始包，然后根据IP头部的协议号字段（06），将包转交给对应模块（TCP模块）。</p><blockquote><p>———————————三次握手——————————</p><p>如果是<u>连接包</u>。。TCP头部的控制位SYN&#x3D;1说明是连接包，则TCP模块会检查接收方指定的端口号上是否有等待连接的套接字，<strong>如果有，则启动客户端通信模块，并为这个套接字复制一个新的副本，并将发送方IP地址、端口号、序号初始值（序号表示是从第几个字节开始发送的）、窗口大小（发送方一次发送多少字节）信息写入进去</strong>，并分配发送缓冲区send buffer和接收缓冲区recv buffer的内存空间，然后生成确认号ACK，窗口大小（接受缓冲区的大小），用这些信息生成一个新的TCP头部，发送给客户端。</p><p>要确定某个套接字需要  服务器端IP地址和端口号，客户端IP地址和端口号。</p></blockquote><p><strong>收到数据包时，</strong>TCP模块会根据发送方IP地址，端口号，接收方IP地址，端口号找到对应套接字，然后将接收到的数据放入recv buffer。并发送ACK号（一共接收了多少字节数据）和更新窗口大小。</p><p><img src="/../../../image/image/94.png" alt="94"></p><h2 id="7-3-服务器发送响应信息"><a href="#7-3-服务器发送响应信息" class="headerlink" title="7.3 服务器发送响应信息"></a>7.3 服务器发送响应信息</h2><p>服务器程序的客户端通信模块调用read来获取接收到的数据，然后根据HTTP请求行中的URI，在服务器虚拟目录中找到对应关系，再将虚拟目录映射到服务器磁盘上的目录，如果URI指定的是图片或HTML文档，则直接找到响应数据，生成响应消息，协议栈调用write返回给客户端。如果URI指定的是一个程序文件，则需要Web服务器委托OS运行这个程序，获取到数据后再返回给Web服务器。</p><h2 id="7-4-客户端接收响应消息并显示到页面上"><a href="#7-4-客户端接收响应消息并显示到页面上" class="headerlink" title="7.4 客户端接收响应消息并显示到页面上"></a>7.4 客户端接收响应消息并显示到页面上</h2><p>浏览器接收响应数据包，根据Content-Type定义的数据类型，判断响应消息中的数据属于哪种类型，然后浏览器向操作系统发出指令，由操作系统来完成按照不同的方法将数据显示在页面上。</p><p><img src="/../../../image/image/324.png" alt="324"></p><h2 id="7-5-断开连接"><a href="#7-5-断开连接" class="headerlink" title="7.5 断开连接"></a>7.5 断开连接</h2><p>谁先断开都可以，但一般是服务器先断开。服务器调用Socket库中的close函数，四次挥手，删除对应套接字。</p><p><strong>———————————四次挥手——————————–</strong></p><p>完结撒花 ✿✿ヽ(°▽°)ノ✿</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
